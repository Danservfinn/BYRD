<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BYRD - Memory Topology</title>
  <!-- Tailwind CSS for utility classes -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* ==========================================================================
       DARK GLASS-MORPHISM THEME (Supermemory-Inspired)
       ========================================================================== */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Background colors - Pure white theme */
      --bg-primary: #ffffff;
      --bg-secondary: #fafafa;
      --bg-card: #ffffff;

      /* Glass colors */
      --glass-fill: rgba(147, 197, 253, 0.08);
      --glass-border: rgba(147, 197, 253, 0.35);
      --glass-glow: rgba(147, 197, 253, 0.5);
      --glass-highlight: rgba(255, 255, 255, 0.1);

      /* Surface colors (relationship types) */
      --surface-derived: rgba(147, 197, 253, 0.15);
      --surface-causal: rgba(251, 191, 36, 0.15);
      --surface-contradiction: rgba(244, 63, 94, 0.15);
      --surface-support: rgba(34, 211, 238, 0.15);
      --surface-cluster: rgba(168, 85, 247, 0.15);

      /* Node colors - darker for light theme */
      --node-experience: #2563eb;
      --node-belief: #d97706;
      --node-desire: #db2777;
      --node-capability: #7c3aed;
      --node-crystal: #0891b2;
      --node-reflection: #059669;
      --node-goal: #ea580c;
      --node-meta: #64748b;

      /* Text colors - Light theme */
      --text-primary: #1e293b;
      --text-secondary: #334155;
      --text-muted: #64748b;

      /* Accent */
      --accent-blue: #93c5fd;
      --accent-glow: rgba(147, 197, 253, 0.4);

      /* Status */
      --status-new: rgba(16, 185, 129, 0.4);
      --status-active: rgba(147, 197, 253, 0.6);
      --status-forgotten: rgba(220, 38, 38, 0.15);

      /* RSI Phase Colors */
      --rsi-reflect: #8b5cf6;
      --rsi-verify: #6366f1;
      --rsi-collapse: #ec4899;
      --rsi-route: #f59e0b;
      --rsi-practice: #10b981;
      --rsi-record: #3b82f6;
      --rsi-crystallize: #06b6d4;
      --rsi-measure: #84cc16;

      /* RSI Node Colors */
      --node-trajectory: #14b8a6;
      --node-heuristic: #f97316;
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    canvas {
      display: block;
    }

    /* ==========================================================================
       GLASS PANEL BASE STYLE
       ========================================================================== */

    .glass-panel {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 12px;
      box-shadow:
        0 0 30px rgba(100, 116, 139, 0.1),
        0 4px 20px rgba(0, 0, 0, 0.08);
    }

    /* ==========================================================================
       STATS BAR (Top)
       ========================================================================== */

    .stats-bar {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 50px;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .stat-item:hover {
      background: rgba(147, 197, 253, 0.1);
    }

    .stat-item.active {
      background: rgba(147, 197, 253, 0.15);
      border: 1px solid var(--glass-border);
    }

    .stat-icon {
      font-size: 14px;
      opacity: 0.8;
    }

    .stat-label {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat-value {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
    }

    .stat-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    /* ==========================================================================
       TITLE BADGE (Top Left)
       ========================================================================== */

    .title-badge {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
    }

    .title-badge h1 {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 0.02em;
    }

    .title-badge .subtitle {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .connection-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--node-reflection);
      box-shadow: 0 0 8px var(--node-reflection);
      animation: pulse 2s ease-in-out infinite;
    }

    .connection-indicator.disconnected {
      background: #ef4444;
      box-shadow: 0 0 8px #ef4444;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    /* ==========================================================================
       LEGEND PANEL (Bottom Left)
       ========================================================================== */

    .legend-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      padding: 16px 20px;
      min-width: 200px;
    }

    .legend-panel h3 {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(147, 197, 253, 0.2);
    }

    .legend-section {
      margin-bottom: 16px;
    }

    .legend-section:last-child {
      margin-bottom: 0;
    }

    .legend-section-title {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 4px 0;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .legend-shape {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: var(--accent-blue);
    }

    /* ==========================================================================
       INFO PANEL (Left Side - shows when clicking nodes/structures)
       ========================================================================== */

    .info-panel {
      position: fixed;
      top: 80px;
      left: 20px;
      z-index: 101;
      width: 300px;
      max-height: calc(100vh - 400px);
      overflow-y: auto;
      padding: 20px;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.3s ease;
      pointer-events: none;
    }

    .info-panel.visible {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }

    .info-panel h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .info-panel .close-btn {
      margin-left: auto;
      width: 24px;
      height: 24px;
      border: none;
      background: rgba(147, 197, 253, 0.1);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .info-panel .close-btn:hover {
      background: rgba(147, 197, 253, 0.2);
      color: var(--text-primary);
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(147, 197, 253, 0.1);
    }

    .info-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .info-value {
      font-size: 12px;
      color: var(--text-primary);
      font-weight: 500;
    }

    .info-content {
      margin-top: 16px;
      padding: 12px;
      background: rgba(147, 197, 253, 0.05);
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    .info-nodes-list {
      margin-top: 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    .info-node-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      margin-bottom: 4px;
      background: rgba(147, 197, 253, 0.05);
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .info-node-item:hover {
      background: rgba(147, 197, 253, 0.1);
    }

    .info-node-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* ==========================================================================
       CONSOLE PANEL (Right Side)
       ========================================================================== */

    .console-panel {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 100;
      width: 380px;
      height: calc(100vh - 180px);
      display: flex;
      flex-direction: column;
      transition: all 0.3s ease;
    }

    .console-panel.minimized {
      height: 44px;
      overflow: hidden;
    }

    .console-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(147, 197, 253, 0.2);
      background: rgba(248, 250, 252, 0.5);
      border-radius: 12px 12px 0 0;
      flex-shrink: 0;
    }

    .console-panel.minimized .console-header {
      border-radius: 12px;
      border-bottom: none;
    }

    .console-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    .console-count {
      font-size: 10px;
      color: var(--text-muted);
      background: rgba(147, 197, 253, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
      font-family: 'SF Mono', monospace;
    }

    .console-controls {
      display: flex;
      gap: 4px;
    }

    .console-btn {
      width: 26px;
      height: 26px;
      border: none;
      background: rgba(147, 197, 253, 0.1);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      transition: all 0.15s ease;
    }

    .console-btn:hover {
      background: rgba(147, 197, 253, 0.2);
      color: var(--text-primary);
    }

    .console-btn.active {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .console-body {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      background: rgba(255, 255, 255, 0.7);
    }

    .console-event {
      display: flex;
      gap: 10px;
      padding: 8px 10px;
      margin-bottom: 4px;
      background: rgba(248, 250, 252, 0.8);
      border-radius: 8px;
      border-left: 3px solid var(--accent-blue);
      font-size: 11px;
      transition: all 0.15s ease;
    }

    .console-event:hover {
      background: rgba(147, 197, 253, 0.1);
    }

    .console-event.type-belief { border-left-color: var(--node-belief); }
    .console-event.type-desire { border-left-color: var(--node-desire); }
    .console-event.type-experience { border-left-color: var(--node-experience); }
    .console-event.type-goal { border-left-color: var(--node-goal); }
    .console-event.type-capability { border-left-color: var(--node-capability); }
    .console-event.type-reflection { border-left-color: var(--node-reflection); }
    .console-event.type-system { border-left-color: #22c55e; }
    .console-event.type-error { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
    .console-event.filtered { display: none; }

    /* Console Filter Bar */
    .console-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 6px 10px;
      background: rgba(248, 250, 252, 0.5);
      border-bottom: 1px solid rgba(147, 197, 253, 0.15);
    }

    .console-filter-bar.hidden {
      display: none;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      font-size: 9px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1px solid transparent;
      opacity: 0.5;
    }

    .filter-chip.active {
      opacity: 1;
    }

    .filter-chip:hover {
      transform: scale(1.05);
    }

    .filter-chip-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .filter-chip.type-belief { background: rgba(59, 130, 246, 0.15); color: var(--node-belief); }
    .filter-chip.type-belief .filter-chip-dot { background: var(--node-belief); }
    .filter-chip.type-belief.active { background: rgba(59, 130, 246, 0.3); border-color: var(--node-belief); }

    .filter-chip.type-desire { background: rgba(249, 115, 22, 0.15); color: var(--node-desire); }
    .filter-chip.type-desire .filter-chip-dot { background: var(--node-desire); }
    .filter-chip.type-desire.active { background: rgba(249, 115, 22, 0.3); border-color: var(--node-desire); }

    .filter-chip.type-experience { background: rgba(168, 85, 247, 0.15); color: var(--node-experience); }
    .filter-chip.type-experience .filter-chip-dot { background: var(--node-experience); }
    .filter-chip.type-experience.active { background: rgba(168, 85, 247, 0.3); border-color: var(--node-experience); }

    .filter-chip.type-goal { background: rgba(236, 72, 153, 0.15); color: var(--node-goal); }
    .filter-chip.type-goal .filter-chip-dot { background: var(--node-goal); }
    .filter-chip.type-goal.active { background: rgba(236, 72, 153, 0.3); border-color: var(--node-goal); }

    .filter-chip.type-capability { background: rgba(34, 197, 94, 0.15); color: var(--node-capability); }
    .filter-chip.type-capability .filter-chip-dot { background: var(--node-capability); }
    .filter-chip.type-capability.active { background: rgba(34, 197, 94, 0.3); border-color: var(--node-capability); }

    .filter-chip.type-reflection { background: rgba(6, 182, 212, 0.15); color: var(--node-reflection); }
    .filter-chip.type-reflection .filter-chip-dot { background: var(--node-reflection); }
    .filter-chip.type-reflection.active { background: rgba(6, 182, 212, 0.3); border-color: var(--node-reflection); }

    .filter-chip.type-system { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
    .filter-chip.type-system .filter-chip-dot { background: #22c55e; }
    .filter-chip.type-system.active { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }

    .filter-chip.type-error { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
    .filter-chip.type-error .filter-chip-dot { background: #ef4444; }
    .filter-chip.type-error.active { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }

    .filter-actions {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }

    .filter-action-btn {
      font-size: 8px;
      padding: 2px 6px;
      border: 1px solid rgba(147, 197, 253, 0.3);
      background: rgba(255, 255, 255, 0.5);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.15s ease;
    }

    .filter-action-btn:hover {
      background: rgba(147, 197, 253, 0.2);
      color: var(--text-primary);
    }

    .console-event-time {
      font-size: 10px;
      color: var(--text-muted);
      font-family: 'SF Mono', monospace;
      flex-shrink: 0;
      width: 55px;
    }

    .console-event-type {
      font-size: 10px;
      font-weight: 600;
      color: var(--accent-blue);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      flex-shrink: 0;
      width: 70px;
    }

    .console-event-content {
      flex: 1;
      color: var(--text-secondary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .console-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 14px;
      border-top: 1px solid rgba(147, 197, 253, 0.2);
      background: rgba(248, 250, 252, 0.5);
      border-radius: 0 0 12px 12px;
      font-size: 10px;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .console-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .console-connection {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #94a3b8;
    }

    .console-connection.connected {
      background: #22c55e;
    }

    /* ==========================================================================
       CONSOLIDATION INDICATOR (Bottom Right)
       ========================================================================== */

    .consolidation-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .consolidation-bar {
      width: 120px;
      height: 6px;
      background: rgba(147, 197, 253, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .consolidation-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-blue), var(--node-capability));
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    .consolidation-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    .consolidation-text strong {
      color: var(--text-primary);
    }

    /* ==========================================================================
       CONTROLS HINT (Bottom Center)
       ========================================================================== */

    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      gap: 16px;
      padding: 8px 16px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .control-key {
      padding: 2px 6px;
      background: rgba(147, 197, 253, 0.1);
      border: 1px solid rgba(147, 197, 253, 0.2);
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* ==========================================================================
       LOADING STATE
       ========================================================================== */

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      transition: opacity 0.5s ease;
    }

    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(147, 197, 253, 0.2);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 14px;
      color: var(--text-muted);
    }

    /* ==========================================================================
       SCROLLBAR
       ========================================================================== */

    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(100, 116, 139, 0.3);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(100, 116, 139, 0.5);
    }

    ::-webkit-scrollbar-track {
      background: rgba(147, 197, 253, 0.05);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(147, 197, 253, 0.2);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(147, 197, 253, 0.3);
    }

    /* ==========================================================================
       META-NODE & CLUSTER STYLES
       ========================================================================== */

    .meta-node-label {
      position: absolute;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 6px;
      font-size: 10px;
      color: var(--text-secondary);
      white-space: nowrap;
      pointer-events: none;
      transform: translate(-50%, -100%);
      margin-top: -8px;
    }

    .meta-node-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      background: var(--surface-cluster);
      border-radius: 10px;
      font-size: 9px;
      font-weight: 600;
      color: var(--node-capability);
    }

    /* ==========================================================================
       CONSOLIDATION CONTROLS (Top Right)
       ========================================================================== */

    .consolidation-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      padding: 16px;
      width: 280px;
    }

    .consolidation-controls h4 {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .consolidation-controls h4 .badge {
      padding: 2px 6px;
      background: var(--surface-cluster);
      border-radius: 10px;
      font-size: 9px;
      color: var(--node-capability);
    }

    .consolidation-controls h4 .minimize-btn {
      margin-left: auto;
      width: 22px;
      height: 22px;
      border: none;
      background: rgba(147, 197, 253, 0.1);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      transition: all 0.15s ease;
    }

    .consolidation-controls h4 .minimize-btn:hover {
      background: rgba(147, 197, 253, 0.2);
      color: var(--text-primary);
    }

    .consolidation-controls.minimized {
      padding: 12px 16px;
    }

    .consolidation-controls.minimized .control-row,
    .consolidation-controls.minimized .consolidation-stats {
      display: none;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .control-row:last-child {
      margin-bottom: 0;
    }

    .control-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .control-value {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
    }

    .slider-container {
      flex: 1;
      margin: 0 12px;
    }

    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      background: rgba(147, 197, 253, 0.2);
      border-radius: 2px;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px var(--accent-glow);
      transition: transform 0.15s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .control-btn {
      padding: 6px 12px;
      background: rgba(147, 197, 253, 0.1);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .control-btn:hover {
      background: rgba(147, 197, 253, 0.2);
      color: var(--text-primary);
    }

    .control-btn.active {
      background: var(--accent-blue);
      color: var(--bg-primary);
      border-color: var(--accent-blue);
    }

    .control-btn-group {
      display: flex;
      gap: 4px;
    }

    .consolidation-stats {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid rgba(147, 197, 253, 0.1);
    }

    .consolidation-stat {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .consolidation-stat .value {
      color: var(--text-secondary);
      font-weight: 500;
    }

    /* ==========================================================================
       EXPANDED CLUSTER VIEW
       ========================================================================== */

    .cluster-expanded-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(100, 116, 139, 0.3);
      z-index: 500;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .cluster-expanded-overlay.visible {
      display: flex;
    }

    .cluster-expanded-panel {
      width: 600px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      padding: 24px;
    }

    .cluster-expanded-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .cluster-expanded-header h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .cluster-expanded-header .node-count {
      padding: 4px 10px;
      background: var(--surface-cluster);
      border-radius: 12px;
      font-size: 12px;
      color: var(--node-capability);
    }

    .cluster-node-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 12px;
    }

    .cluster-node-card {
      padding: 12px;
      background: rgba(147, 197, 253, 0.05);
      border: 1px solid rgba(147, 197, 253, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .cluster-node-card:hover {
      background: rgba(147, 197, 253, 0.1);
      border-color: var(--glass-border);
    }

    .cluster-node-card .type-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .cluster-node-card .content {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.5;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .cluster-node-card .timestamp {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* ==========================================================================
       NAVIGATION BAR (Bottom)
       ========================================================================== */

    .nav-bar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      gap: 6px;
      padding: 8px 14px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 50px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .nav-btn {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      gap: 4px;
      text-decoration: none;
      white-space: nowrap;
    }

    .nav-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .nav-btn.orange { background: #fff7ed; border-color: #fed7aa; color: #c2410c; }
    .nav-btn.orange:hover { background: #ffedd5; }

    .nav-btn.slate { background: #f1f5f9; border-color: #cbd5e1; color: #475569; }
    .nav-btn.slate:hover { background: #e2e8f0; }

    .nav-btn.purple { background: #f3e8ff; border-color: #d8b4fe; color: #7c3aed; }
    .nav-btn.purple:hover { background: #e9d5ff; }

    .nav-btn.pink { background: #fce7f3; border-color: #fbcfe8; color: #be185d; }
    .nav-btn.pink:hover { background: #fbcfe8; }

    .nav-btn.amber { background: #fffbeb; border-color: #fde68a; color: #b45309; }
    .nav-btn.amber:hover { background: #fef3c7; }

    .nav-btn.blue { background: #eff6ff; border-color: #bfdbfe; color: #1d4ed8; }
    .nav-btn.blue:hover { background: #dbeafe; }

    .nav-btn.teal { background: #f0fdfa; border-color: #99f6e4; color: #0f766e; }
    .nav-btn.teal:hover { background: #ccfbf1; }

    .nav-btn.emerald { background: #ecfdf5; border-color: #a7f3d0; color: #047857; }
    .nav-btn.emerald:hover { background: #d1fae5; }

    .nav-btn.violet { background: #f5f3ff; border-color: #ddd6fe; color: #6d28d9; }
    .nav-btn.violet:hover { background: #ede9fe; }

    .nav-btn.active {
      transform: translateY(0);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #1e293b;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 200;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* ==========================================================================
       MESSAGES PANEL - Chat History
       ========================================================================== */
    .messages-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 380px;
      max-width: calc(100vw - 40px);
      height: 450px;
      max-height: calc(100vh - 120px);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 16px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
      z-index: 500;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .messages-panel.collapsed {
      height: 48px;
    }

    .messages-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(241, 245, 249, 0.8);
      border-bottom: 1px solid rgba(100, 116, 139, 0.15);
      cursor: pointer;
    }

    .messages-panel-header h3 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .messages-panel-header .unread-badge {
      background: #10b981;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 700;
    }

    .messages-panel-toggle {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      transition: color 0.2s;
    }

    .messages-panel-toggle:hover {
      color: var(--text-primary);
    }

    .messages-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message-item {
      display: flex;
      flex-direction: column;
      max-width: 90%;
      animation: messageSlideIn 0.3s ease-out;
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-item.byrd {
      align-self: flex-start;
    }

    .message-item.human {
      align-self: flex-end;
    }

    .message-bubble {
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.5;
    }

    .message-item.byrd .message-bubble {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(6, 182, 212, 0.15));
      border: 1px solid rgba(16, 185, 129, 0.25);
      color: #065f46;
      border-bottom-left-radius: 4px;
    }

    .message-item.human .message-bubble {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
      border: 1px solid rgba(99, 102, 241, 0.25);
      color: #3730a3;
      border-bottom-right-radius: 4px;
    }

    .message-meta {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 4px;
      padding: 0 4px;
    }

    .message-item.byrd .message-meta {
      text-align: left;
    }

    .message-item.human .message-meta {
      text-align: right;
    }

    .message-emotion {
      display: inline-block;
      font-size: 9px;
      padding: 1px 6px;
      border-radius: 8px;
      background: rgba(16, 185, 129, 0.15);
      color: #059669;
      margin-left: 6px;
    }

    .messages-input-area {
      padding: 12px;
      background: rgba(241, 245, 249, 0.6);
      border-top: 1px solid rgba(100, 116, 139, 0.15);
      display: flex;
      gap: 8px;
    }

    .messages-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(100, 116, 139, 0.2);
      border-radius: 8px;
      padding: 10px 12px;
      color: var(--text-primary);
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }

    .messages-input::placeholder {
      color: var(--text-muted);
    }

    .messages-input:focus {
      border-color: rgba(99, 102, 241, 0.5);
    }

    .messages-send-btn {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      color: white;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .messages-send-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .messages-send-btn:active {
      transform: translateY(0);
    }

    .messages-loading {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 12px;
    }

    .messages-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .messages-empty-icon {
      font-size: 32px;
      margin-bottom: 12px;
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading Memory Topology...</div>
  </div>

  <!-- Canvas Container -->
  <div id="canvas-container"></div>

  <!-- RSI Phase Ring (SVG overlay) -->
  <div id="rsi-ring-container" style="
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 100;
    pointer-events: none;
  ">
    <svg width="200" height="200" viewBox="0 0 200 200" id="rsi-ring">
      <g transform="translate(100, 100)">
        <!-- 8 phase segments arranged in a ring -->
        <path id="rsi-seg-reflect" d="M0,-80 A80,80 0 0,1 56.57,-56.57 L0,0 Z"
              fill="var(--rsi-reflect)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-verify" d="M56.57,-56.57 A80,80 0 0,1 80,0 L0,0 Z"
              fill="var(--rsi-verify)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-collapse" d="M80,0 A80,80 0 0,1 56.57,56.57 L0,0 Z"
              fill="var(--rsi-collapse)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-route" d="M56.57,56.57 A80,80 0 0,1 0,80 L0,0 Z"
              fill="var(--rsi-route)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-practice" d="M0,80 A80,80 0 0,1 -56.57,56.57 L0,0 Z"
              fill="var(--rsi-practice)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-record" d="M-56.57,56.57 A80,80 0 0,1 -80,0 L0,0 Z"
              fill="var(--rsi-record)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-crystallize" d="M-80,0 A80,80 0 0,1 -56.57,-56.57 L0,0 Z"
              fill="var(--rsi-crystallize)" opacity="0.3" stroke="white" stroke-width="1"/>
        <path id="rsi-seg-measure" d="M-56.57,-56.57 A80,80 0 0,1 0,-80 L0,0 Z"
              fill="var(--rsi-measure)" opacity="0.3" stroke="white" stroke-width="1"/>
        <!-- Center label -->
        <circle cx="0" cy="0" r="35" fill="rgba(255,255,255,0.9)" stroke="var(--glass-border)" stroke-width="1"/>
        <text id="rsi-phase-label" x="0" y="5" text-anchor="middle" font-size="12" fill="var(--text-primary)" font-weight="600">RSI</text>
      </g>
    </svg>
    <!-- Phase labels around ring -->
    <div id="rsi-phase-labels" style="position: absolute; top: 0; left: 0; width: 200px; height: 200px; font-size: 9px; color: var(--text-muted);">
      <span style="position: absolute; top: 5px; left: 85px;">REFLECT</span>
      <span style="position: absolute; top: 30px; right: 5px;">VERIFY</span>
      <span style="position: absolute; top: 90px; right: 0;">COLLAPSE</span>
      <span style="position: absolute; bottom: 30px; right: 5px;">ROUTE</span>
      <span style="position: absolute; bottom: 5px; left: 75px;">PRACTICE</span>
      <span style="position: absolute; bottom: 30px; left: 5px;">RECORD</span>
      <span style="position: absolute; top: 90px; left: 0;">CRYSTAL</span>
      <span style="position: absolute; top: 30px; left: 10px;">MEASURE</span>
    </div>
  </div>

  <!-- RSI Metrics Panel -->
  <div id="rsi-metrics-panel" class="glass-panel" style="
    position: fixed;
    bottom: 20px;
    left: 240px;
    z-index: 100;
    padding: 16px;
    min-width: 280px;
    font-size: 12px;
  ">
    <h4 style="margin: 0 0 12px 0; color: var(--text-primary); font-size: 14px;">RSI Metrics</h4>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
      <div style="background: rgba(139, 92, 246, 0.1); padding: 8px; border-radius: 8px;">
        <div style="color: var(--text-muted); font-size: 10px;">Activation Rate</div>
        <div id="rsi-activation-rate" style="color: var(--rsi-reflect); font-size: 16px; font-weight: 600;">0.0</div>
      </div>
      <div style="background: rgba(6, 182, 212, 0.1); padding: 8px; border-radius: 8px;">
        <div style="color: var(--text-muted); font-size: 10px;">Complete Cycles</div>
        <div id="rsi-complete-cycles" style="color: var(--rsi-crystallize); font-size: 16px; font-weight: 600;">0</div>
      </div>
    </div>

    <div style="margin-bottom: 12px;">
      <div style="color: var(--text-muted); font-size: 10px; margin-bottom: 4px;">Domain Distribution</div>
      <div id="rsi-domain-bars" style="display: flex; height: 20px; border-radius: 4px; overflow: hidden; background: rgba(0,0,0,0.05);">
        <div id="domain-code" style="background: var(--node-capability); width: 33%;" title="Code"></div>
        <div id="domain-math" style="background: var(--node-crystal); width: 33%;" title="Math"></div>
        <div id="domain-logic" style="background: var(--node-reflection); width: 34%;" title="Logic"></div>
      </div>
      <div style="display: flex; justify-content: space-between; font-size: 9px; color: var(--text-muted); margin-top: 2px;">
        <span>Code</span><span>Math</span><span>Logic</span>
      </div>
    </div>

    <div>
      <div style="color: var(--text-muted); font-size: 10px; margin-bottom: 4px;">Crystallization Progress</div>
      <div id="rsi-crystallization-progress" style="height: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; overflow: hidden;">
        <div id="crystallization-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--rsi-crystallize), var(--node-heuristic)); transition: width 0.3s ease;"></div>
      </div>
      <div style="display: flex; justify-content: space-between; font-size: 9px; color: var(--text-muted); margin-top: 2px;">
        <span id="trajectories-count">0 trajectories</span>
        <span id="heuristics-count">0 heuristics</span>
      </div>
    </div>
  </div>

  <!-- Title Badge -->
  <div class="glass-panel title-badge">
    <div class="connection-indicator disconnected" id="connection-indicator"></div>
    <div>
      <h1>BYRD</h1>
      <div class="subtitle">Memory Topology</div>
    </div>
    <button onclick="toggleHelpPanel()" title="Keyboard Shortcuts (H)" style="
      background: rgba(147, 197, 253, 0.1);
      border: 1px solid rgba(147, 197, 253, 0.3);
      color: var(--text-muted);
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      margin-left: 12px;
      transition: all 0.15s ease;
    " onmouseover="this.style.background='rgba(147, 197, 253, 0.2)'; this.style.color='var(--text-primary)';"
       onmouseout="this.style.background='rgba(147, 197, 253, 0.1)'; this.style.color='var(--text-muted)';">?</button>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar glass-panel" id="stats-bar">
    <div class="stat-item" data-filter="nodes">
      <span class="stat-dot" style="background: var(--accent-blue)"></span>
      <span class="stat-label">Nodes</span>
      <span class="stat-value" id="stat-nodes">0</span>
    </div>
    <div class="stat-item" data-filter="triangles">
      <span class="stat-icon">&#9650;</span>
      <span class="stat-label">Triangles</span>
      <span class="stat-value" id="stat-triangles">0</span>
    </div>
    <div class="stat-item" data-filter="tetrahedra">
      <span class="stat-icon">&#9670;</span>
      <span class="stat-label">Tetrahedra</span>
      <span class="stat-value" id="stat-tetrahedra">0</span>
    </div>
    <div class="stat-item" data-filter="higher-cliques">
      <span class="stat-icon">&#11044;</span>
      <span class="stat-label">5+ Cliques</span>
      <span class="stat-value" id="stat-higher-cliques">0</span>
    </div>
    <div class="stat-item" data-filter="chains">
      <span class="stat-icon">&#10137;</span>
      <span class="stat-label">Chains</span>
      <span class="stat-value" id="stat-chains">0</span>
    </div>
    <div class="stat-item" data-filter="clusters">
      <span class="stat-icon">&#11042;</span>
      <span class="stat-label">Clusters</span>
      <span class="stat-value" id="stat-clusters">0</span>
    </div>
    <div class="stat-item" data-filter="relationships">
      <span class="stat-icon">&#8212;</span>
      <span class="stat-label">Links</span>
      <span class="stat-value" id="stat-relationships">0</span>
    </div>
    <div class="stat-item physics-controls">
      <button id="physics-toggle" onclick="togglePhysics()" style="
        background: #f59e0b;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
        font-weight: 600;
      ">‚è∏ Pause</button>
      <button onclick="restartPhysics()" style="
        background: #6366f1;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 11px;
        cursor: pointer;
        margin-left: 4px;
      " title="Restart physics simulation">‚Üª</button>
      <span id="physics-iter" style="font-size: 10px; color: #64748b; margin-left: 6px;">0</span>
    </div>
  </div>

  <!-- Legend Panel -->
  <div class="glass-panel legend-panel">
    <h3>Memory Topology</h3>

    <div class="legend-section">
      <div class="legend-section-title">Node Types</div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-experience)">‚óè</div>
        <span>Experience (sphere)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-belief)">‚óÜ</div>
        <span>Belief (octahedron)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-desire)">‚ñ≤</div>
        <span>Desire (tetrahedron)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-goal)">‚¨°</div>
        <span>Goal (dodecahedron)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-capability)">‚ñ†</div>
        <span>Capability (cube)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-reflection)">‚àû</div>
        <span>Reflection (torus knot)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-crystal)">‚úß</div>
        <span>Crystal (icosahedron)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-meta)">‚óé</div>
        <span>Meta Cluster</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-trajectory)">‚ñÆ</div>
        <span>Trajectory (prism)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: var(--node-heuristic)">‚òÖ</div>
        <span>Heuristic (star)</span>
      </div>
    </div>

    <div class="legend-section">
      <div class="legend-section-title">Topology Structures</div>
      <div class="legend-item">
        <div class="legend-shape" style="color: #93c5fd">&#9650;</div>
        <span>Triangle (3 nodes)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: #fbbf24">&#9670;</div>
        <span>Tetrahedron (4 nodes)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: #ff6b9d">&#11044;</div>
        <span>Higher Clique (5+ nodes)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: #22d3ee">&#10137;</div>
        <span>Chain (derivation path)</span>
      </div>
      <div class="legend-item">
        <div class="legend-shape" style="color: #a855f7">&#11042;</div>
        <span>Cluster Hull (meta)</span>
      </div>
    </div>
  </div>

  <!-- Info Panel (Hidden by default) -->
  <div class="glass-panel info-panel" id="info-panel">
    <h3>
      <span id="info-title">Selected Structure</span>
      <button class="close-btn" onclick="hideInfoPanel()">&times;</button>
    </h3>
    <div class="info-row">
      <span class="info-label">Type</span>
      <span class="info-value" id="info-type">-</span>
    </div>
    <div class="info-row">
      <span class="info-label">Nodes</span>
      <span class="info-value" id="info-node-count">-</span>
    </div>
    <div class="info-row">
      <span class="info-label">Relationships</span>
      <span class="info-value" id="info-rel-count">-</span>
    </div>
    <div class="info-content" id="info-content">
      Click a structure to see details.
    </div>
    <div class="info-nodes-list" id="info-nodes-list"></div>
  </div>

  <!-- Console Panel (Right Side) -->
  <div class="glass-panel console-panel" id="console-panel">
    <div class="console-header">
      <div style="display: flex; align-items: center;">
        <span class="console-title">Console</span>
        <span class="console-count" id="console-count">0</span>
      </div>
      <div class="console-controls">
        <button class="console-btn" id="btn-toggle-filter" title="Filter Events">‚öô</button>
        <button class="console-btn active" id="btn-auto-scroll" title="Auto-scroll">‚ñ∂</button>
        <button class="console-btn" id="btn-clear-console" title="Clear">üóë</button>
        <button class="console-btn" id="btn-export-console" title="Export">‚§ì</button>
        <button class="console-btn" id="btn-minimize-console" title="Minimize">‚ñº</button>
      </div>
    </div>
    <!-- Event Type Filter Bar -->
    <div class="console-filter-bar hidden" id="console-filter-bar">
      <div class="filter-chip type-belief active" data-filter="belief" title="Beliefs">
        <span class="filter-chip-dot"></span>Belief
      </div>
      <div class="filter-chip type-desire active" data-filter="desire" title="Desires">
        <span class="filter-chip-dot"></span>Desire
      </div>
      <div class="filter-chip type-experience active" data-filter="experience" title="Experiences">
        <span class="filter-chip-dot"></span>Exp
      </div>
      <div class="filter-chip type-goal active" data-filter="goal" title="Goals">
        <span class="filter-chip-dot"></span>Goal
      </div>
      <div class="filter-chip type-capability active" data-filter="capability" title="Capabilities">
        <span class="filter-chip-dot"></span>Cap
      </div>
      <div class="filter-chip type-reflection active" data-filter="reflection" title="Reflections">
        <span class="filter-chip-dot"></span>Refl
      </div>
      <div class="filter-chip type-system active" data-filter="system" title="System Events">
        <span class="filter-chip-dot"></span>Sys
      </div>
      <div class="filter-chip type-error active" data-filter="error" title="Errors">
        <span class="filter-chip-dot"></span>Err
      </div>
      <div class="filter-actions">
        <button class="filter-action-btn" id="btn-filter-all" title="Show All">All</button>
        <button class="filter-action-btn" id="btn-filter-none" title="Hide All">None</button>
      </div>
    </div>
    <div class="console-body" id="console-body">
      <!-- Events will be rendered here -->
    </div>
    <div class="console-footer">
      <div class="console-status">
        <span id="console-connection" class="console-connection"></span>
        <span id="console-status-text">Disconnected</span>
      </div>
      <div>
        <span id="console-rate">0/s</span>
      </div>
    </div>
  </div>

  <!-- Consolidation Controls (Top Right) -->
  <div class="glass-panel consolidation-controls" id="consolidation-controls">
    <h4>
      Consolidation
      <span class="badge" id="consolidation-badge">AUTO</span>
      <button class="minimize-btn" id="btn-minimize-consolidation" title="Minimize">‚ñº</button>
    </h4>

    <div class="control-row">
      <span class="control-label">Node Limit</span>
      <div class="slider-container">
        <input type="range" class="slider" id="node-limit-slider" min="100" max="5000" value="2000" step="100">
      </div>
      <span class="control-value" id="node-limit-value">2000</span>
    </div>

    <div class="control-row">
      <span class="control-label">Strategy</span>
      <div class="control-btn-group">
        <button class="control-btn active" data-strategy="auto" onclick="setConsolidationStrategy('auto')">Auto</button>
        <button class="control-btn" data-strategy="temporal" onclick="setConsolidationStrategy('temporal')">Time</button>
        <button class="control-btn" data-strategy="community" onclick="setConsolidationStrategy('community')">Community</button>
      </div>
    </div>

    <div class="control-row">
      <span class="control-label">Age Threshold</span>
      <div class="slider-container">
        <input type="range" class="slider" id="age-threshold-slider" min="1" max="30" value="7" step="1">
      </div>
      <span class="control-value" id="age-threshold-value">7d</span>
    </div>

    <div class="consolidation-stats">
      <div class="consolidation-stat">
        <span>Original Nodes</span>
        <span class="value" id="stat-original">0</span>
      </div>
      <div class="consolidation-stat">
        <span>After Consolidation</span>
        <span class="value" id="stat-after">0</span>
      </div>
      <div class="consolidation-stat">
        <span>Meta Clusters</span>
        <span class="value" id="stat-meta-clusters">0</span>
      </div>
      <div class="consolidation-stat">
        <span>Compression Ratio</span>
        <span class="value" id="stat-compression">1.0x</span>
      </div>
    </div>
  </div>

  <!-- Consolidation Panel (Bottom Right - simplified) -->
  <div class="glass-panel consolidation-panel" id="consolidation-panel">
    <div class="consolidation-text">
      <strong id="visible-count">0</strong> / <span id="total-count">0</span> nodes
    </div>
    <div class="consolidation-bar">
      <div class="consolidation-fill" id="consolidation-fill" style="width: 0%"></div>
    </div>
    <div class="consolidation-text">
      Level <strong id="consolidation-level">0</strong>
    </div>
  </div>

  <!-- Cluster Expanded Overlay -->
  <div class="cluster-expanded-overlay" id="cluster-overlay">
    <div class="glass-panel cluster-expanded-panel">
      <div class="cluster-expanded-header">
        <h3>
          <span id="cluster-title">Cluster Details</span>
          <span class="node-count" id="cluster-node-count">0 nodes</span>
        </h3>
        <button class="control-btn" onclick="hideClusterOverlay()">Close</button>
      </div>
      <div class="cluster-node-grid" id="cluster-node-grid">
        <!-- Populated dynamically -->
      </div>
    </div>
  </div>

  <!-- Navigation Bar -->
  <div class="nav-bar" id="nav-bar">
    <button class="nav-btn orange" id="nav-pause" onclick="togglePhysics()">
      ‚è∏ Pause
    </button>
    <button class="nav-btn slate" onclick="restartPhysics()" title="Restart physics">
      ‚Ü∫
    </button>
    <button class="nav-btn slate" onclick="refreshGraph()" title="Refresh graph data">
      üîÑ
    </button>
    <a href="byrd-3d-visualization.html" class="nav-btn purple" title="Mind Space">
      üß† Graph
    </a>
    <button class="nav-btn slate" onclick="showStatusModal()" title="System status">
      üß† Status
    </button>
    <button class="nav-btn slate" onclick="showGenesisModal()" title="Genesis data">
      üß¨ Genesis
    </button>
    <button class="nav-btn pink" onclick="showMessageModal()" title="Send message to BYRD">
      üí¨ Message
    </button>
    <button class="nav-btn amber" id="feed-button" title="Feed files to BYRD">
      üçú Feed
    </button>
    <button class="nav-btn teal" onclick="speakToMe()" title="Ask BYRD to speak">
      üéôÔ∏è Speak to me
    </button>
    <button class="nav-btn emerald" onclick="showAGIMetricsModal()" title="AGI Progress Tracking">
      üìä AGI Metrics
    </button>
    <a href="byrd-architecture.html" class="nav-btn violet" title="System architecture">
      üèõÔ∏è Architecture
    </a>
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>

  <!-- Messages Panel - Chat History -->
  <div id="messages-panel" class="messages-panel collapsed">
    <div id="messages-panel-header" class="messages-panel-header">
      <h3>
        <span>üí¨ Messages</span>
        <span id="unread-badge" class="unread-badge" style="display: none;">0</span>
      </h3>
      <button class="messages-panel-toggle" aria-label="Toggle messages panel">
        <svg id="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="18 15 12 9 6 15"></polyline>
        </svg>
      </button>
    </div>
    <div id="messages-list" class="messages-list">
      <div class="messages-loading">Loading messages...</div>
    </div>
    <div class="messages-input-area">
      <input type="text" id="message-input" class="messages-input" placeholder="Type a message to BYRD...">
      <button id="messages-send-btn" class="messages-send-btn">Send</button>
    </div>
  </div>

  <!-- File Upload Modal -->
  <div id="upload-modal" class="fixed inset-0 z-[9999] hidden items-center justify-center bg-black/50 backdrop-blur-sm">
    <div class="bg-white/95 backdrop-blur-lg rounded-2xl shadow-2xl w-[540px] max-h-[85vh] overflow-hidden border border-slate-200/50">
      <!-- Modal Header -->
      <div class="bg-gradient-to-r from-amber-500 to-orange-500 p-5">
        <div class="flex items-center justify-between">
          <div>
            <h2 class="text-lg font-semibold text-white flex items-center gap-2">
              üçú Feed BYRD
            </h2>
            <p class="text-amber-100 text-sm mt-1">Feed knowledge for BYRD to learn from</p>
          </div>
          <button onclick="hideUploadModal()" class="text-white/80 hover:text-white p-1 rounded transition-colors">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>

      <!-- Modal Body -->
      <div class="p-5 overflow-y-auto max-h-[60vh]">
        <!-- Drop Zone -->
        <div id="upload-dropzone-inner" class="border-2 border-dashed border-slate-300 rounded-xl p-8 text-center hover:border-amber-400 hover:bg-amber-50/50 transition-colors cursor-pointer"
             onclick="document.getElementById('file-input').click();">
          <div class="text-4xl mb-3">üìÅ</div>
          <p class="text-slate-600 font-medium">Drop files here or click to browse</p>
          <p class="text-sm text-slate-400 mt-1">PDF, text, code, markdown, JSON</p>
          <input type="file" id="file-input" multiple class="hidden" accept=".txt,.md,.pdf,.json,.py,.js,.ts,.tsx,.yaml,.yml,.html,.css,.sql,.sh,.go,.rs,.java,.cpp,.c,.h,.hpp" onchange="handleFileSelect(event)">
        </div>

        <!-- Selected Files List -->
        <div id="selected-files-list" class="mt-4 space-y-2 hidden">
          <div class="text-sm text-slate-500 font-medium">Selected files:</div>
        </div>

        <!-- Metadata Inputs -->
        <div class="mt-5 space-y-4">
          <div>
            <label class="block text-sm font-medium text-slate-600 mb-1">Tags (comma-separated)</label>
            <input type="text" id="upload-tags" placeholder="research, code, notes"
                   class="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 outline-none transition-all text-slate-700">
          </div>
          <div>
            <label class="block text-sm font-medium text-slate-600 mb-1">Purpose</label>
            <select id="upload-purpose" class="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 outline-none transition-all text-slate-700">
              <option value="">Let BYRD decide</option>
              <option value="knowledge">Knowledge (learn from this)</option>
              <option value="context">Context (reference material)</option>
              <option value="memory">Memory (remember this event)</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-slate-600 mb-1">Notes for BYRD</label>
            <textarea id="upload-notes" rows="2" placeholder="What should BYRD know about these files?"
                      class="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 outline-none transition-all text-slate-700 resize-none"></textarea>
          </div>
        </div>

        <!-- Info Box -->
        <div class="mt-4 bg-amber-50 rounded-lg p-3 border border-amber-100">
          <p class="text-xs text-amber-700">
            Files are processed in the background. BYRD will analyze, chunk, and embed the content for future reflection.
          </p>
        </div>
      </div>

      <!-- Modal Footer -->
      <div class="border-t border-slate-200 p-4 bg-slate-50/50 flex items-center justify-between">
        <span id="upload-status" class="text-sm text-slate-500"></span>
        <div class="flex gap-3">
          <button onclick="hideUploadModal()" class="px-5 py-2.5 text-sm font-medium bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition-colors">
            Cancel
          </button>
          <button
            id="btn-execute-upload"
            onclick="executeUpload()"
            disabled
            class="px-5 py-2.5 text-sm font-medium bg-amber-500 text-white rounded-lg hover:bg-amber-600 active:bg-amber-700 transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-amber-500/25"
          >
            <span>Feed BYRD</span>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Event Details Modal -->
  <div id="event-modal" class="fixed inset-0 z-[9999] hidden items-center justify-center bg-black/50 backdrop-blur-sm">
    <div class="bg-white/95 backdrop-blur-lg rounded-2xl shadow-2xl w-[600px] max-h-[90vh] overflow-hidden border border-slate-200/50">
      <!-- Modal Header -->
      <div id="event-modal-header" class="bg-gradient-to-r from-slate-700 to-slate-800 p-4">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <span id="event-modal-icon" class="text-2xl">‚óÜ</span>
            <div>
              <h2 id="event-modal-title" class="text-lg font-semibold text-white">EVENT</h2>
              <p id="event-modal-time" class="text-slate-300 text-sm">timestamp</p>
            </div>
          </div>
          <button onclick="hideEventModal()" class="text-white/80 hover:text-white p-1 rounded transition-colors">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
      <!-- Modal Body -->
      <div class="p-5 overflow-y-auto max-h-[80vh]">
        <p id="event-modal-content" class="text-slate-700 mb-4 italic"></p>
        <div class="bg-slate-100 rounded-lg p-4 font-mono text-sm text-slate-600 overflow-x-auto">
          <pre id="event-modal-data" class="whitespace-pre-wrap break-words"></pre>
        </div>
      </div>
      <!-- Modal Footer -->
      <div class="border-t border-slate-200 p-4 flex justify-between items-center bg-slate-50">
        <button id="event-modal-focus" onclick="focusEventNode()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm">
          Focus Node
        </button>
        <button onclick="hideEventModal()" class="px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition-colors text-sm">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Upload Modal Script (must be regular script for onclick handlers) -->
  <script>
    // Upload modal state
    var uploadSelectedFiles = [];
    var uploadApiBase = window.location.hostname === 'localhost' ? 'http://localhost:8000' : '';

    function showUploadModal() {
      console.log('showUploadModal called');
      var modal = document.getElementById('upload-modal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        console.log('Modal shown');
      } else {
        console.log('Modal not found');
      }
    }

    function hideUploadModal() {
      var modal = document.getElementById('upload-modal');
      if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
      }
      uploadSelectedFiles = [];
      var fileInput = document.getElementById('file-input');
      if (fileInput) fileInput.value = '';
      var filesList = document.getElementById('selected-files-list');
      if (filesList) {
        filesList.classList.add('hidden');
        filesList.innerHTML = '<div class="text-sm text-slate-500 font-medium">Selected files:</div>';
      }
      var tagsInput = document.getElementById('upload-tags');
      if (tagsInput) tagsInput.value = '';
      var purposeInput = document.getElementById('upload-purpose');
      if (purposeInput) purposeInput.value = '';
      var notesInput = document.getElementById('upload-notes');
      if (notesInput) notesInput.value = '';
      var statusEl = document.getElementById('upload-status');
      if (statusEl) statusEl.textContent = '';
      var btn = document.getElementById('btn-execute-upload');
      if (btn) btn.disabled = true;
    }

    function handleFileSelect(event) {
      var files = Array.from(event.target.files);
      if (files.length === 0) return;

      uploadSelectedFiles = files;
      var listEl = document.getElementById('selected-files-list');
      if (!listEl) return;

      listEl.classList.remove('hidden');
      listEl.innerHTML = '<div class="text-sm text-slate-500 font-medium">Selected files:</div>' +
        files.map(function(f) {
          return '<div class="flex items-center gap-2 text-sm text-slate-700 bg-slate-100 rounded-lg px-3 py-2">' +
            '<span>üìÑ</span>' +
            '<span class="flex-1 truncate">' + f.name + '</span>' +
            '<span class="text-slate-400">' + (f.size / 1024).toFixed(1) + ' KB</span>' +
          '</div>';
        }).join('');

      var btn = document.getElementById('btn-execute-upload');
      if (btn) btn.disabled = false;
    }

    function executeUpload() {
      if (uploadSelectedFiles.length === 0) return;

      var statusEl = document.getElementById('upload-status');
      var btn = document.getElementById('btn-execute-upload');
      if (btn) btn.disabled = true;
      if (statusEl) statusEl.textContent = 'Uploading...';

      var tagsInput = document.getElementById('upload-tags');
      var purposeInput = document.getElementById('upload-purpose');
      var notesInput = document.getElementById('upload-notes');
      var tags = tagsInput ? tagsInput.value : '';
      var purpose = purposeInput ? purposeInput.value : '';
      var notes = notesInput ? notesInput.value : '';

      var successCount = 0;
      var errorCount = 0;
      var fileIndex = 0;

      function uploadNext() {
        if (fileIndex >= uploadSelectedFiles.length) {
          // All done
          if (errorCount === 0) {
            if (window.showToast) window.showToast('Fed ' + successCount + ' file(s) to BYRD! üçú');
            hideUploadModal();
          } else {
            if (statusEl) statusEl.textContent = successCount + ' succeeded, ' + errorCount + ' failed';
            if (btn) btn.disabled = false;
          }
          return;
        }

        var file = uploadSelectedFiles[fileIndex];
        var formData = new FormData();
        formData.append('file', file);
        if (tags) formData.append('tags', tags);
        if (purpose) formData.append('purpose', purpose);
        if (notes) formData.append('notes', notes);

        if (statusEl) statusEl.textContent = 'Uploading ' + file.name + '...';

        fetch(uploadApiBase + '/api/ingest/upload', {
          method: 'POST',
          body: formData
        }).then(function(res) {
          if (res.ok) {
            successCount++;
          } else {
            errorCount++;
          }
          fileIndex++;
          uploadNext();
        }).catch(function(e) {
          errorCount++;
          fileIndex++;
          uploadNext();
        });
      }

      uploadNext();
    }
  </script>

  <!-- Three.js and Dependencies -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    // GLTFLoader not needed - using procedural cat head

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================

    const CONFIG = {
      // Node limits (reduced for browser performance)
      maxNodes: 1000,
      consolidationThreshold: 500,

      // Consolidation settings
      consolidation: {
        enabled: true,   // Enable consolidation for large graphs
        strategy: 'auto',          // 'auto', 'temporal', 'community'
        ageThresholdDays: 7,       // Nodes older than this get consolidated
        minClusterSize: 3,         // Minimum nodes to form a cluster
        maxClusterSize: 50,        // Maximum nodes per cluster
        communityResolution: 1.0,  // Louvain resolution parameter
      },

      // Visual
      nodeBaseSize: 0.5,
      nodeSizeVariation: 0.3,
      metaNodeSizeMultiplier: 1.5,

      // Physics (disabled - using community-based positioning)
      physicsEnabled: false,           // Community layout handles positioning
      physicsAnimated: false,
      physicsMaxIterations: 0,
      repulsionStrength: 0,
      attractionStrength: 0,
      attractionSamples: 0,
      minNodeDistance: 5.0,
      sphereRadius: 150,               // Large sphere for community spread
      sphereBoundaryStrength: 0,
      centeringStrength: 0,
      damping: 0.99,
      repulsionSamples: 0,

      // Bloom (reduced for light theme)
      bloomStrength: 0.1,
      bloomRadius: 0.3,
      bloomThreshold: 0.95,

      // API
      apiBase: '',
      wsUrl: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/events`
    };

    // ==========================================================================
    // COLOR DEFINITIONS
    // ==========================================================================

    const COLORS = {
      background: 0xffffff,  // Pure white background

      nodes: {
        experience: 0x2563eb,  // Darker blue
        belief: 0xd97706,      // Darker amber
        desire: 0xdb2777,      // Darker pink
        capability: 0x7c3aed,  // Darker purple
        crystal: 0x0891b2,     // Darker cyan
        reflection: 0x059669,  // Darker green
        goal: 0xea580c,        // Darker orange
        trajectory: 0x14b8a6,  // Teal
        heuristic: 0xf97316,   // Orange
        meta_cluster: 0x64748b,
        operatingsystem: 0x1d4ed8,
        default: 0x475569
      },

      rsiPhases: {
        reflect: 0x8b5cf6,
        verify: 0x6366f1,
        collapse: 0xec4899,
        route: 0xf59e0b,
        practice: 0x10b981,
        record: 0x3b82f6,
        crystallize: 0x06b6d4,
        measure: 0x84cc16
      },

      surfaces: {
        derived: 0x3b82f6,    // Darker blue
        causal: 0xd97706,     // Darker amber
        contradiction: 0xdc2626, // Darker red
        support: 0x0891b2,    // Darker cyan
        cluster: 0x7c3aed     // Darker purple
      },

      glow: 0x93c5fd
    };

    // ==========================================================================
    // UTILITY FUNCTIONS
    // ==========================================================================

    // Helper to validate position has valid numeric coordinates
    // Used throughout to prevent NaN geometry errors
    function isValidPosition(pos) {
      return pos &&
             typeof pos.x === 'number' && !isNaN(pos.x) &&
             typeof pos.y === 'number' && !isNaN(pos.y) &&
             typeof pos.z === 'number' && !isNaN(pos.z);
    }

    // ==========================================================================
    // STATE
    // ==========================================================================

    let scene, camera, renderer, composer, controls;
    let clock;
    let raycaster, mouse;
    let hoveredObject = null;
    let selectedObject = null;
    let particleSystem = null;

    // BYRD Cat Avatar (center of topology)
    let byrdCat = null;
    let catEyeMeshes = [];
    let catBreathPhase = 0;
    let catIdlePhase = 0;
    let catEyeGlow = 0.6;
    let currentByrdState = 'idle';

    // RSI State (Recursive Self-Improvement)
    const rsiState = {
      currentPhase: null,           // Current RSI phase: reflect, verify, collapse, route, practice, record, crystallize, measure
      currentCycleId: null,         // Current cycle ID for tracking
      completeCycles: 0,            // Total completed cycles
      activationRate: 0.0,          // Emergent desire activation rate
      trajectoriesStored: 0,        // Learning trajectories stored
      heuristicsCount: 0,           // Crystallized heuristics
      domainDistribution: {         // Practice domain distribution
        code: 0,
        math: 0,
        logic: 0
      },
      lastCrystallization: null     // Last crystallization event data
    };

    // Animation state for new structures
    const animationState = {
      newStructures: [],       // Structures pending pulse animation
      pulseTime: 0,
      glowIntensity: 1.0
    };

    // Physics state (for animated force-directed layout)
    const physicsState = {
      velocities: new Map(),   // id -> THREE.Vector3
      iteration: 0,
      running: false,
      converged: false
    };

    // Graph state
    const graphState = {
      // Raw data (before consolidation)
      rawNodes: [],
      rawRelationships: [],

      // Consolidated data (displayed)
      nodes: new Map(),           // id -> node data
      relationships: new Map(),   // id -> relationship data
      nodePositions: new Map(),   // id -> THREE.Vector3
      nodeMeshes: new Map(),      // id -> THREE.Mesh

      // Meta-node tracking
      metaNodes: new Map(),       // metaId -> { constituent_ids, centroid, type, label }
      expandedMetaNodes: new Set(), // IDs of meta-nodes currently expanded

      // Topology structures
      triangles: [],
      tetrahedra: [],
      higherCliques: [],          // 5+ node cliques
      chains: [],                 // A‚ÜíB‚ÜíC‚ÜíD path sequences
      clusters: [],
      clusterHulls: new Map(),    // clusterId -> THREE.Mesh (convex hull)

      // Three.js objects
      instancedNodes: null,
      surfaceMeshes: [],
      edgeLines: [],
      chainMeshes: [],            // Tube geometries for chains

      // Stats
      stats: {
        totalNodes: 0,
        visibleNodes: 0,
        triangleCount: 0,
        tetrahedronCount: 0,
        higherCliqueCount: 0,
        chainCount: 0,
        clusterCount: 0,
        relationshipCount: 0,
        consolidationLevel: 0,
        metaNodeCount: 0,
        compressionRatio: 1.0
      }
    };

    // Consolidation state (for UI binding)
    const consolidationState = {
      originalCount: 0,
      consolidatedCount: 0,
      metaClusters: 0,
      level: 0,
      strategy: 'auto'
    };

    // WebSocket
    let ws = null;
    let wsReconnectTimeout = null;

    // ==========================================================================
    // CONSOLE STATE
    // ==========================================================================

    const consoleEvents = [];
    const consoleState = {
      autoScroll: true,
      maxEvents: 500,
      eventTimestamps: [],
      eventRate: 0,
      filterBarVisible: false,
      activeFilters: {
        belief: true,
        desire: true,
        experience: true,
        goal: true,
        capability: true,
        reflection: true,
        system: true,
        error: true
      }
    };

    // Map event types to categories for styling
    const eventTypeToCategory = {
      'belief_created': 'belief',
      'desire_created': 'desire',
      'experience_created': 'experience',
      'goal_created': 'goal',
      'capability_acquired': 'capability',
      'reflection_complete': 'reflection',
      'dream_cycle_start': 'system',
      'dream_cycle_complete': 'system',
      'system_started': 'system',
      'system_reset': 'system',
      'graph_updated': 'system',
      'relationship_created': 'system',
      'error': 'error'
    };

    function formatEventTime(timestamp) {
      const date = timestamp ? new Date(timestamp) : new Date();
      return date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function formatEventType(type) {
      return type.replace(/_/g, ' ').replace(/created|complete|acquired/g, '').trim().substring(0, 10);
    }

    function getEventContent(event) {
      const data = event.data || {};
      return data.content || data.description || data.message || data.id || event.type;
    }

    function addConsoleEvent(event) {
      // Add to events array (newest at end)
      consoleEvents.push(event);
      if (consoleEvents.length > consoleState.maxEvents) {
        consoleEvents.shift();  // Remove oldest from beginning
      }

      // Track event rate
      consoleState.eventTimestamps.push(Date.now());
      consoleState.eventTimestamps = consoleState.eventTimestamps.filter(t => Date.now() - t < 1000);
      consoleState.eventRate = consoleState.eventTimestamps.length;

      // Update UI
      renderConsoleEvent(event);
      updateConsoleStats();
    }

    function renderConsoleEvent(event) {
      const consoleBody = document.getElementById('console-body');
      if (!consoleBody) return;

      const category = eventTypeToCategory[event.type] || 'system';
      const isFiltered = !consoleState.activeFilters[category];

      const eventEl = document.createElement('div');
      eventEl.className = `console-event type-${category}${isFiltered ? ' filtered' : ''}`;
      eventEl.dataset.category = category;
      eventEl.style.cursor = 'pointer';
      eventEl.innerHTML = `
        <span class="console-event-time">${formatEventTime(event.timestamp)}</span>
        <span class="console-event-type">${formatEventType(event.type)}</span>
        <span class="console-event-content">${getEventContent(event)}</span>
      `;

      // Add click handler to show event details
      eventEl.addEventListener('click', () => {
        showEventModal(event);
      });

      // Add hover effect
      eventEl.addEventListener('mouseenter', () => {
        eventEl.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
      });
      eventEl.addEventListener('mouseleave', () => {
        eventEl.style.backgroundColor = '';
      });

      // Append at bottom (newest last)
      consoleBody.appendChild(eventEl);

      // Limit rendered events (remove oldest from top)
      while (consoleBody.children.length > 100) {
        consoleBody.removeChild(consoleBody.firstChild);
      }

      // Auto-scroll to bottom if enabled (sticky to bottom)
      if (consoleState.autoScroll) {
        consoleBody.scrollTop = consoleBody.scrollHeight;
      }
    }

    function updateConsoleStats() {
      const countEl = document.getElementById('console-count');
      const rateEl = document.getElementById('console-rate');
      if (countEl) countEl.textContent = consoleEvents.length;
      if (rateEl) rateEl.textContent = `${consoleState.eventRate}/s`;
    }

    function clearConsole() {
      consoleEvents.length = 0;
      const consoleBody = document.getElementById('console-body');
      if (consoleBody) consoleBody.innerHTML = '';
      updateConsoleStats();
    }

    function exportConsole() {
      const data = {
        exported_at: new Date().toISOString(),
        event_count: consoleEvents.length,
        events: consoleEvents
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `byrd-topology-events-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function toggleConsoleMinimize() {
      const panel = document.getElementById('console-panel');
      const btn = document.getElementById('btn-minimize-console');
      if (panel) {
        panel.classList.toggle('minimized');
        if (btn) btn.textContent = panel.classList.contains('minimized') ? '‚ñ≤' : '‚ñº';
      }
    }

    function toggleAutoScroll() {
      consoleState.autoScroll = !consoleState.autoScroll;
      updateAutoScrollButton();

      // If enabling auto-scroll, scroll to bottom immediately
      if (consoleState.autoScroll) {
        const consoleBody = document.getElementById('console-body');
        if (consoleBody) {
          consoleBody.scrollTop = consoleBody.scrollHeight;
        }
      }
    }

    // ==========================================================================
    // CONSOLE FILTER FUNCTIONS
    // ==========================================================================

    function toggleFilterBar() {
      consoleState.filterBarVisible = !consoleState.filterBarVisible;
      const filterBar = document.getElementById('console-filter-bar');
      const filterBtn = document.getElementById('btn-toggle-filter');

      if (filterBar) {
        filterBar.classList.toggle('hidden', !consoleState.filterBarVisible);
      }
      if (filterBtn) {
        filterBtn.classList.toggle('active', consoleState.filterBarVisible);
      }
    }

    function toggleFilter(category) {
      consoleState.activeFilters[category] = !consoleState.activeFilters[category];
      updateFilterChips();
      applyFiltersToConsole();
    }

    function setAllFilters(active) {
      Object.keys(consoleState.activeFilters).forEach(category => {
        consoleState.activeFilters[category] = active;
      });
      updateFilterChips();
      applyFiltersToConsole();
    }

    function updateFilterChips() {
      document.querySelectorAll('.filter-chip[data-filter]').forEach(chip => {
        const category = chip.dataset.filter;
        chip.classList.toggle('active', consoleState.activeFilters[category]);
      });
    }

    function applyFiltersToConsole() {
      const consoleBody = document.getElementById('console-body');
      if (!consoleBody) return;

      consoleBody.querySelectorAll('.console-event').forEach(eventEl => {
        const category = eventEl.dataset.category;
        const isFiltered = !consoleState.activeFilters[category];
        eventEl.classList.toggle('filtered', isFiltered);
      });

      // Scroll to bottom if auto-scroll is enabled
      if (consoleState.autoScroll) {
        consoleBody.scrollTop = consoleBody.scrollHeight;
      }
    }

    function initializeFilterListeners() {
      // Filter bar toggle button
      const filterBtn = document.getElementById('btn-toggle-filter');
      if (filterBtn) {
        filterBtn.addEventListener('click', toggleFilterBar);
      }

      // Filter chips
      document.querySelectorAll('.filter-chip[data-filter]').forEach(chip => {
        chip.addEventListener('click', () => {
          toggleFilter(chip.dataset.filter);
        });
      });

      // All/None buttons
      const allBtn = document.getElementById('btn-filter-all');
      const noneBtn = document.getElementById('btn-filter-none');
      if (allBtn) allBtn.addEventListener('click', () => setAllFilters(true));
      if (noneBtn) noneBtn.addEventListener('click', () => setAllFilters(false));
    }

    // Event modal state
    let currentEventData = null;
    let highlightedNodeId = null;

    function showEventModal(event) {
      currentEventData = event;
      const modal = document.getElementById('event-modal');
      if (!modal) return;

      // Get event category for styling
      const category = eventTypeToCategory[event.type] || 'system';
      const colors = {
        memory: 'from-blue-500 to-blue-600',
        desire: 'from-orange-500 to-red-500',
        action: 'from-green-500 to-emerald-600',
        system: 'from-slate-600 to-slate-700',
        learning: 'from-purple-500 to-violet-600'
      };

      const icons = {
        memory: '‚óÜ',
        desire: '‚ô¶',
        action: '‚ñ∂',
        system: '‚öô',
        learning: '‚ú¶'
      };

      // Update modal header
      const header = document.getElementById('event-modal-header');
      if (header) {
        header.className = `bg-gradient-to-r ${colors[category] || colors.system} p-4`;
      }

      document.getElementById('event-modal-icon').textContent = icons[category] || '‚óÜ';
      document.getElementById('event-modal-title').textContent = formatEventType(event.type);
      document.getElementById('event-modal-time').textContent = new Date(event.timestamp).toLocaleString();

      // Get content preview
      const content = getEventContent(event);
      document.getElementById('event-modal-content').textContent = content;

      // Show full data
      const dataStr = JSON.stringify(event.data || event, null, 2);
      document.getElementById('event-modal-data').textContent = dataStr;

      // Check if we can focus on a node
      const nodeId = event.data?.id || event.data?.node_id || event.data?.nodeId;
      const focusBtn = document.getElementById('event-modal-focus');
      if (focusBtn) {
        const hasNode = nodeId && graphState.nodeMeshes.has(nodeId);
        focusBtn.style.display = hasNode ? 'block' : 'none';
      }

      // Highlight the node if it exists
      if (nodeId) {
        highlightNodeById(nodeId, true);
      }

      // Show modal
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }

    function hideEventModal() {
      const modal = document.getElementById('event-modal');
      if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
      }

      // Remove highlight
      if (highlightedNodeId) {
        highlightNodeById(highlightedNodeId, false);
        highlightedNodeId = null;
      }
      currentEventData = null;
    }

    function highlightNodeById(nodeId, highlight) {
      const mesh = graphState.nodeMeshes.get(nodeId);
      if (!mesh || !mesh.material) return;

      if (highlight) {
        // Store original values
        if (!mesh.userData.originalScale) {
          mesh.userData.originalScale = mesh.scale.clone();
          mesh.userData.originalEmissiveIntensity = mesh.material.emissiveIntensity || 0;
        }
        // Enlarge and glow
        mesh.scale.setScalar(mesh.userData.originalScale.x * 3);
        if (mesh.material.emissiveIntensity !== undefined) {
          mesh.material.emissiveIntensity = 1.0;
        }
        highlightedNodeId = nodeId;
      } else {
        // Restore original values
        if (mesh.userData.originalScale) {
          mesh.scale.copy(mesh.userData.originalScale);
          mesh.material.emissiveIntensity = mesh.userData.originalEmissiveIntensity || 0;
          delete mesh.userData.originalScale;
          delete mesh.userData.originalEmissiveIntensity;
        }
      }
    }

    function focusEventNode() {
      if (!currentEventData) return;

      const nodeId = currentEventData.data?.id || currentEventData.data?.node_id || currentEventData.data?.nodeId;
      if (!nodeId) return;

      const mesh = graphState.nodeMeshes.get(nodeId);
      if (!mesh) return;

      // Animate camera to focus on node
      const targetPosition = mesh.position.clone();
      const distance = 50;
      const cameraTarget = targetPosition.clone().add(new THREE.Vector3(distance, distance * 0.5, distance));

      // Simple animation
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const duration = 1000;
      const startTime = Date.now();

      function animateCamera() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const easeT = t * (2 - t); // Ease out

        camera.position.lerpVectors(startPos, cameraTarget, easeT);
        controls.target.lerpVectors(startTarget, targetPosition, easeT);
        controls.update();

        if (t < 1) {
          requestAnimationFrame(animateCamera);
        }
      }

      animateCamera();
      hideEventModal();
    }

    // Expose functions globally for onclick handlers
    window.showEventModal = showEventModal;
    window.hideEventModal = hideEventModal;
    window.focusEventNode = focusEventNode;

    function updateConsoleConnection(connected) {
      const connEl = document.getElementById('console-connection');
      const statusEl = document.getElementById('console-status-text');
      if (connEl) connEl.classList.toggle('connected', connected);
      if (statusEl) statusEl.textContent = connected ? 'Connected' : 'Disconnected';
    }

    function setupConsoleListeners() {
      document.getElementById('btn-auto-scroll')?.addEventListener('click', toggleAutoScroll);
      document.getElementById('btn-clear-console')?.addEventListener('click', clearConsole);
      document.getElementById('btn-export-console')?.addEventListener('click', exportConsole);
      document.getElementById('btn-minimize-console')?.addEventListener('click', toggleConsoleMinimize);

      // Initialize filter listeners
      initializeFilterListeners();

      // Smart auto-scroll: disable when user scrolls up, re-enable when at bottom
      const consoleBody = document.getElementById('console-body');
      if (consoleBody) {
        consoleBody.addEventListener('scroll', () => {
          // Check if scrolled to bottom (with 20px tolerance)
          const isAtBottom = consoleBody.scrollHeight - consoleBody.scrollTop - consoleBody.clientHeight < 20;

          if (isAtBottom && !consoleState.autoScroll) {
            // User scrolled back to bottom - re-enable auto-scroll
            consoleState.autoScroll = true;
            updateAutoScrollButton();
          } else if (!isAtBottom && consoleState.autoScroll) {
            // User scrolled away from bottom - disable auto-scroll
            consoleState.autoScroll = false;
            updateAutoScrollButton();
          }
        });
      }
    }

    function updateAutoScrollButton() {
      const btn = document.getElementById('btn-auto-scroll');
      if (btn) {
        btn.classList.toggle('active', consoleState.autoScroll);
        btn.textContent = consoleState.autoScroll ? '‚ñ∂' : '‚è∏';
      }
    }

    // ==========================================================================
    // CONSOLIDATION CONTROLS
    // ==========================================================================

    function setupConsolidationControls() {
      // Minimize button
      document.getElementById('btn-minimize-consolidation')?.addEventListener('click', toggleConsolidationMinimize);

      // Node limit slider
      const nodeLimitSlider = document.getElementById('node-limit-slider');
      const nodeLimitValue = document.getElementById('node-limit-value');
      if (nodeLimitSlider) {
        // Initialize slider to match CONFIG
        nodeLimitSlider.value = CONFIG.maxNodes;
        nodeLimitValue.textContent = CONFIG.maxNodes.toLocaleString();

        nodeLimitSlider.addEventListener('input', (e) => {
          const value = parseInt(e.target.value);
          nodeLimitValue.textContent = value.toLocaleString();
          CONFIG.maxNodes = value;
        });
        nodeLimitSlider.addEventListener('change', () => {
          console.log(`Node limit changed to ${CONFIG.maxNodes}`);
          applyConsolidationSettings();
        });
      }

      // Age threshold slider
      const ageSlider = document.getElementById('age-threshold-slider');
      const ageValue = document.getElementById('age-threshold-value');
      if (ageSlider) {
        // Initialize slider to match CONFIG
        ageSlider.value = CONFIG.consolidation.ageThresholdDays;
        ageValue.textContent = `${CONFIG.consolidation.ageThresholdDays}d`;

        ageSlider.addEventListener('input', (e) => {
          const value = parseInt(e.target.value);
          ageValue.textContent = `${value}d`;
          CONFIG.consolidation.ageThresholdDays = value;
        });
        ageSlider.addEventListener('change', () => {
          console.log(`Age threshold changed to ${CONFIG.consolidation.ageThresholdDays} days`);
          applyConsolidationSettings();
        });
      }

      // Initialize strategy buttons to match CONFIG
      document.querySelectorAll('[data-strategy]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.strategy === CONFIG.consolidation.strategy);
      });
      document.getElementById('consolidation-badge').textContent = CONFIG.consolidation.strategy.toUpperCase();
    }

    /**
     * Apply current consolidation settings and re-process the graph
     * Called when any consolidation control is changed
     */
    function applyConsolidationSettings() {
      if (graphState.rawNodes && graphState.rawNodes.length > 0) {
        // Re-process existing data with new settings
        processGraphData({
          nodes: graphState.rawNodes,
          relationships: graphState.rawRelationships
        });
        updateStats();
        updateConsolidationUI();
        console.log(`Consolidation applied: ${consolidationState.originalCount} ‚Üí ${consolidationState.consolidatedCount} nodes`);
      } else {
        // No data loaded - offer to load demo data
        console.log('No data loaded. Consider loading demo data.');
        showNoDataMessage();
      }
    }

    /**
     * Show message when no data is available for consolidation
     */
    function showNoDataMessage() {
      const statsContainer = document.querySelector('.consolidation-stats');
      if (statsContainer && !document.getElementById('load-demo-btn')) {
        const hint = document.createElement('div');
        hint.id = 'load-demo-btn';
        hint.style.cssText = 'margin-top: 8px; text-align: center;';
        hint.innerHTML = `
          <button class="control-btn" onclick="loadDemoDataForTesting()"
                  style="font-size: 11px; padding: 4px 8px;">
            Load Demo Data
          </button>
        `;
        statsContainer.appendChild(hint);
      }
    }

    /**
     * Load demo data for testing consolidation controls
     */
    window.loadDemoDataForTesting = function() {
      console.log('Loading demo data for consolidation testing...');
      // Remove the hint button
      const hint = document.getElementById('load-demo-btn');
      if (hint) hint.remove();
      // Create demo data
      createDemoData();
    };

    function toggleConsolidationMinimize() {
      const panel = document.getElementById('consolidation-controls');
      const btn = document.getElementById('btn-minimize-consolidation');
      if (panel) {
        panel.classList.toggle('minimized');
        if (btn) btn.textContent = panel.classList.contains('minimized') ? '‚ñ≤' : '‚ñº';
      }
    }

    // ==========================================================================
    // RSI (RECURSIVE SELF-IMPROVEMENT) VISUALIZATION
    // ==========================================================================

    /**
     * Handle RSI phase change events
     * Updates the RSI ring to highlight the active phase
     */
    function handleRSIPhaseEvent(data) {
      const phase = data.phase || data.current_phase;
      const cycleId = data.cycle || data.cycle_id;

      if (!phase) return;

      rsiState.currentPhase = phase;
      rsiState.currentCycleId = cycleId;

      // Update RSI ring segments
      const phases = ['reflect', 'verify', 'collapse', 'route', 'practice', 'record', 'crystallize', 'measure'];
      phases.forEach(p => {
        const seg = document.getElementById(`rsi-seg-${p}`);
        if (seg) {
          if (p === phase.toLowerCase()) {
            seg.setAttribute('opacity', '1.0');
            seg.style.filter = 'drop-shadow(0 0 8px currentColor)';
          } else {
            seg.setAttribute('opacity', '0.3');
            seg.style.filter = 'none';
          }
        }
      });

      // Update center label
      const label = document.getElementById('rsi-phase-label');
      if (label) {
        label.textContent = phase.toUpperCase();
      }

      // Update BYRD cat state based on RSI phase
      if (phase === 'reflect') {
        setByrdState('dreaming');
      } else if (phase === 'practice') {
        setByrdState('seeking');
      } else if (phase === 'crystallize') {
        setByrdState('yearning');
      }

      console.log(`RSI Phase: ${phase} (cycle: ${cycleId})`);
    }

    /**
     * Handle quantum collapse events
     * Creates a visual burst effect at the BYRD cat
     */
    function handleQuantumCollapseEvent(data) {
      console.log('Quantum collapse:', data);

      // Create particle burst effect at cat position
      if (byrdCat) {
        createQuantumBurst(byrdCat.position);
      }
    }

    /**
     * Create quantum burst visual effect
     */
    function createQuantumBurst(position) {
      const particleCount = 50;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = [];

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;

        velocities.push(new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3
        ));
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        size: 0.15,
        color: COLORS.rsiPhases.collapse,
        transparent: true,
        opacity: 1.0
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Animate burst
      const startTime = performance.now();
      const duration = 1000;

      function animateBurst() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const posArray = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          posArray[i * 3] += velocities[i].x;
          posArray[i * 3 + 1] += velocities[i].y;
          posArray[i * 3 + 2] += velocities[i].z;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        material.opacity = 1 - progress;

        if (progress < 1) {
          requestAnimationFrame(animateBurst);
        } else {
          scene.remove(particles);
          geometry.dispose();
          material.dispose();
        }
      }

      requestAnimationFrame(animateBurst);
    }

    /**
     * Handle crystallization events
     */
    function handleCrystallizationEvent(eventType, data) {
      console.log(`Crystallization event: ${eventType}`, data);

      if (eventType === 'crystallization_proposed') {
        rsiState.lastCrystallization = data;
        // Highlight trajectories being crystallized
        const trajectoryIds = data.trajectory_ids || [];
        trajectoryIds.forEach(id => {
          const mesh = graphState.nodeMeshes.get(id);
          if (mesh) {
            mesh.material.emissiveIntensity = 0.8;
          }
        });
      } else if (eventType === 'crystallization_collapsed') {
        // Animate crystallization
        if (data.heuristic_id && rsiState.lastCrystallization) {
          animateCrystallization(
            rsiState.lastCrystallization.trajectory_ids || [],
            data.heuristic_id
          );
        }
        rsiState.heuristicsCount++;
        updateRSIMetricsDisplay();
      }
    }

    /**
     * Animate trajectories flowing into a new heuristic
     */
    function animateCrystallization(trajectoryIds, heuristicId) {
      // Find heuristic position (or create at cat position)
      let targetPos = byrdCat ? byrdCat.position.clone() : new THREE.Vector3(0, 0, 0);
      const heuristicMesh = graphState.nodeMeshes.get(heuristicId);
      if (heuristicMesh) {
        targetPos = heuristicMesh.position.clone();
      }

      // Create flowing particles from each trajectory
      trajectoryIds.forEach((trajId, index) => {
        const trajMesh = graphState.nodeMeshes.get(trajId);
        if (!trajMesh) return;

        const startPos = trajMesh.position.clone();
        const particleCount = 20;

        for (let i = 0; i < particleCount; i++) {
          setTimeout(() => {
            createFlowingParticle(startPos, targetPos, COLORS.nodes.trajectory);
          }, index * 100 + i * 50);
        }
      });

      // Create heuristic birth effect after delay
      setTimeout(() => {
        createHeuristicBirth(targetPos);
      }, trajectoryIds.length * 100 + 1000);
    }

    /**
     * Create a particle that flows from source to target
     */
    function createFlowingParticle(from, to, color) {
      const geometry = new THREE.SphereGeometry(0.1, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 1.0
      });

      const particle = new THREE.Mesh(geometry, material);
      particle.position.copy(from);
      scene.add(particle);

      const startTime = performance.now();
      const duration = 800;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

        particle.position.lerpVectors(from, to, eased);
        material.opacity = 1 - progress * 0.5;

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          scene.remove(particle);
          geometry.dispose();
          material.dispose();
        }
      }

      requestAnimationFrame(animate);
    }

    /**
     * Create expanding ring effect for new heuristic
     */
    function createHeuristicBirth(position) {
      const geometry = new THREE.RingGeometry(0.5, 0.6, 32);
      const material = new THREE.MeshBasicMaterial({
        color: COLORS.nodes.heuristic,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide
      });

      const ring = new THREE.Mesh(geometry, material);
      ring.position.copy(position);
      ring.lookAt(camera.position);
      scene.add(ring);

      const startTime = performance.now();
      const duration = 1000;

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        ring.scale.setScalar(1 + progress * 3);
        material.opacity = 1 - progress;

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          scene.remove(ring);
          geometry.dispose();
          material.dispose();
        }
      }

      requestAnimationFrame(animate);
    }

    /**
     * Fetch and display RSI metrics
     */
    async function fetchRSIMetrics() {
      try {
        const response = await fetch('/api/rsi/metrics');
        if (!response.ok) {
          console.warn('RSI metrics not available');
          return;
        }

        const data = await response.json();
        updateRSIMetricsFromData(data);
      } catch (error) {
        console.warn('Failed to fetch RSI metrics:', error);
      }
    }

    /**
     * Update RSI metrics display from API data
     */
    function updateRSIMetricsFromData(data) {
      const rsiMetrics = data.rsi_metrics || {};

      rsiState.activationRate = rsiMetrics.activation_rate || 0;
      rsiState.completeCycles = rsiMetrics.complete_cycles || 0;
      rsiState.trajectoriesStored = rsiMetrics.trajectories_stored || 0;
      rsiState.heuristicsCount = rsiMetrics.heuristics_crystallized || 0;

      // Update domain distribution
      const domainDist = rsiMetrics.domain_distribution || {};
      rsiState.domainDistribution = {
        code: domainDist.code || 0,
        math: domainDist.math || 0,
        logic: domainDist.logic || 0
      };

      updateRSIMetricsDisplay();
    }

    /**
     * Update the RSI metrics panel UI
     */
    function updateRSIMetricsDisplay() {
      // Update activation rate
      const activationEl = document.getElementById('rsi-activation-rate');
      if (activationEl) {
        activationEl.textContent = rsiState.activationRate.toFixed(2);
      }

      // Update complete cycles
      const cyclesEl = document.getElementById('rsi-complete-cycles');
      if (cyclesEl) {
        cyclesEl.textContent = rsiState.completeCycles.toString();
      }

      // Update domain bars
      const total = rsiState.domainDistribution.code + rsiState.domainDistribution.math + rsiState.domainDistribution.logic;
      if (total > 0) {
        const codeBar = document.getElementById('domain-code');
        const mathBar = document.getElementById('domain-math');
        const logicBar = document.getElementById('domain-logic');

        if (codeBar) codeBar.style.width = `${(rsiState.domainDistribution.code / total) * 100}%`;
        if (mathBar) mathBar.style.width = `${(rsiState.domainDistribution.math / total) * 100}%`;
        if (logicBar) logicBar.style.width = `${(rsiState.domainDistribution.logic / total) * 100}%`;
      }

      // Update trajectories/heuristics counts
      const trajEl = document.getElementById('trajectories-count');
      if (trajEl) {
        trajEl.textContent = `${rsiState.trajectoriesStored} trajectories`;
      }

      const heurEl = document.getElementById('heuristics-count');
      if (heurEl) {
        heurEl.textContent = `${rsiState.heuristicsCount} heuristics`;
      }

      // Update crystallization progress bar
      const threshold = 10; // Assume crystallization threshold is 10 trajectories
      const progress = Math.min((rsiState.trajectoriesStored % threshold) / threshold * 100, 100);
      const progressBar = document.getElementById('crystallization-bar');
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
    }

    // ==========================================================================
    // INITIALIZATION
    // ==========================================================================

    async function init() {
      console.log('Initializing Memory Topology Visualizer...');

      // Setup Three.js
      setupScene();
      setupCamera();
      setupRenderer();
      setupControls();
      setupPostProcessing();
      setupLighting();
      setupBackground();

      // Load BYRD cat avatar at center
      await loadByrdCat();

      setupRaycaster();

      // Setup event listeners
      setupEventListeners();

      // Setup console listeners
      setupConsoleListeners();

      // Setup consolidation controls
      setupConsolidationControls();

      // Create performance panel (hidden by default)
      createPerformancePanel();

      // Connect to WebSocket
      connectWebSocket();

      // Fetch initial data
      await fetchGraphData();

      // Fetch RSI metrics
      await fetchRSIMetrics();

      // Set up periodic RSI metrics refresh (every 30 seconds)
      setInterval(fetchRSIMetrics, 30000);

      // Hide loading overlay
      document.getElementById('loading-overlay').classList.add('hidden');

      // Start animation loop
      animate();

      console.log('Memory Topology Visualizer initialized');
    }

    // ==========================================================================
    // THREE.JS SETUP
    // ==========================================================================

    function setupScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.background);
      // No fog - nodes stay fully visible at all distances
      clock = new THREE.Clock();
    }

    function setupCamera() {
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 10000);  // Large far plane for zooming out
      camera.position.set(0, 30, 80);
      camera.lookAt(0, 0, 0);
    }

    function setupRenderer() {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        powerPreference: 'high-performance'
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      document.getElementById('canvas-container').appendChild(renderer.domElement);
    }

    function setupControls() {
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 10;
      controls.maxDistance = 2000;  // Allow zooming out to see full graph
      controls.maxPolarAngle = Math.PI * 0.9;
      controls.target.set(0, 0, 0);
    }

    function setupPostProcessing() {
      composer = new EffectComposer(renderer);

      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.bloomStrength,
        CONFIG.bloomRadius,
        CONFIG.bloomThreshold
      );
      composer.addPass(bloomPass);
    }

    function setupLighting() {
      // Strong ambient for light theme
      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);

      // Main directional light
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
      mainLight.position.set(50, 100, 50);
      scene.add(mainLight);

      // Fill light from opposite side
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
      fillLight.position.set(-50, 50, -50);
      scene.add(fillLight);

      // Top-down light
      const topLight = new THREE.DirectionalLight(0xffffff, 0.4);
      topLight.position.set(0, 100, 0);
      scene.add(topLight);
    }

    function setupBackground() {
      // Clean background - only nodes visible, no stars/grid/dust
      // Just keeping the dark background from scene.background
    }

    // ==========================================================================
    // BYRD CAT AVATAR (Center of Topology)
    // ==========================================================================

    async function loadByrdCat() {
      // Create the procedural cat head (matching mind space exactly)
      createProceduralCatHead();
      return Promise.resolve();
    }

    function createProceduralCatHead() {
      // Procedural cat head - matching mind space exactly
      byrdCat = new THREE.Group();

      // Materials
      const blackMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        roughness: 0.85,
        metalness: 0.05
      });

      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4af37,
        emissive: 0xd4af37,
        emissiveIntensity: 0.8,
        roughness: 0.2,
        metalness: 0.3
      });

      const noseMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a1a1a,
        roughness: 0.6
      });

      // Head - slightly squashed sphere
      const headGeom = new THREE.SphereGeometry(1, 32, 24);
      headGeom.scale(1, 0.9, 0.95);
      const head = new THREE.Mesh(headGeom, blackMaterial);
      byrdCat.add(head);

      // Ears - cones
      const earGeom = new THREE.ConeGeometry(0.35, 0.7, 4);
      const leftEar = new THREE.Mesh(earGeom, blackMaterial);
      leftEar.position.set(-0.5, 0.75, 0);
      leftEar.rotation.z = 0.3;
      leftEar.rotation.x = 0.1;
      byrdCat.add(leftEar);

      const rightEar = new THREE.Mesh(earGeom, blackMaterial);
      rightEar.position.set(0.5, 0.75, 0);
      rightEar.rotation.z = -0.3;
      rightEar.rotation.x = 0.1;
      byrdCat.add(rightEar);

      // Inner ears (pink)
      const innerEarGeom = new THREE.ConeGeometry(0.2, 0.4, 4);
      const innerEarMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a2020,
        emissive: 0x1a0505,
        emissiveIntensity: 0.3
      });
      const leftInnerEar = new THREE.Mesh(innerEarGeom, innerEarMaterial);
      leftInnerEar.position.set(-0.5, 0.7, 0.1);
      leftInnerEar.rotation.z = 0.3;
      leftInnerEar.rotation.x = 0.2;
      byrdCat.add(leftInnerEar);

      const rightInnerEar = new THREE.Mesh(innerEarGeom, innerEarMaterial);
      rightInnerEar.position.set(0.5, 0.7, 0.1);
      rightInnerEar.rotation.z = -0.3;
      rightInnerEar.rotation.x = 0.2;
      byrdCat.add(rightInnerEar);

      // Eyes - glowing golden spheres
      const eyeGeom = new THREE.SphereGeometry(0.18, 16, 16);
      const leftEye = new THREE.Mesh(eyeGeom, eyeMaterial);
      leftEye.position.set(-0.35, 0.1, 0.8);
      leftEye.name = 'leftEye';
      byrdCat.add(leftEye);
      catEyeMeshes.push(leftEye);

      const rightEye = new THREE.Mesh(eyeGeom, eyeMaterial);
      rightEye.position.set(0.35, 0.1, 0.8);
      rightEye.name = 'rightEye';
      byrdCat.add(rightEye);
      catEyeMeshes.push(rightEye);

      // Pupils
      const pupilGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMaterial);
      leftPupil.position.set(-0.35, 0.1, 0.95);
      byrdCat.add(leftPupil);

      const rightPupil = new THREE.Mesh(pupilGeom, pupilMaterial);
      rightPupil.position.set(0.35, 0.1, 0.95);
      byrdCat.add(rightPupil);

      // Nose - small triangle
      const noseGeom = new THREE.ConeGeometry(0.1, 0.15, 3);
      const nose = new THREE.Mesh(noseGeom, noseMaterial);
      nose.position.set(0, -0.15, 0.9);
      nose.rotation.x = Math.PI;
      byrdCat.add(nose);

      // Muzzle bumps
      const muzzleGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const leftMuzzle = new THREE.Mesh(muzzleGeom, blackMaterial);
      leftMuzzle.position.set(-0.15, -0.25, 0.75);
      leftMuzzle.scale.set(1, 0.7, 0.8);
      byrdCat.add(leftMuzzle);

      const rightMuzzle = new THREE.Mesh(muzzleGeom, blackMaterial);
      rightMuzzle.position.set(0.15, -0.25, 0.75);
      rightMuzzle.scale.set(1, 0.7, 0.8);
      byrdCat.add(rightMuzzle);

      // Position and scale the whole cat (matching mind space)
      byrdCat.scale.set(3, 2.4, 2.8);
      byrdCat.position.set(0, -2, 0);

      scene.add(byrdCat);
      console.log('BYRD procedural cat head created');
    }

    function animateCatIdle(elapsed) {
      if (!byrdCat) return;

      // Breathing - subtle scale animation (matching mind space)
      const breathSpeed = currentByrdState === 'dreaming' ? 0.3 : 0.5;
      const breathAmount = currentByrdState === 'dreaming' ? 0.025 : 0.018;

      catBreathPhase = Math.sin(elapsed * breathSpeed * Math.PI * 2);

      // Apply subtle breathing (base scale 3, 2.4, 2.8 - matching mind space)
      byrdCat.scale.y = 2.4 + catBreathPhase * breathAmount;
      byrdCat.scale.x = 3 + catBreathPhase * breathAmount * 0.3;

      // Subtle idle sway
      catIdlePhase = elapsed * 0.3;
      byrdCat.rotation.y = Math.sin(catIdlePhase) * 0.02;
      byrdCat.rotation.z = Math.sin(catIdlePhase * 0.7) * 0.008;
    }

    function animateCatEyes(elapsed) {
      if (catEyeMeshes.length === 0) return;

      // Pulsing eye glow based on state
      let targetGlow = 0.6;
      switch (currentByrdState) {
        case 'dreaming':
          targetGlow = 0.3;
          break;
        case 'seeking':
          targetGlow = 1.0;
          break;
        case 'yearning':
          targetGlow = 0.9;
          break;
        case 'idle':
        default:
          targetGlow = 0.6;
      }

      catEyeGlow += (targetGlow - catEyeGlow) * 0.02;
      const glowPulse = catEyeGlow + Math.sin(elapsed * 0.5) * 0.2;

      catEyeMeshes.forEach(eye => {
        if (eye.material && eye.material.emissiveIntensity !== undefined) {
          eye.material.emissiveIntensity = glowPulse;
        }
      });
    }

    function setByrdState(newState) {
      if (newState === currentByrdState) return;
      currentByrdState = newState;
      console.log('BYRD state:', newState);
    }

    function setupParticleDust() {
      const particleCount = 500;
      const geometry = new THREE.BufferGeometry();

      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        // Random position in viewing area
        positions[i3] = (Math.random() - 0.5) * 150;
        positions[i3 + 1] = (Math.random() - 0.5) * 100;
        positions[i3 + 2] = (Math.random() - 0.5) * 150;

        // Slow drift velocities
        velocities[i3] = (Math.random() - 0.5) * 0.02;
        velocities[i3 + 1] = (Math.random() - 0.5) * 0.01 + 0.005; // Slight upward drift
        velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;

        // Bluish-white colors with variation
        const brightness = 0.3 + Math.random() * 0.4;
        colors[i3] = brightness * 0.7;      // R
        colors[i3 + 1] = brightness * 0.85; // G
        colors[i3 + 2] = brightness;        // B (more blue)

        sizes[i] = 0.3 + Math.random() * 0.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.4,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particleSystem = new THREE.Points(geometry, material);
      particleSystem.userData.velocities = velocities;
      scene.add(particleSystem);
    }

    function setupRaycaster() {
      raycaster = new THREE.Raycaster();
      raycaster.params.Points.threshold = 1;
      mouse = new THREE.Vector2();
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================

    function setupEventListeners() {
      // Window resize
      window.addEventListener('resize', onWindowResize);

      // Mouse events
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onClick);
      renderer.domElement.addEventListener('dblclick', onDoubleClick);

      // Keyboard
      document.addEventListener('keydown', onKeyDown);

      // Note: Consolidation control sliders are set up in setupConsolidationControls()

      // Close cluster overlay when clicking background
      const clusterOverlay = document.getElementById('cluster-overlay');
      if (clusterOverlay) {
        clusterOverlay.addEventListener('click', (e) => {
          if (e.target === clusterOverlay) {
            hideClusterOverlay();
          }
        });
      }
    }

    function onDoubleClick(event) {
      if (hoveredObject && hoveredObject.userData) {
        const userData = hoveredObject.userData;

        // Check if it's a meta-node (cluster)
        if (userData.nodeData?.isMetaNode) {
          showClusterOverlay(userData.nodeData);
        } else if (userData.isHull && userData.metaNodeId) {
          const metaNode = graphState.nodes.get(userData.metaNodeId);
          if (metaNode) {
            showClusterOverlay(metaNode);
          }
        }
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast for hover
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(
        [
          ...graphState.nodeMeshes.values(),
          ...graphState.surfaceMeshes,
          ...graphState.clusterHulls.values()
        ],
        false
      );

      if (intersects.length > 0) {
        const object = intersects[0].object;
        if (hoveredObject !== object) {
          // Reset previous hover
          if (hoveredObject) {
            resetHoverState(hoveredObject);
          }
          // Set new hover
          hoveredObject = object;
          setHoverState(hoveredObject);
          renderer.domElement.style.cursor = 'pointer';
        }
      } else {
        if (hoveredObject) {
          resetHoverState(hoveredObject);
          hoveredObject = null;
          renderer.domElement.style.cursor = 'default';
        }
      }
    }

    // Track double-clicks for meta-node expansion
    let lastClickTime = 0;
    let lastClickObject = null;

    function onClick(event) {
      const now = performance.now();
      const isDoubleClick = (now - lastClickTime < 300) && (lastClickObject === hoveredObject);

      if (hoveredObject) {
        // Check if it's a meta-node hull and double-click
        if (isDoubleClick && hoveredObject.userData.metaNodeId) {
          toggleMetaNode(hoveredObject.userData.metaNodeId);
        } else {
          selectObject(hoveredObject);
        }
        lastClickTime = now;
        lastClickObject = hoveredObject;
      } else {
        // Clicked empty space - deselect
        if (selectedObject) {
          deselectObject();
        }
        lastClickTime = 0;
        lastClickObject = null;
      }
    }

    function onKeyDown(event) {
      // Don't capture keys if typing in an input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        return;
      }

      switch (event.key.toLowerCase()) {
        case 'r':
          // Reset view
          resetView();
          break;

        case 'escape':
          // Deselect and hide panel
          deselectObject();
          hideInfoPanel();
          break;

        case 'e':
          // Expand/collapse selected meta-node
          if (selectedObject && selectedObject.userData.metaNodeId) {
            toggleMetaNode(selectedObject.userData.metaNodeId);
            showInfoPanel(selectedObject); // Refresh panel
          }
          break;

        case 'f':
          // Focus on selected object
          if (selectedObject) {
            const position = selectedObject.position.clone();
            const targetPosition = position.clone().add(new THREE.Vector3(15, 15, 15));
            camera.position.copy(targetPosition);
            controls.target.copy(position);
          }
          break;

        case 'i':
          // Toggle info panel
          const panel = document.getElementById('info-panel');
          if (panel.classList.contains('visible')) {
            panel.classList.remove('visible');
          } else if (selectedObject) {
            showInfoPanel(selectedObject);
          }
          break;

        case 'h':
        case '?':
          // Toggle help panel
          toggleHelpPanel();
          break;

        case '1':
          // Force close LOD
          currentLODLevel = 'close';
          applyLODLevel('close');
          break;

        case '2':
          // Force medium LOD
          currentLODLevel = 'medium';
          applyLODLevel('medium');
          break;

        case '3':
          // Force far LOD
          currentLODLevel = 'far';
          applyLODLevel('far');
          break;

        case 'g':
          // Toggle stats bar
          const statsBar = document.querySelector('.stats-bar');
          if (statsBar) {
            statsBar.style.display = statsBar.style.display === 'none' ? 'flex' : 'none';
          }
          break;

        case '+':
        case '=':
          // Zoom in
          const currentDistance = camera.position.length();
          camera.position.multiplyScalar(0.8);
          break;

        case '-':
        case '_':
          // Zoom out
          camera.position.multiplyScalar(1.25);
          break;

        case 'c':
          // Collapse all expanded meta-nodes
          graphState.expandedMetaNodes.forEach(metaId => {
            collapseMetaNode(metaId);
          });
          break;

        case 'l':
          // Toggle live updates
          toggleLiveUpdates();
          break;

        case 'p':
          // Toggle performance panel
          togglePerformancePanel();
          break;
      }
    }

    // ==========================================================================
    // HELP PANEL
    // ==========================================================================

    function toggleHelpPanel() {
      let helpPanel = document.getElementById('help-panel');

      if (!helpPanel) {
        // Create help panel
        helpPanel = document.createElement('div');
        helpPanel.id = 'help-panel';
        helpPanel.className = 'glass-panel';
        helpPanel.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 200;
          padding: 20px 30px;
          min-width: 300px;
          max-width: 400px;
        `;

        helpPanel.innerHTML = `
          <h3 style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
            Keyboard Shortcuts
            <button onclick="toggleHelpPanel()" style="
              background: none;
              border: none;
              color: var(--text-muted);
              font-size: 18px;
              cursor: pointer;
            ">&times;</button>
          </h3>
          <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 15px; font-size: 13px;">
            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">R</kbd>
            <span>Reset camera view</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">Esc</kbd>
            <span>Deselect / Close panels</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">E</kbd>
            <span>Expand/collapse selected cluster</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">F</kbd>
            <span>Focus on selected object</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">I</kbd>
            <span>Toggle info panel</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">C</kbd>
            <span>Collapse all clusters</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">G</kbd>
            <span>Toggle stats bar</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">1/2/3</kbd>
            <span>Set detail level (close/med/far)</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">+/-</kbd>
            <span>Zoom in/out</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">L</kbd>
            <span>Toggle live updates</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">P</kbd>
            <span>Toggle performance panel</span>

            <kbd style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">H or ?</kbd>
            <span>Show this help</span>
          </div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: var(--text-muted);">
            <strong>Mouse:</strong> Left-drag to rotate, Right-drag to pan, Scroll to zoom<br>
            <strong>Double-click</strong> cluster hulls to expand/collapse
          </div>
        `;

        document.body.appendChild(helpPanel);
      } else {
        // Toggle visibility
        if (helpPanel.style.display === 'none') {
          helpPanel.style.display = 'block';
        } else {
          helpPanel.style.display = 'none';
        }
      }
    }

    // Make toggleHelpPanel global for onclick
    window.toggleHelpPanel = toggleHelpPanel;

    // ==========================================================================
    // HOVER/SELECT STATES
    // ==========================================================================

    function setHoverState(object) {
      if (object.material) {
        // Handle glass shader materials (with uniforms)
        if (object.material.uniforms && object.material.uniforms.hoverIntensity) {
          object.userData.originalHoverIntensity = object.material.uniforms.hoverIntensity.value;
          object.userData.originalGlowIntensity = object.material.uniforms.glowIntensity?.value;

          object.material.uniforms.hoverIntensity.value = 1.0;
          if (object.material.uniforms.glowIntensity) {
            object.material.uniforms.glowIntensity.value = Math.min(1.0, object.material.uniforms.glowIntensity.value * 1.5);
          }
        }
        // Handle standard materials (MeshPhysicalMaterial)
        else {
          object.userData.originalEmissive = object.material.emissive?.clone();
          object.userData.originalOpacity = object.material.opacity;
          object.userData.originalEmissiveIntensity = object.material.emissiveIntensity;

          if (object.material.emissive) {
            object.material.emissive.multiplyScalar(1.8);
          }
          if (object.material.opacity !== undefined) {
            object.material.opacity = Math.min(1, object.material.opacity * 1.5);
          }
          if (object.material.emissiveIntensity !== undefined) {
            object.material.emissiveIntensity = Math.min(1, object.material.emissiveIntensity * 2);
          }
        }
      }

      // Highlight connected structures
      highlightConnectedStructures(object, true);
    }

    function resetHoverState(object) {
      if (object.material) {
        // Handle glass shader materials
        if (object.material.uniforms && object.material.uniforms.hoverIntensity) {
          object.material.uniforms.hoverIntensity.value = object.userData.originalHoverIntensity || 0;
          if (object.material.uniforms.glowIntensity && object.userData.originalGlowIntensity !== undefined) {
            object.material.uniforms.glowIntensity.value = object.userData.originalGlowIntensity;
          }
        }
        // Handle standard materials
        else {
          if (object.userData.originalEmissive) {
            object.material.emissive.copy(object.userData.originalEmissive);
          }
          if (object.userData.originalOpacity !== undefined) {
            object.material.opacity = object.userData.originalOpacity;
          }
          if (object.userData.originalEmissiveIntensity !== undefined) {
            object.material.emissiveIntensity = object.userData.originalEmissiveIntensity;
          }
        }
      }

      // Reset all dimmed elements
      resetAllDimming();
    }

    function highlightConnectedStructures(object, dimOthers) {
      const connectedIds = new Set();

      // Get node IDs from the object
      if (object.userData.nodeId) {
        connectedIds.add(object.userData.nodeId);
      }
      if (object.userData.nodeIds) {
        object.userData.nodeIds.forEach(id => connectedIds.add(id));
      }

      // Find all structures that share nodes
      const connectedMeshes = new Set([object]);

      // Check node meshes
      graphState.nodeMeshes.forEach((mesh, id) => {
        if (connectedIds.has(id)) {
          connectedMeshes.add(mesh);
        }
      });

      // Check surface meshes (triangles, tetrahedra, cliques)
      graphState.surfaceMeshes.forEach(mesh => {
        if (mesh.userData.nodeIds) {
          const hasConnection = mesh.userData.nodeIds.some(id => connectedIds.has(id));
          if (hasConnection) {
            connectedMeshes.add(mesh);
            mesh.userData.nodeIds.forEach(id => connectedIds.add(id));
          }
        }
      });

      // Check chain meshes
      graphState.chainMeshes.forEach(mesh => {
        if (mesh.userData.nodeIds) {
          const hasConnection = mesh.userData.nodeIds.some(id => connectedIds.has(id));
          if (hasConnection) {
            connectedMeshes.add(mesh);
          }
        }
      });

      if (dimOthers) {
        // Dim unconnected elements
        graphState.nodeMeshes.forEach((mesh) => {
          if (!connectedMeshes.has(mesh)) {
            dimMesh(mesh);
          }
        });

        graphState.surfaceMeshes.forEach(mesh => {
          if (!connectedMeshes.has(mesh)) {
            dimMesh(mesh);
          }
        });

        graphState.chainMeshes.forEach(mesh => {
          if (!connectedMeshes.has(mesh)) {
            dimMesh(mesh);
          }
        });

        graphState.edgeLines.forEach(line => {
          const rel = line.userData.relationship;
          if (rel && !connectedIds.has(rel.source) && !connectedIds.has(rel.target)) {
            if (line.material) {
              line.userData.originalLineOpacity = line.material.opacity;
              line.material.opacity = 0.05;
            }
          }
        });
      }
    }

    function dimMesh(mesh) {
      if (mesh.material && !mesh.userData.isDimmed) {
        mesh.userData.isDimmed = true;

        // Handle glass shader materials
        if (mesh.material.uniforms && mesh.material.uniforms.glassOpacity) {
          mesh.userData.dimmedOriginalOpacity = mesh.material.uniforms.glassOpacity.value;
          mesh.material.uniforms.glassOpacity.value = mesh.material.uniforms.glassOpacity.value * 0.15;
        }
        // Handle standard materials
        else if (mesh.material.opacity !== undefined) {
          mesh.userData.dimmedOriginalOpacity = mesh.material.opacity;
          mesh.material.opacity = mesh.material.opacity * 0.15;
        }
      }
    }

    function resetMeshDimming(mesh) {
      if (mesh.userData.isDimmed && mesh.userData.dimmedOriginalOpacity !== undefined) {
        // Handle glass shader materials
        if (mesh.material.uniforms && mesh.material.uniforms.glassOpacity) {
          mesh.material.uniforms.glassOpacity.value = mesh.userData.dimmedOriginalOpacity;
        }
        // Handle standard materials
        else if (mesh.material.opacity !== undefined) {
          mesh.material.opacity = mesh.userData.dimmedOriginalOpacity;
        }
        mesh.userData.isDimmed = false;
      }
    }

    function resetAllDimming() {
      // Reset node meshes
      graphState.nodeMeshes.forEach((mesh) => {
        resetMeshDimming(mesh);
      });

      // Reset surface meshes
      graphState.surfaceMeshes.forEach(mesh => {
        resetMeshDimming(mesh);
      });

      // Reset chain meshes
      graphState.chainMeshes.forEach(mesh => {
        resetMeshDimming(mesh);
      });

      // Reset edge lines
      graphState.edgeLines.forEach(line => {
        if (line.userData.originalLineOpacity !== undefined) {
          line.material.opacity = line.userData.originalLineOpacity;
          delete line.userData.originalLineOpacity;
        }
      });
    }

    function selectObject(object) {
      // Deselect previous
      if (selectedObject && selectedObject !== object) {
        deselectObject();
      }

      selectedObject = object;

      // Visual feedback - scale up and add glow
      if (object.material) {
        object.userData.preSelectScale = object.scale.clone();
        object.userData.preSelectEmissiveIntensity = object.material.emissiveIntensity;
        object.scale.multiplyScalar(1.15);

        if (object.material.emissiveIntensity !== undefined) {
          object.material.emissiveIntensity = 0.5;
        }
      }

      // Highlight connected and dim others
      highlightConnectedStructures(object, true);

      // Show info panel
      showInfoPanel(object);
    }

    function deselectObject() {
      if (selectedObject) {
        if (selectedObject.userData.preSelectScale) {
          selectedObject.scale.copy(selectedObject.userData.preSelectScale);
        }
        if (selectedObject.userData.preSelectEmissiveIntensity !== undefined) {
          selectedObject.material.emissiveIntensity = selectedObject.userData.preSelectEmissiveIntensity;
        }

        // Reset all dimming
        resetAllDimming();

        selectedObject = null;
      }
    }

    function resetView() {
      controls.reset();
      camera.position.set(0, 30, 80);
      camera.lookAt(0, 0, 0);
    }

    // ==========================================================================
    // INFO PANEL
    // ==========================================================================

    function showInfoPanel(object) {
      const panel = document.getElementById('info-panel');
      const userData = object.userData;

      if (userData.nodeData) {
        // It's a node
        const node = userData.nodeData;
        document.getElementById('info-title').textContent = 'Node Details';
        document.getElementById('info-type').textContent = node.type || 'Unknown';
        document.getElementById('info-node-count').textContent = '1';
        document.getElementById('info-rel-count').textContent = node.relationshipCount || '0';
        document.getElementById('info-content').textContent =
          node.content || node.description || node.name || 'No content';
        document.getElementById('info-nodes-list').innerHTML = '';
      } else if (userData.metaNodeId) {
        // It's a meta-node (cluster hull)
        const metaId = userData.metaNodeId;
        const metaData = graphState.metaNodes.get(metaId);
        const isExpanded = graphState.expandedMetaNodes.has(metaId);

        document.getElementById('info-title').textContent = 'Memory Cluster';
        document.getElementById('info-type').textContent = 'Meta-Node';
        document.getElementById('info-node-count').textContent = userData.nodeCount || metaData?.constituent_count || '0';
        document.getElementById('info-rel-count').textContent = '-';

        const nodeCount = userData.nodeCount || metaData?.constituent_count || 0;
        let contentHtml = `
          <div style="margin-bottom: 10px;">
            This cluster contains ${nodeCount} consolidated memories.
            ${isExpanded ? 'Currently expanded.' : 'Double-click to expand.'}
          </div>
          <button class="expand-btn" onclick="toggleMetaNode('${metaId}')" style="
            background: rgba(147, 197, 253, 0.2);
            border: 1px solid rgba(147, 197, 253, 0.5);
            color: #93c5fd;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            transition: all 0.15s ease;
          ">
            ${isExpanded ? '‚äü Collapse Cluster' : '‚äû Expand Cluster'}
          </button>
        `;
        document.getElementById('info-content').innerHTML = contentHtml;

        // List constituent nodes (if we have data)
        const listEl = document.getElementById('info-nodes-list');
        listEl.innerHTML = '';
        if (metaData?.constituents) {
          const preview = metaData.constituents.slice(0, 5); // Show first 5
          preview.forEach(node => {
            const item = document.createElement('div');
            item.className = 'info-node-item';
            item.innerHTML = `
              <div class="info-node-dot" style="background: ${getNodeColorCSS(node.type)}"></div>
              <span>${node.type}: ${truncate(node.content || node.description || node.id, 40)}</span>
            `;
            listEl.appendChild(item);
          });
          if (metaData.constituents.length > 5) {
            const moreItem = document.createElement('div');
            moreItem.className = 'info-node-item';
            moreItem.style.opacity = '0.6';
            moreItem.innerHTML = `<span>... and ${metaData.constituents.length - 5} more</span>`;
            listEl.appendChild(moreItem);
          }
        }
      } else if (userData.structureType) {
        // It's a topology structure
        document.getElementById('info-title').textContent = userData.structureType;
        document.getElementById('info-type').textContent = userData.structureType;
        document.getElementById('info-node-count').textContent = userData.nodeIds?.length || '0';
        document.getElementById('info-rel-count').textContent = userData.relationshipCount || '0';
        document.getElementById('info-content').textContent =
          `A ${userData.structureType.toLowerCase()} formed by ${userData.nodeIds?.length || 0} interconnected nodes.`;

        // List nodes in structure
        const listEl = document.getElementById('info-nodes-list');
        listEl.innerHTML = '';
        userData.nodeIds?.forEach(id => {
          const nodeData = graphState.nodes.get(id);
          if (nodeData) {
            const item = document.createElement('div');
            item.className = 'info-node-item';
            item.innerHTML = `
              <div class="info-node-dot" style="background: ${getNodeColorCSS(nodeData.type)}"></div>
              <span>${nodeData.type}: ${truncate(nodeData.content || nodeData.description || id, 40)}</span>
            `;
            item.onclick = () => focusOnNode(id);
            listEl.appendChild(item);
          }
        });
      }

      panel.classList.add('visible');
    }

    function hideInfoPanel() {
      document.getElementById('info-panel').classList.remove('visible');
    }
    window.hideInfoPanel = hideInfoPanel;  // Expose to global scope for onclick

    function focusOnNode(nodeId) {
      const position = graphState.nodePositions.get(nodeId);
      if (position) {
        // Animate camera to node
        const targetPosition = position.clone().add(new THREE.Vector3(10, 10, 10));
        camera.position.copy(targetPosition);
        controls.target.copy(position);
      }
    }

    // ==========================================================================
    // META-NODE EXPANSION
    // ==========================================================================

    /**
     * Expand a meta-node to show its constituent nodes
     * Animates the hull fading out and constituent nodes appearing in a sphere
     */
    function expandMetaNode(metaNodeId) {
      const metaData = graphState.metaNodes.get(metaNodeId);
      const hullMesh = graphState.clusterHulls.get(metaNodeId);

      if (!metaData || !hullMesh) {
        console.warn('Cannot expand meta-node:', metaNodeId);
        return;
      }

      if (graphState.expandedMetaNodes.has(metaNodeId)) {
        console.log('Meta-node already expanded:', metaNodeId);
        return;
      }

      console.log('Expanding meta-node:', metaNodeId, 'with', metaData.constituent_count, 'constituents');

      graphState.expandedMetaNodes.add(metaNodeId);

      // Get hull center for positioning
      const hullCenter = hullMesh.userData.center || new THREE.Vector3();
      if (!hullCenter.isVector3) {
        // Compute center from constituent positions
        hullCenter.set(0, 0, 0);
        metaData.constituents.forEach(node => {
          const pos = graphState.nodePositions.get(node.id);
          if (pos) hullCenter.add(pos);
        });
        hullCenter.divideScalar(metaData.constituents.length);
      }

      // Animate hull fading out
      const fadeOutDuration = 300;
      const startOpacity = hullMesh.material.uniforms?.glassOpacity?.value || hullMesh.material.opacity || 0.12;
      const fadeStart = performance.now();

      function fadeHull() {
        const elapsed = performance.now() - fadeStart;
        const progress = Math.min(elapsed / fadeOutDuration, 1);

        if (hullMesh.material.uniforms?.glassOpacity) {
          hullMesh.material.uniforms.glassOpacity.value = startOpacity * (1 - progress);
        } else {
          hullMesh.material.opacity = startOpacity * (1 - progress);
        }

        if (progress < 1) {
          requestAnimationFrame(fadeHull);
        } else {
          hullMesh.visible = false;
        }
      }
      fadeHull();

      // Create constituent node meshes
      const constituents = metaData.constituents;
      const expandedMeshes = [];
      const radius = 8 + Math.sqrt(constituents.length) * 2;

      constituents.forEach((node, i) => {
        // Get or generate position in sphere around center
        let nodePos = graphState.nodePositions.get(node.id);
        if (!nodePos) {
          // Generate position in golden spiral sphere
          const phi = Math.acos(-1 + (2 * i + 1) / constituents.length);
          const theta = Math.sqrt(constituents.length * Math.PI) * phi;

          nodePos = new THREE.Vector3(
            hullCenter.x + radius * Math.cos(theta) * Math.sin(phi),
            hullCenter.y + radius * Math.cos(phi),
            hullCenter.z + radius * Math.sin(theta) * Math.sin(phi)
          );
          graphState.nodePositions.set(node.id, nodePos);
        }

        // Create node mesh
        const color = getNodeColor(node.type);
        const size = 0.8 + Math.log10(1 + (node.importance || 0.5)) * 0.5;

        let geometry;
        switch((node.type || '').toLowerCase()) {
          case 'belief':
            geometry = new THREE.OctahedronGeometry(size, 0);
            break;
          case 'desire':
            geometry = new THREE.TetrahedronGeometry(size, 0);
            break;
          case 'goal':
            geometry = new THREE.DodecahedronGeometry(size * 0.8, 0);
            break;
          case 'trajectory':
            geometry = new THREE.CylinderGeometry(size * 0.5, size * 0.5, size * 1.5, 6);
            break;
          case 'heuristic':
            geometry = new THREE.IcosahedronGeometry(size * 0.9, 0);
            break;
          default:
            geometry = new THREE.SphereGeometry(size, 16, 16);
        }

        const material = new THREE.MeshPhysicalMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          transparent: true,
          opacity: 0,
          roughness: 0.2,
          metalness: 0.1
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(hullCenter); // Start at center
        mesh.userData = {
          nodeId: node.id,
          nodeData: node,
          isExpandedConstituent: true,
          parentMetaNodeId: metaNodeId,
          targetPosition: nodePos.clone()
        };

        scene.add(mesh);
        graphState.nodeMeshes.set(node.id, mesh);
        expandedMeshes.push(mesh);
      });

      // Animate constituents expanding outward
      const expandDuration = 500;
      const expandStart = performance.now();

      function expandConstituents() {
        const elapsed = performance.now() - expandStart;
        const progress = Math.min(elapsed / expandDuration, 1);
        const easeOut = 1 - Math.pow(1 - progress, 3);

        expandedMeshes.forEach(mesh => {
          const target = mesh.userData.targetPosition;
          mesh.position.lerpVectors(hullCenter, target, easeOut);
          mesh.material.opacity = 0.85 * easeOut;
          mesh.scale.setScalar(easeOut);
        });

        if (progress < 1) {
          requestAnimationFrame(expandConstituents);
        }
      }
      expandConstituents();

      // Store reference for collapse
      hullMesh.userData.expandedMeshes = expandedMeshes;

      // Update stats
      updateStats();
    }

    /**
     * Collapse an expanded meta-node back to its hull
     */
    function collapseMetaNode(metaNodeId) {
      const metaData = graphState.metaNodes.get(metaNodeId);
      const hullMesh = graphState.clusterHulls.get(metaNodeId);

      if (!metaData || !hullMesh) {
        console.warn('Cannot collapse meta-node:', metaNodeId);
        return;
      }

      if (!graphState.expandedMetaNodes.has(metaNodeId)) {
        console.log('Meta-node not expanded:', metaNodeId);
        return;
      }

      console.log('Collapsing meta-node:', metaNodeId);

      const expandedMeshes = hullMesh.userData.expandedMeshes || [];
      const hullCenter = hullMesh.userData.center || new THREE.Vector3();

      // Animate constituents collapsing inward
      const collapseDuration = 400;
      const collapseStart = performance.now();

      function collapseConstituents() {
        const elapsed = performance.now() - collapseStart;
        const progress = Math.min(elapsed / collapseDuration, 1);
        const easeIn = progress * progress;

        expandedMeshes.forEach(mesh => {
          const target = mesh.userData.targetPosition;
          mesh.position.lerpVectors(target, hullCenter, easeIn);
          mesh.material.opacity = 0.85 * (1 - easeIn);
          mesh.scale.setScalar(1 - easeIn * 0.8);
        });

        if (progress < 1) {
          requestAnimationFrame(collapseConstituents);
        } else {
          // Remove constituent meshes
          expandedMeshes.forEach(mesh => {
            scene.remove(mesh);
            graphState.nodeMeshes.delete(mesh.userData.nodeId);
          });
          hullMesh.userData.expandedMeshes = [];

          // Fade hull back in
          hullMesh.visible = true;
          const targetOpacity = 0.12;
          const fadeInDuration = 300;
          const fadeStart = performance.now();

          function fadeIn() {
            const elapsed = performance.now() - fadeStart;
            const progress = Math.min(elapsed / fadeInDuration, 1);

            if (hullMesh.material.uniforms?.glassOpacity) {
              hullMesh.material.uniforms.glassOpacity.value = targetOpacity * progress;
            } else {
              hullMesh.material.opacity = targetOpacity * progress;
            }

            if (progress < 1) {
              requestAnimationFrame(fadeIn);
            }
          }
          fadeIn();
        }
      }
      collapseConstituents();

      graphState.expandedMetaNodes.delete(metaNodeId);
      updateStats();
    }

    /**
     * Toggle meta-node expansion
     */
    window.toggleMetaNode = function(metaNodeId) {
      if (graphState.expandedMetaNodes.has(metaNodeId)) {
        collapseMetaNode(metaNodeId);
      } else {
        expandMetaNode(metaNodeId);
      }
    };

    // ==========================================================================
    // CONSOLIDATION ENGINE
    // ==========================================================================

    /**
     * Main consolidation function - reduces node count to limit while preserving structure
     */
    function consolidateNodes(nodes, relationships, limit = CONFIG.maxNodes) {
      console.log(`Consolidating ${nodes.length} nodes to max ${limit}...`);

      // Raw data is already stored in processGraphData before this is called

      // If under limit, no consolidation needed
      if (nodes.length <= limit) {
        consolidationState.originalCount = nodes.length;
        consolidationState.consolidatedCount = nodes.length;
        consolidationState.metaClusters = 0;
        consolidationState.level = 0;
        return { nodes, relationships, metaNodes: [] };
      }

      // Choose strategy based on config
      const strategy = CONFIG.consolidation.strategy;
      let result = { nodes, relationships, metaNodes: [], level: 0 };

      if (strategy === 'temporal' || strategy === 'auto') {
        result = temporalConsolidation(nodes, relationships, limit);
      }

      // If still over limit after temporal, or if community strategy selected, apply community detection
      if ((result && result.nodes.length > limit) || strategy === 'community') {
        result = communityConsolidation(result.nodes, result.relationships, limit, result.metaNodes || []);
      }

      // Update consolidation state
      consolidationState.originalCount = nodes.length;
      consolidationState.consolidatedCount = result.nodes.length;
      consolidationState.metaClusters = result.metaNodes.length;
      consolidationState.level = result.level || 1;

      console.log(`Consolidation complete: ${nodes.length} -> ${result.nodes.length} nodes, ${result.metaNodes.length} meta-clusters`);

      return result;
    }

    /**
     * Temporal consolidation - group old nodes by time period
     */
    function temporalConsolidation(nodes, relationships, limit) {
      const now = Date.now();
      const ageThreshold = CONFIG.consolidation.ageThresholdDays * 24 * 60 * 60 * 1000;

      const recent = [];
      const old = [];

      // Separate recent vs old nodes
      nodes.forEach(node => {
        const timestamp = node.timestamp || node.created_at || node.formed_at;
        const nodeTime = timestamp ? new Date(timestamp).getTime() : now;
        const age = now - nodeTime;

        if (age < ageThreshold) {
          recent.push(node);
        } else {
          old.push(node);
        }
      });

      console.log(`Temporal split: ${recent.length} recent, ${old.length} old (threshold: ${CONFIG.consolidation.ageThresholdDays} days)`);

      // If recent nodes alone exceed limit, we need stronger consolidation
      if (recent.length >= limit) {
        // Group recent by type first
        return typeConsolidation(nodes, relationships, limit);
      }

      // Group old nodes by day
      const dayBuckets = new Map();
      old.forEach(node => {
        const timestamp = node.timestamp || node.created_at || node.formed_at || new Date().toISOString();
        const dayKey = timestamp.split('T')[0];

        if (!dayBuckets.has(dayKey)) {
          dayBuckets.set(dayKey, []);
        }
        dayBuckets.get(dayKey).push(node);
      });

      // Create meta-nodes for each day bucket
      const metaNodes = [];
      const consolidatedNodes = [...recent];

      dayBuckets.forEach((dayNodes, dayKey) => {
        if (dayNodes.length >= CONFIG.consolidation.minClusterSize) {
          // Create meta-node
          const metaNode = createMetaNode(dayNodes, `day_${dayKey}`, `${dayKey} (${dayNodes.length})`);
          metaNodes.push(metaNode);
          consolidatedNodes.push(metaNode);
        } else {
          // Too few nodes, keep them individual
          consolidatedNodes.push(...dayNodes);
        }
      });

      // Rebuild relationships
      const consolidatedRels = rebuildRelationships(relationships, consolidatedNodes, metaNodes);

      return {
        nodes: consolidatedNodes,
        relationships: consolidatedRels,
        metaNodes,
        level: 1
      };
    }

    /**
     * Type-based consolidation - group by node type
     */
    function typeConsolidation(nodes, relationships, limit) {
      const typeBuckets = new Map();

      nodes.forEach(node => {
        const type = (node.type || 'unknown').toLowerCase();
        if (!typeBuckets.has(type)) {
          typeBuckets.set(type, []);
        }
        typeBuckets.get(type).push(node);
      });

      const metaNodes = [];
      const consolidatedNodes = [];

      typeBuckets.forEach((typeNodes, type) => {
        // Calculate how many we need to consolidate
        const targetCount = Math.ceil((typeNodes.length / nodes.length) * limit);

        if (typeNodes.length <= targetCount || typeNodes.length < CONFIG.consolidation.minClusterSize * 2) {
          // Keep individual
          consolidatedNodes.push(...typeNodes);
        } else {
          // Create chunks of nodes
          const chunkSize = Math.ceil(typeNodes.length / Math.ceil(typeNodes.length / CONFIG.consolidation.maxClusterSize));
          for (let i = 0; i < typeNodes.length; i += chunkSize) {
            const chunk = typeNodes.slice(i, i + chunkSize);
            if (chunk.length >= CONFIG.consolidation.minClusterSize) {
              const metaNode = createMetaNode(chunk, `type_${type}_${i}`, `${type} cluster (${chunk.length})`);
              metaNodes.push(metaNode);
              consolidatedNodes.push(metaNode);
            } else {
              consolidatedNodes.push(...chunk);
            }
          }
        }
      });

      const consolidatedRels = rebuildRelationships(relationships, consolidatedNodes, metaNodes);

      return {
        nodes: consolidatedNodes,
        relationships: consolidatedRels,
        metaNodes,
        level: 2
      };
    }

    /**
     * Community detection using Louvain algorithm (simplified)
     */
    function communityConsolidation(nodes, relationships, limit, existingMetaNodes = []) {
      // Build adjacency for community detection
      const adjacency = new Map();
      const nodeSet = new Set(nodes.map(n => n.id));

      nodes.forEach(node => {
        adjacency.set(node.id, new Set());
      });

      relationships.forEach(rel => {
        if (nodeSet.has(rel.source) && nodeSet.has(rel.target)) {
          adjacency.get(rel.source)?.add(rel.target);
          adjacency.get(rel.target)?.add(rel.source);
        }
      });

      // Simple community detection: group highly connected nodes
      const communities = detectCommunities(nodes, adjacency);

      console.log(`Found ${communities.length} communities`);

      // Create meta-nodes for large communities
      const metaNodes = [...existingMetaNodes];
      const consolidatedNodes = [];

      communities.forEach((community, i) => {
        if (community.length >= CONFIG.consolidation.minClusterSize &&
            community.length <= CONFIG.consolidation.maxClusterSize) {
          const metaNode = createMetaNode(community, `community_${i}`, `Cluster ${i + 1} (${community.length})`);
          metaNodes.push(metaNode);
          consolidatedNodes.push(metaNode);
        } else if (community.length > CONFIG.consolidation.maxClusterSize) {
          // Split large community
          for (let j = 0; j < community.length; j += CONFIG.consolidation.maxClusterSize) {
            const chunk = community.slice(j, j + CONFIG.consolidation.maxClusterSize);
            if (chunk.length >= CONFIG.consolidation.minClusterSize) {
              const metaNode = createMetaNode(chunk, `community_${i}_${j}`, `Cluster ${i + 1}.${Math.floor(j / CONFIG.consolidation.maxClusterSize) + 1} (${chunk.length})`);
              metaNodes.push(metaNode);
              consolidatedNodes.push(metaNode);
            } else {
              consolidatedNodes.push(...chunk);
            }
          }
        } else {
          // Small community, keep individual
          consolidatedNodes.push(...community);
        }
      });

      const consolidatedRels = rebuildRelationships(relationships, consolidatedNodes, metaNodes);

      return {
        nodes: consolidatedNodes,
        relationships: consolidatedRels,
        metaNodes,
        level: 3
      };
    }

    /**
     * Simple community detection using label propagation
     */
    function detectCommunities(nodes, adjacency) {
      const labels = new Map();
      const nodeList = nodes.filter(n => !n.isMetaNode);

      // Initialize each node with its own label
      nodeList.forEach((node, i) => {
        labels.set(node.id, i);
      });

      // Iterate until convergence or max iterations
      const maxIterations = 10;
      for (let iter = 0; iter < maxIterations; iter++) {
        let changed = false;

        // Shuffle node order for each iteration
        const shuffled = [...nodeList].sort(() => Math.random() - 0.5);

        shuffled.forEach(node => {
          const neighbors = adjacency.get(node.id);
          if (!neighbors || neighbors.size === 0) return;

          // Count neighbor labels
          const labelCounts = new Map();
          neighbors.forEach(neighborId => {
            const label = labels.get(neighborId);
            if (label !== undefined) {
              labelCounts.set(label, (labelCounts.get(label) || 0) + 1);
            }
          });

          if (labelCounts.size === 0) return;

          // Find most common label
          let maxCount = 0;
          let bestLabel = labels.get(node.id);
          labelCounts.forEach((count, label) => {
            if (count > maxCount) {
              maxCount = count;
              bestLabel = label;
            }
          });

          if (bestLabel !== labels.get(node.id)) {
            labels.set(node.id, bestLabel);
            changed = true;
          }
        });

        if (!changed) break;
      }

      // Group nodes by label
      const communities = new Map();
      nodeList.forEach(node => {
        const label = labels.get(node.id);
        if (!communities.has(label)) {
          communities.set(label, []);
        }
        communities.get(label).push(node);
      });

      // Include meta-nodes as-is
      const metaNodeCommunity = nodes.filter(n => n.isMetaNode);
      if (metaNodeCommunity.length > 0) {
        communities.set('meta', metaNodeCommunity);
      }

      return Array.from(communities.values());
    }

    /**
     * Create a meta-node representing a cluster of nodes
     */
    function createMetaNode(nodes, id, label) {
      const constituentIds = nodes.map(n => n.id);

      // Calculate aggregate properties
      const avgImportance = nodes.reduce((sum, n) => sum + (n.importance || 0.5), 0) / nodes.length;

      // Determine dominant type
      const typeCounts = {};
      nodes.forEach(n => {
        const type = (n.type || 'unknown').toLowerCase();
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
      const dominantType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'mixed';

      // Get time range
      const timestamps = nodes.map(n => new Date(n.timestamp || n.created_at || n.formed_at || Date.now()).getTime());
      const minTime = Math.min(...timestamps);
      const maxTime = Math.max(...timestamps);

      const metaNode = {
        id: `meta_${id}`,
        type: 'meta_cluster',
        isMetaNode: true,
        label,
        constituent_ids: constituentIds,
        constituent_count: nodes.length,
        dominant_type: dominantType,
        type_breakdown: typeCounts,
        importance: avgImportance,
        time_range: { min: new Date(minTime).toISOString(), max: new Date(maxTime).toISOString() },
        timestamp: new Date(maxTime).toISOString(),
        content: `Cluster of ${nodes.length} ${dominantType} nodes`
      };

      // Store in graphState for expansion
      graphState.metaNodes.set(metaNode.id, {
        ...metaNode,
        constituents: nodes
      });

      return metaNode;
    }

    /**
     * Rebuild relationships after consolidation
     */
    function rebuildRelationships(originalRels, consolidatedNodes, metaNodes) {
      const nodeIdSet = new Set(consolidatedNodes.map(n => n.id));
      const rebuiltRels = [];

      // Map original node IDs to their meta-node (if consolidated)
      const nodeToMeta = new Map();
      metaNodes.forEach(meta => {
        meta.constituent_ids.forEach(id => {
          nodeToMeta.set(id, meta.id);
        });
      });

      // Process each original relationship
      originalRels.forEach(rel => {
        const sourceId = nodeToMeta.get(rel.source) || rel.source;
        const targetId = nodeToMeta.get(rel.target) || rel.target;

        // Only include if both endpoints exist in consolidated set
        if (nodeIdSet.has(sourceId) && nodeIdSet.has(targetId) && sourceId !== targetId) {
          // Check for duplicate
          const relKey = `${sourceId}-${targetId}`;
          const reverseKey = `${targetId}-${sourceId}`;
          const existing = rebuiltRels.find(r =>
            `${r.source}-${r.target}` === relKey || `${r.source}-${r.target}` === reverseKey
          );

          if (!existing) {
            rebuiltRels.push({
              source: sourceId,
              target: targetId,
              type: rel.type || 'RELATES_TO',
              original_count: 1
            });
          } else {
            existing.original_count = (existing.original_count || 1) + 1;
          }
        }
      });

      return rebuiltRels;
    }

    // ==========================================================================
    // CONVEX HULL COMPUTATION (3D)
    // ==========================================================================

    /**
     * QuickHull3D - Proper 3D convex hull computation
     */
    function computeConvexHull3D(points) {
      // Filter out any invalid points
      const validPoints = points.filter(isValidPosition);

      if (validPoints.length === 0) {
        return { vertices: new Float32Array([]), center: new THREE.Vector3(), indices: [] };
      }

      if (validPoints.length < 4) {
        return createSimpleHull(validPoints);
      }

      const center = new THREE.Vector3();
      validPoints.forEach(p => center.add(p));
      center.divideScalar(validPoints.length);

      // Find extreme points along each axis to form initial tetrahedron
      let minX = 0, maxX = 0, minY = 0, maxY = 0, minZ = 0, maxZ = 0;
      for (let i = 1; i < validPoints.length; i++) {
        if (validPoints[i].x < validPoints[minX].x) minX = i;
        if (validPoints[i].x > validPoints[maxX].x) maxX = i;
        if (validPoints[i].y < validPoints[minY].y) minY = i;
        if (validPoints[i].y > validPoints[maxY].y) maxY = i;
        if (validPoints[i].z < validPoints[minZ].z) minZ = i;
        if (validPoints[i].z > validPoints[maxZ].z) maxZ = i;
      }

      // Find the two most distant points for base edge
      const extremes = [minX, maxX, minY, maxY, minZ, maxZ];
      let maxDist = 0;
      let p1 = 0, p2 = 1;
      for (let i = 0; i < extremes.length; i++) {
        for (let j = i + 1; j < extremes.length; j++) {
          const d = validPoints[extremes[i]].distanceToSquared(validPoints[extremes[j]]);
          if (d > maxDist) {
            maxDist = d;
            p1 = extremes[i];
            p2 = extremes[j];
          }
        }
      }

      // Find third point farthest from the line p1-p2
      const lineDir = new THREE.Vector3().subVectors(validPoints[p2], validPoints[p1]).normalize();
      let maxDistToLine = 0;
      let p3 = -1;
      for (let i = 0; i < validPoints.length; i++) {
        if (i === p1 || i === p2) continue;
        const v = new THREE.Vector3().subVectors(validPoints[i], validPoints[p1]);
        const proj = lineDir.clone().multiplyScalar(v.dot(lineDir));
        const perpDist = v.clone().sub(proj).lengthSq();
        if (perpDist > maxDistToLine) {
          maxDistToLine = perpDist;
          p3 = i;
        }
      }

      if (p3 === -1) p3 = (p1 + 2) % validPoints.length;

      // Find fourth point farthest from the plane p1-p2-p3
      const normal = new THREE.Vector3()
        .crossVectors(
          new THREE.Vector3().subVectors(validPoints[p2], validPoints[p1]),
          new THREE.Vector3().subVectors(validPoints[p3], validPoints[p1])
        ).normalize();

      let maxDistToPlane = 0;
      let p4 = -1;
      for (let i = 0; i < validPoints.length; i++) {
        if (i === p1 || i === p2 || i === p3) continue;
        const d = Math.abs(new THREE.Vector3().subVectors(validPoints[i], validPoints[p1]).dot(normal));
        if (d > maxDistToPlane) {
          maxDistToPlane = d;
          p4 = i;
        }
      }

      if (p4 === -1) p4 = (p3 + 1) % validPoints.length;

      // Build initial tetrahedron faces
      const tetPoints = [validPoints[p1], validPoints[p2], validPoints[p3], validPoints[p4]];
      const tetCenter = new THREE.Vector3();
      tetPoints.forEach(p => tetCenter.add(p));
      tetCenter.divideScalar(4);

      // Four faces of tetrahedron with outward normals
      const faces = [];
      const faceIndices = [
        [p1, p2, p3],
        [p1, p3, p4],
        [p1, p4, p2],
        [p2, p4, p3]
      ];

      faceIndices.forEach(([a, b, c]) => {
        const faceNormal = new THREE.Vector3()
          .crossVectors(
            new THREE.Vector3().subVectors(validPoints[b], validPoints[a]),
            new THREE.Vector3().subVectors(validPoints[c], validPoints[a])
          ).normalize();

        const faceCentroid = new THREE.Vector3()
          .add(validPoints[a]).add(validPoints[b]).add(validPoints[c]).divideScalar(3);

        const toCenter = new THREE.Vector3().subVectors(tetCenter, faceCentroid);
        if (faceNormal.dot(toCenter) > 0) {
          faces.push({ vertices: [c, b, a], normal: faceNormal.negate() });
        } else {
          faces.push({ vertices: [a, b, c], normal: faceNormal });
        }
      });

      // Assign remaining points to faces
      const usedPoints = new Set([p1, p2, p3, p4]);

      faces.forEach(face => {
        face.outsidePoints = [];
        for (let i = 0; i < validPoints.length; i++) {
          if (usedPoints.has(i)) continue;
          const faceCentroid = new THREE.Vector3()
            .add(validPoints[face.vertices[0]])
            .add(validPoints[face.vertices[1]])
            .add(validPoints[face.vertices[2]])
            .divideScalar(3);
          const toPoint = new THREE.Vector3().subVectors(validPoints[i], faceCentroid);
          if (toPoint.dot(face.normal) > 0.001) {
            face.outsidePoints.push(i);
          }
        }
      });

      // Iteratively expand hull
      let iterations = 0;
      const maxIterations = Math.min(100, validPoints.length);

      while (iterations++ < maxIterations) {
        let maxFace = null;
        let maxPointIdx = -1;
        let maxDistance = 0;

        for (const face of faces) {
          if (face.outsidePoints.length === 0) continue;

          const faceCentroid = new THREE.Vector3()
            .add(validPoints[face.vertices[0]])
            .add(validPoints[face.vertices[1]])
            .add(validPoints[face.vertices[2]])
            .divideScalar(3);

          for (const idx of face.outsidePoints) {
            const d = new THREE.Vector3().subVectors(validPoints[idx], faceCentroid).dot(face.normal);
            if (d > maxDistance) {
              maxDistance = d;
              maxPointIdx = idx;
              maxFace = face;
            }
          }
        }

        if (!maxFace) break;

        const newPoint = validPoints[maxPointIdx];
        usedPoints.add(maxPointIdx);

        const visibleFaces = [];
        const horizonEdges = new Map();

        for (let fi = 0; fi < faces.length; fi++) {
          const face = faces[fi];
          const faceCentroid = new THREE.Vector3()
            .add(validPoints[face.vertices[0]])
            .add(validPoints[face.vertices[1]])
            .add(validPoints[face.vertices[2]])
            .divideScalar(3);
          const toPoint = new THREE.Vector3().subVectors(newPoint, faceCentroid);

          if (toPoint.dot(face.normal) > 0.001) {
            visibleFaces.push(fi);

            const edges = [
              [face.vertices[0], face.vertices[1]],
              [face.vertices[1], face.vertices[2]],
              [face.vertices[2], face.vertices[0]]
            ];

            edges.forEach(([a, b]) => {
              const key = a < b ? `${a}-${b}` : `${b}-${a}`;
              if (horizonEdges.has(key)) {
                horizonEdges.delete(key);
              } else {
                horizonEdges.set(key, [a, b, fi]);
              }
            });
          }
        }

        if (visibleFaces.length === 0) continue;

        const reassignPoints = [];
        visibleFaces.forEach(fi => {
          faces[fi].outsidePoints.forEach(idx => {
            if (idx !== maxPointIdx) reassignPoints.push(idx);
          });
        });

        const newFaces = [];
        horizonEdges.forEach(([a, b]) => {
          const faceNormal = new THREE.Vector3()
            .crossVectors(
              new THREE.Vector3().subVectors(validPoints[b], validPoints[a]),
              new THREE.Vector3().subVectors(newPoint, validPoints[a])
            ).normalize();

          const faceCentroid = new THREE.Vector3()
            .add(validPoints[a]).add(validPoints[b]).add(newPoint).divideScalar(3);
          const toCenter = new THREE.Vector3().subVectors(center, faceCentroid);
          if (faceNormal.dot(toCenter) > 0) {
            faceNormal.negate();
            newFaces.push({ vertices: [maxPointIdx, b, a], normal: faceNormal, outsidePoints: [] });
          } else {
            newFaces.push({ vertices: [a, b, maxPointIdx], normal: faceNormal, outsidePoints: [] });
          }
        });

        visibleFaces.sort((a, b) => b - a);
        visibleFaces.forEach(fi => faces.splice(fi, 1));

        faces.push(...newFaces);

        newFaces.forEach(face => {
          reassignPoints.forEach(idx => {
            const faceCentroid = new THREE.Vector3()
              .add(validPoints[face.vertices[0]])
              .add(validPoints[face.vertices[1]])
              .add(validPoints[face.vertices[2]])
              .divideScalar(3);
            const toPoint = new THREE.Vector3().subVectors(validPoints[idx], faceCentroid);
            if (toPoint.dot(face.normal) > 0.001) {
              face.outsidePoints.push(idx);
            }
          });
        });
      }

      // Convert faces to vertex array
      const vertices = [];
      faces.forEach(face => {
        vertices.push(
          validPoints[face.vertices[0]].x, validPoints[face.vertices[0]].y, validPoints[face.vertices[0]].z,
          validPoints[face.vertices[1]].x, validPoints[face.vertices[1]].y, validPoints[face.vertices[1]].z,
          validPoints[face.vertices[2]].x, validPoints[face.vertices[2]].y, validPoints[face.vertices[2]].z
        );
      });

      return { vertices: new Float32Array(vertices), center, indices: [] };
    }

    function createSimpleHull(points) {
      // Filter out any invalid points
      const validPoints = points.filter(isValidPosition);

      if (validPoints.length === 0) {
        return { vertices: new Float32Array([]), center: new THREE.Vector3() };
      }

      const center = new THREE.Vector3();
      validPoints.forEach(p => center.add(p));
      center.divideScalar(validPoints.length);

      const vertices = [];

      if (validPoints.length === 1) {
        // Single point - create small tetrahedron
        const p = validPoints[0];
        const size = 1;
        vertices.push(
          p.x, p.y + size, p.z,
          p.x - size, p.y - size, p.z - size,
          p.x + size, p.y - size, p.z - size,
          p.x, p.y + size, p.z,
          p.x + size, p.y - size, p.z - size,
          p.x, p.y - size, p.z + size,
          p.x, p.y + size, p.z,
          p.x, p.y - size, p.z + size,
          p.x - size, p.y - size, p.z - size,
          p.x - size, p.y - size, p.z - size,
          p.x, p.y - size, p.z + size,
          p.x + size, p.y - size, p.z - size
        );
      } else if (validPoints.length === 2) {
        // Two points - create tube-like shape
        const p1 = validPoints[0], p2 = validPoints[1];
        const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
        vertices.push(
          p1.x, p1.y, p1.z,
          mid.x, mid.y + 1, mid.z,
          p2.x, p2.y, p2.z,
          p1.x, p1.y, p1.z,
          p2.x, p2.y, p2.z,
          mid.x, mid.y - 1, mid.z
        );
      } else if (validPoints.length === 3) {
        // Three points - create double-sided triangle
        vertices.push(
          validPoints[0].x, validPoints[0].y, validPoints[0].z,
          validPoints[1].x, validPoints[1].y, validPoints[1].z,
          validPoints[2].x, validPoints[2].y, validPoints[2].z,
          validPoints[2].x, validPoints[2].y, validPoints[2].z,
          validPoints[1].x, validPoints[1].y, validPoints[1].z,
          validPoints[0].x, validPoints[0].y, validPoints[0].z
        );
      }

      return { vertices: new Float32Array(vertices), center };
    }

    /**
     * Create a glass mesh from convex hull
     */
    function createHullMesh(hullData, color = COLORS.surfaces.cluster) {
      // Validate vertices don't contain NaN
      if (!hullData.vertices || hullData.vertices.some(v => isNaN(v))) {
        console.warn('Hull has invalid vertices');
        return null;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(hullData.vertices, 3));
      geometry.computeVertexNormals();

      const material = createGlassMaterial(color, {
        opacity: 0.12,
        fresnelPower: 2.0,
        glowIntensity: 0.25
      });
      glassMaterials.push(material);

      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData = { isHull: true, center: hullData.center };

      return mesh;
    }

    // ==========================================================================
    // UI CONTROL FUNCTIONS (Global scope for onclick handlers)
    // ==========================================================================

    // These need to be in global scope for HTML onclick attributes
    window.setConsolidationStrategy = function(strategy) {
      CONFIG.consolidation.strategy = strategy;
      consolidationState.strategy = strategy;

      // Update button states
      document.querySelectorAll('[data-strategy]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.strategy === strategy);
      });

      document.getElementById('consolidation-badge').textContent = strategy.toUpperCase();

      console.log(`Consolidation strategy changed to ${strategy}`);

      // Apply new strategy using shared function
      applyConsolidationSettings();
    };

    window.hideClusterOverlay = function() {
      document.getElementById('cluster-overlay').classList.remove('visible');
    };

    function showClusterOverlay(metaNode) {
      const overlay = document.getElementById('cluster-overlay');
      const title = document.getElementById('cluster-title');
      const count = document.getElementById('cluster-node-count');
      const grid = document.getElementById('cluster-node-grid');

      const metaData = graphState.metaNodes.get(metaNode.id);
      if (!metaData) return;

      title.textContent = metaNode.label || 'Cluster';
      count.textContent = `${metaData.constituent_count} nodes`;

      // Populate grid
      grid.innerHTML = '';
      metaData.constituents.forEach(node => {
        const card = document.createElement('div');
        card.className = 'cluster-node-card';

        const typeColor = getNodeColorCSS(node.type);
        card.innerHTML = `
          <span class="type-badge" style="background: ${typeColor}20; color: ${typeColor}">${node.type || 'unknown'}</span>
          <div class="content">${node.content || node.description || node.name || node.id}</div>
          <div class="timestamp">${formatTimestamp(node.timestamp || node.created_at)}</div>
        `;

        card.onclick = () => {
          hideClusterOverlay();
          focusOnNode(node.id);
        };

        grid.appendChild(card);
      });

      overlay.classList.add('visible');
    }

    function formatTimestamp(ts) {
      if (!ts) return 'Unknown time';
      const date = new Date(ts);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }

    function updateConsolidationUI() {
      document.getElementById('stat-original').textContent = consolidationState.originalCount.toLocaleString();
      document.getElementById('stat-after').textContent = consolidationState.consolidatedCount.toLocaleString();
      document.getElementById('stat-meta-clusters').textContent = consolidationState.metaClusters.toLocaleString();

      const ratio = consolidationState.originalCount > 0
        ? (consolidationState.originalCount / consolidationState.consolidatedCount).toFixed(1)
        : '1.0';
      document.getElementById('stat-compression').textContent = `${ratio}x`;
    }

    // ==========================================================================
    // DATA FETCHING
    // ==========================================================================

    async function fetchGraphData() {
      try {
        const response = await fetch(`${CONFIG.apiBase}/api/graph?limit=${CONFIG.maxNodes}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        console.log(`Fetched ${data.nodes.length} nodes, ${data.relationships.length} relationships`);

        // If API returns empty data, show message and offer demo data
        if (!data.nodes || data.nodes.length === 0) {
          console.log('API returned empty data. Showing demo data option.');
          processGraphData({ nodes: [], relationships: [] });
          updateStats();
          updateConsolidationUI();
          showNoDataMessage();
          return;
        }

        processGraphData(data);
        updateStats();
        updateConsolidationUI();

      } catch (error) {
        console.error('Failed to fetch graph data:', error);
        // Create demo data if API fails
        createDemoData();
      }
    }

    function processGraphData(data) {
      // Clear existing
      clearGraph();

      // Normalize relationships to use source/target instead of source_id/target_id
      const normalizedRelationships = data.relationships.map(rel => ({
        ...rel,
        source: rel.source || rel.source_id,
        target: rel.target || rel.target_id
      }));

      // Always store raw data for later re-processing
      graphState.rawNodes = data.nodes;
      graphState.rawRelationships = normalizedRelationships;

      // Apply consolidation if enabled, otherwise pass through with state update
      let consolidated;
      if (CONFIG.consolidation.enabled) {
        consolidated = consolidateNodes(data.nodes, normalizedRelationships, CONFIG.maxNodes);
      } else {
        // Even without consolidation, update the state for UI
        consolidationState.originalCount = data.nodes.length;
        consolidationState.consolidatedCount = data.nodes.length;
        consolidationState.metaClusters = 0;
        consolidationState.level = 0;
        consolidated = { nodes: data.nodes, relationships: normalizedRelationships, metaNodes: [] };
      }

      // Store consolidated nodes
      consolidated.nodes.forEach(node => {
        graphState.nodes.set(node.id, node);
      });

      // Store consolidated relationships
      consolidated.relationships.forEach(rel => {
        graphState.relationships.set(rel.id || `${rel.source}-${rel.target}`, rel);
      });

      // Calculate relationshipCount for each node
      graphState.nodes.forEach((node, nodeId) => {
        let count = 0;
        graphState.relationships.forEach(rel => {
          if (rel.source === nodeId || rel.target === nodeId) {
            count++;
          }
        });
        node.relationshipCount = count;
      });

      console.log(`Graph loaded: ${graphState.nodes.size} nodes, ${graphState.relationships.size} relationships`);

      // Update stats
      graphState.stats.totalNodes = data.nodes.length;
      graphState.stats.visibleNodes = consolidated.nodes.length;
      graphState.stats.relationshipCount = consolidated.relationships.length;
      graphState.stats.metaNodeCount = consolidated.metaNodes.length;
      graphState.stats.consolidationLevel = consolidationState.level;
      graphState.stats.compressionRatio = data.nodes.length / consolidated.nodes.length;

      // Initialize positions (Fibonacci sphere for spherical distribution)
      initializeNodePositions();

      // Physics now runs animated each frame (not blocking)
      // initPhysicsState() is called by initializeNodePositions()
      console.log(`Animated physics ${physicsState.running ? 'enabled' : 'disabled'} for ${graphState.nodes.size} nodes`);

      // Create visual objects
      createNodeMeshes();
      createEdgeLines();

      // Create convex hulls for meta-nodes
      createMetaNodeHulls();

      // Detect and render topology structures
      detectTopologyStructures();

      // Clean up any objects with invalid geometry before first render
      cleanupInvalidGeometriesImmediate();

      // Update consolidation UI
      updateConsolidationUI();
    }

    // Immediate cleanup (runs during data load, before animate starts)
    function cleanupInvalidGeometriesImmediate() {
      let removed = 0;

      // Helper to check if geometry has NaN in position data
      function hasNaNGeometry(obj) {
        if (!obj.geometry) return false;
        const posAttr = obj.geometry.attributes?.position;
        if (posAttr) {
          const arr = posAttr.array;
          for (let i = 0; i < Math.min(arr.length, 30); i++) {
            if (isNaN(arr[i])) return true;
          }
        }
        return false;
      }

      // Check and remove invalid edge lines
      graphState.edgeLines = graphState.edgeLines.filter(line => {
        if (hasNaNGeometry(line)) {
          scene.remove(line);
          line.geometry?.dispose();
          line.material?.dispose();
          removed++;
          return false;
        }
        return true;
      });

      // Check and remove invalid surface meshes
      graphState.surfaceMeshes = graphState.surfaceMeshes.filter(mesh => {
        if (hasNaNGeometry(mesh)) {
          scene.remove(mesh);
          mesh.geometry?.dispose();
          mesh.material?.dispose();
          removed++;
          return false;
        }
        return true;
      });

      // Check and remove invalid chain meshes
      graphState.chainMeshes = graphState.chainMeshes.filter(mesh => {
        if (hasNaNGeometry(mesh)) {
          scene.remove(mesh);
          mesh.geometry?.dispose();
          mesh.material?.dispose();
          removed++;
          return false;
        }
        return true;
      });

      if (removed > 0) {
        console.log(`Pre-render cleanup: removed ${removed} objects with invalid geometry`);
      }
    }

    function clearGraph() {
      // Helper to dispose Three.js object properly
      function disposeObject(obj) {
        if (obj.geometry) {
          obj.geometry.dispose();
        }
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      }

      // Remove and dispose node meshes
      graphState.nodeMeshes.forEach(mesh => {
        scene.remove(mesh);
        disposeObject(mesh);
      });
      graphState.nodeMeshes.clear();

      // Remove and dispose surface meshes
      graphState.surfaceMeshes.forEach(mesh => {
        scene.remove(mesh);
        disposeObject(mesh);
      });
      graphState.surfaceMeshes = [];

      // Remove and dispose edge lines
      graphState.edgeLines.forEach(line => {
        scene.remove(line);
        disposeObject(line);
      });
      graphState.edgeLines = [];

      // Remove and dispose chain meshes
      graphState.chainMeshes.forEach(chain => {
        scene.remove(chain);
        disposeObject(chain);
      });
      graphState.chainMeshes = [];

      // Remove and dispose cluster hulls
      graphState.clusterHulls.forEach(hull => {
        scene.remove(hull);
        disposeObject(hull);
      });
      graphState.clusterHulls.clear();

      // Clear data
      graphState.nodes.clear();
      graphState.relationships.clear();
      graphState.nodePositions.clear();
      graphState.metaNodes.clear();
      graphState.expandedMetaNodes.clear();
      graphState.triangles = [];
      graphState.tetrahedra = [];
      graphState.higherCliques = [];
      graphState.chains = [];
      graphState.clusters = [];

      // Clear and dispose glass materials
      glassMaterials.forEach(m => m.dispose());
      glassMaterials.length = 0;

      // Reset cleanup flag so it runs again on next data load
      sceneCleanedUp = false;
    }

    /**
     * Create convex hull meshes for meta-nodes (clusters)
     */
    function createMetaNodeHulls() {
      graphState.metaNodes.forEach((metaData, metaId) => {
        // Get positions of constituent nodes
        const positions = [];
        metaData.constituents.forEach(node => {
          const pos = graphState.nodePositions.get(node.id);
          // Validate position is a valid Vector3 with no NaN values
          if (isValidPosition(pos)) {
            positions.push(pos.clone());
          }
        });

        // Need at least 3 points for a meaningful hull
        if (positions.length < 3) return;

        // Compute convex hull
        const hullData = computeConvexHull3D(positions);

        if (hullData.vertices.length === 0) return;

        // Create hull mesh
        const hullMesh = createHullMesh(hullData, COLORS.surfaces.cluster);
        hullMesh.userData = {
          isHull: true,
          metaNodeId: metaId,
          structureType: 'Cluster',
          nodeIds: metaData.constituent_ids,
          nodeCount: metaData.constituent_count
        };

        scene.add(hullMesh);
        graphState.clusterHulls.set(metaId, hullMesh);
      });

      graphState.stats.clusterCount = graphState.clusterHulls.size;
    }

    // ==========================================================================
    // NODE POSITIONING (Community-Based Clustering)
    // ==========================================================================

    // Detect communities using label propagation for layout positioning
    function detectLayoutCommunities() {
      const nodeIds = Array.from(graphState.nodes.keys());
      const labels = new Map();  // nodeId -> community label
      const adjacency = new Map();  // nodeId -> [neighborIds]

      // Initialize: each node is its own community
      nodeIds.forEach((id, i) => {
        labels.set(id, i);
        adjacency.set(id, []);
      });

      // Build adjacency list
      let matchedRels = 0;
      let unmatchedRels = 0;
      graphState.relationships.forEach(rel => {
        if (adjacency.has(rel.source) && adjacency.has(rel.target)) {
          adjacency.get(rel.source).push(rel.target);
          adjacency.get(rel.target).push(rel.source);
          matchedRels++;
        } else {
          unmatchedRels++;
        }
      });
      console.log(`Adjacency: ${matchedRels} matched, ${unmatchedRels} unmatched relationships`);

      // Label propagation: iterate until stable
      const maxIterations = 20;
      for (let iter = 0; iter < maxIterations; iter++) {
        let changed = false;

        // Shuffle node order for randomness
        const shuffled = [...nodeIds].sort(() => Math.random() - 0.5);

        for (const nodeId of shuffled) {
          const neighbors = adjacency.get(nodeId) || [];
          if (neighbors.length === 0) continue;

          // Count neighbor labels
          const labelCounts = new Map();
          for (const neighbor of neighbors) {
            const label = labels.get(neighbor);
            labelCounts.set(label, (labelCounts.get(label) || 0) + 1);
          }

          // Find most common label
          let maxCount = 0;
          let bestLabel = labels.get(nodeId);
          for (const [label, count] of labelCounts) {
            if (count > maxCount) {
              maxCount = count;
              bestLabel = label;
            }
          }

          // Update if different
          if (bestLabel !== labels.get(nodeId)) {
            labels.set(nodeId, bestLabel);
            changed = true;
          }
        }

        if (!changed) {
          console.log(`Community detection converged at iteration ${iter}`);
          break;
        }
      }

      // Group nodes by community
      const communities = new Map();  // label -> [nodeIds]
      for (const [nodeId, label] of labels) {
        if (!communities.has(label)) {
          communities.set(label, []);
        }
        communities.get(label).push(nodeId);
      }

      // Store community assignments
      graphState.communities = communities;
      graphState.nodeLabels = labels;

      console.log(`Detected ${communities.size} communities`);
      return communities;
    }

    function initializeNodePositions() {
      const nodeArray = Array.from(graphState.nodes.values());
      const count = nodeArray.length;

      if (count === 0) {
        console.log('No nodes to position');
        return;
      }

      // Detect communities first
      const communities = detectLayoutCommunities();
      const communityList = Array.from(communities.entries());
      const numCommunities = communityList.length;

      console.log(`Positioning ${count} nodes in ${numCommunities} communities`);

      // Much larger space for better separation
      const spaceSize = CONFIG.sphereRadius * 4;
      const communityCenters = new Map();

      // Separate connected communities from isolated nodes
      const connectedCommunities = communityList.filter(([_, nodes]) => nodes.length > 1);
      const isolatedNodes = communityList.filter(([_, nodes]) => nodes.length === 1);

      console.log(`Connected communities: ${connectedCommunities.length}, Isolated nodes: ${isolatedNodes.length}`);

      const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle for Fibonacci spirals

      // Halton sequence for true low-discrepancy 3D distribution
      function halton(index, base) {
        let result = 0;
        let f = 1 / base;
        let i = index + 1; // 1-indexed for better distribution
        while (i > 0) {
          result += f * (i % base);
          i = Math.floor(i / base);
          f /= base;
        }
        return result;
      }

      // Position CONNECTED communities in the central region using Halton sequence
      const centralRegion = spaceSize * 0.5; // Inner 50% of space
      connectedCommunities.forEach(([label, nodeIds], i) => {
        const hx = halton(i, 2);
        const hy = halton(i, 3);
        const hz = halton(i, 5);

        const x = (hx - 0.5) * centralRegion;
        const y = (hy - 0.5) * centralRegion;
        const z = (hz - 0.5) * centralRegion;

        const jitter = centralRegion * 0.05;
        const center = new THREE.Vector3(
          x + (Math.random() - 0.5) * jitter,
          y + (Math.random() - 0.5) * jitter,
          z + (Math.random() - 0.5) * jitter
        );
        communityCenters.set(label, center);
      });

      // Position ISOLATED nodes in outer shell using Fibonacci sphere
      const outerRadius = spaceSize * 0.4; // Outer shell
      const innerRadius = spaceSize * 0.25; // Inner boundary of shell
      isolatedNodes.forEach(([label, nodeIds], i) => {
        // Fibonacci sphere for even distribution on outer shell
        const y = 1 - (i / Math.max(isolatedNodes.length - 1, 1)) * 2;
        const radiusAtY = Math.sqrt(1 - y * y);
        const theta = phi * i;

        // Random radius within shell
        const r = innerRadius + Math.random() * (outerRadius - innerRadius);

        const center = new THREE.Vector3(
          Math.cos(theta) * radiusAtY * r,
          y * r,
          Math.sin(theta) * radiusAtY * r
        );
        communityCenters.set(label, center);
      });

      // Log community size distribution
      const sizes = communityList.map(([_, nodes]) => nodes.length).sort((a, b) => b - a);
      console.log(`Community sizes - largest: ${sizes[0]}, top 5: [${sizes.slice(0, 5).join(', ')}], single-node: ${sizes.filter(s => s === 1).length}`);

      // Position nodes within their community
      communityList.forEach(([label, nodeIds]) => {
        const center = communityCenters.get(label);
        const clusterSize = nodeIds.length;

        // Cluster radius scales more aggressively with node count
        // Single nodes: 0, small clusters: modest, large clusters: much bigger
        const clusterRadius = clusterSize === 1 ? 0 : Math.max(8, Math.sqrt(clusterSize) * 8);

        nodeIds.forEach((nodeId, i) => {
          let position;

          if (clusterSize === 1) {
            // Single node - place at center
            position = center.clone();
          } else {
            // Fibonacci sphere within cluster
            const y = 1 - (i / (clusterSize - 1)) * 2;
            const radiusAtY = Math.sqrt(1 - y * y);
            const theta = phi * i;

            // Add jitter for natural look
            const jitter = 0.1;
            position = new THREE.Vector3(
              center.x + (Math.cos(theta) * radiusAtY + (Math.random() - 0.5) * jitter) * clusterRadius,
              center.y + (y + (Math.random() - 0.5) * jitter) * clusterRadius,
              center.z + (Math.sin(theta) * radiusAtY + (Math.random() - 0.5) * jitter) * clusterRadius
            );
          }

          if (isValidPosition(position)) {
            graphState.nodePositions.set(nodeId, position);
          } else {
            graphState.nodePositions.set(nodeId, center.clone());
          }
        });
      });

      // Initialize physics for fine-tuning (optional, with gentle forces)
      initPhysicsState();
    }

    function initPhysicsState() {
      physicsState.velocities.clear();
      graphState.nodes.forEach((node, id) => {
        physicsState.velocities.set(id, new THREE.Vector3(0, 0, 0));
      });
      physicsState.iteration = 0;
      physicsState.running = CONFIG.physicsEnabled && CONFIG.physicsAnimated;
      physicsState.converged = false;
      console.log(`Physics initialized: ${physicsState.running ? 'running' : 'disabled'}`);
    }

    // Animated physics step - runs once per frame for smooth simulation
    function physicsStep() {
      if (!physicsState.running || physicsState.converged) {
        return;
      }

      // Check iteration limit
      if (physicsState.iteration >= CONFIG.physicsMaxIterations) {
        physicsState.running = false;
        physicsState.converged = true;
        console.log(`Physics converged after ${physicsState.iteration} iterations`);
        return;
      }

      const nodes = Array.from(graphState.nodes.values());
      const positions = graphState.nodePositions;
      const velocities = physicsState.velocities;

      // Track total movement for convergence detection
      let totalMovement = 0;

      // 1. SAMPLED REPULSION (O(samples) instead of O(n¬≤))
      // Randomly sample node pairs for repulsion to make it efficient
      for (let s = 0; s < CONFIG.repulsionSamples; s++) {
        const i = Math.floor(Math.random() * nodes.length);
        const j = Math.floor(Math.random() * nodes.length);
        if (i === j) continue;

        const posA = positions.get(nodes[i].id);
        const posB = positions.get(nodes[j].id);
        if (!isValidPosition(posA) || !isValidPosition(posB)) continue;

        const delta = posA.clone().sub(posB);
        const dist = delta.length();
        if (dist < 0.5) continue;  // Minimum distance

        // Inverse square repulsion, scaled for sampling
        const scaleFactor = (nodes.length * nodes.length) / (CONFIG.repulsionSamples * 2);
        const force = (CONFIG.repulsionStrength / (dist * dist)) / scaleFactor;
        const clampedForce = Math.min(force, 2);  // Clamp to prevent explosions

        delta.normalize().multiplyScalar(clampedForce);

        velocities.get(nodes[i].id)?.add(delta);
        velocities.get(nodes[j].id)?.sub(delta);

        // STRONG close-range repulsion to prevent collapse
        const minDist = CONFIG.minNodeDistance || 2.0;
        if (dist < minDist) {
          const pushForce = (minDist - dist) * 0.5;  // Strong push when too close
          const pushDelta = posA.clone().sub(posB).normalize().multiplyScalar(pushForce);
          velocities.get(nodes[i].id)?.add(pushDelta);
          velocities.get(nodes[j].id)?.sub(pushDelta);
        }
      }

      // 2. SAMPLED EDGE ATTRACTION - only process subset of edges
      // Skip if attraction is disabled
      if (CONFIG.attractionStrength > 0) {
        const relationships = Array.from(graphState.relationships.values());
        const attractionSamples = Math.min(CONFIG.attractionSamples || 100, relationships.length);
        const attractionThreshold = (CONFIG.minNodeDistance || 3.0) * 2;

        for (let s = 0; s < attractionSamples; s++) {
          const rel = relationships[Math.floor(Math.random() * relationships.length)];
          const posA = positions.get(rel.source);
          const posB = positions.get(rel.target);

          if (!isValidPosition(posA) || !isValidPosition(posB)) continue;
          if (!velocities.has(rel.source) || !velocities.has(rel.target)) continue;

          const delta = posB.clone().sub(posA);
          const dist = delta.length();

          // Only attract if far apart - prevents collapse
          if (dist < attractionThreshold) continue;

          // Scaled attraction force
          const scaleFactor = relationships.length / attractionSamples;
          const force = dist * CONFIG.attractionStrength / scaleFactor;
          delta.normalize().multiplyScalar(force);

          velocities.get(rel.source).add(delta);
          velocities.get(rel.target).sub(delta);
        }
      }

      // 3. SPHERICAL BOUNDARY FORCE - keeps nodes within sphere
      const sphereRadius = CONFIG.sphereRadius;
      nodes.forEach(node => {
        const pos = positions.get(node.id);
        if (!isValidPosition(pos)) return;

        const dist = pos.length();
        if (dist > sphereRadius) {
          // Push back toward sphere surface
          const overshoot = dist - sphereRadius;
          const toCenter = pos.clone().negate().normalize();
          toCenter.multiplyScalar(overshoot * CONFIG.sphereBoundaryStrength);
          velocities.get(node.id)?.add(toCenter);
        }
      });

      // 4. GENTLE CENTERING - prevents drift
      nodes.forEach(node => {
        const pos = positions.get(node.id);
        if (!isValidPosition(pos)) return;

        const toCenter = pos.clone().negate().multiplyScalar(CONFIG.centeringStrength);
        velocities.get(node.id)?.add(toCenter);
      });

      // 5. APPLY VELOCITIES
      nodes.forEach(node => {
        const pos = positions.get(node.id);
        const vel = velocities.get(node.id);

        if (!isValidPosition(pos) || !vel) return;

        // Apply velocity
        pos.add(vel);
        totalMovement += vel.length();

        // Apply damping
        vel.multiplyScalar(CONFIG.damping);

        // NaN protection
        if (isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z)) {
          pos.set(0, 0, 0);
          vel.set(0, 0, 0);
        }
      });

      // 6. UPDATE VISUAL OBJECTS
      updateNodeMeshPositions();
      updateEdgePositions();

      // Check for convergence (average movement below threshold)
      const avgMovement = totalMovement / nodes.length;
      if (avgMovement < 0.001 && physicsState.iteration > 100) {
        physicsState.converged = true;
        physicsState.running = false;
        console.log(`Physics converged at iteration ${physicsState.iteration} (avg movement: ${avgMovement.toFixed(6)})`);
        updatePhysicsButton();
      }

      physicsState.iteration++;

      // Update UI every 10 iterations (avoid overhead)
      if (physicsState.iteration % 10 === 0) {
        updatePhysicsButton();
      }
    }

    // Update node mesh positions from physics state
    function updateNodeMeshPositions() {
      graphState.nodeMeshes.forEach((mesh, id) => {
        const pos = graphState.nodePositions.get(id);
        if (pos && isValidPosition(pos)) {
          mesh.position.copy(pos);
        }
      });
    }

    // Update edge line positions from physics state
    function updateEdgePositions() {
      graphState.edgeLines.forEach(line => {
        const rel = line.userData.relationship;
        if (!rel) return;

        const sourcePos = graphState.nodePositions.get(rel.source);
        const targetPos = graphState.nodePositions.get(rel.target);

        if (sourcePos && targetPos && isValidPosition(sourcePos) && isValidPosition(targetPos)) {
          const positions = line.geometry.attributes.position;
          positions.setXYZ(0, sourcePos.x, sourcePos.y, sourcePos.z);
          positions.setXYZ(1, targetPos.x, targetPos.y, targetPos.z);
          positions.needsUpdate = true;
        }
      });
    }

    // Toggle physics simulation
    function togglePhysics() {
      if (physicsState.running) {
        physicsState.running = false;
        console.log('Physics paused');
      } else {
        physicsState.running = true;
        physicsState.converged = false;
        console.log('Physics resumed');
      }
      updatePhysicsButton();
    }

    // Reset and restart physics
    function restartPhysics() {
      initPhysicsState();
      console.log('Physics restarted');
      updatePhysicsButton();
    }

    function updatePhysicsButton() {
      const btn = document.getElementById('physics-toggle');
      const navBtn = document.getElementById('nav-pause');

      if (btn) {
        if (physicsState.converged) {
          btn.textContent = '‚úì Done';
          btn.style.background = '#10b981';
        } else {
          btn.textContent = physicsState.running ? '‚è∏ Pause' : '‚ñ∂ Resume';
          btn.style.background = physicsState.running ? '#f59e0b' : '#6366f1';
        }
      }

      // Update nav bar pause button
      if (navBtn) {
        if (physicsState.converged) {
          navBtn.textContent = '‚úì Done';
          navBtn.classList.remove('orange');
          navBtn.classList.add('emerald');
        } else {
          navBtn.textContent = physicsState.running ? '‚è∏ Pause' : '‚ñ∂ Resume';
          navBtn.classList.remove('emerald');
          navBtn.classList.add('orange');
        }
      }

      // Update iteration counter
      const iterSpan = document.getElementById('physics-iter');
      if (iterSpan) {
        iterSpan.textContent = physicsState.iteration;
      }
    }

    // ==========================================================================
    // NODE RENDERING
    // ==========================================================================

    function createNodeMeshes() {
      let nodesCreated = 0;
      let nodesSkipped = 0;

      // Limit max nodes for performance
      const maxNodesToRender = Math.min(graphState.nodes.size, CONFIG.maxNodes || 2000);

      for (const [id, node] of graphState.nodes) {
        // Safety limit
        if (nodesCreated >= maxNodesToRender) {
          console.log(`Node limit reached: ${maxNodesToRender}`);
          break;
        }

        const position = graphState.nodePositions.get(id);

        // Skip nodes with invalid positions
        if (!isValidPosition(position)) {
          nodesSkipped++;
          continue;
        }

        const color = getNodeColor(node.type);
        const size = getNodeSize(node);

        // Create geometry based on type
        let geometry;
        const nodeType = (node.type || '').toLowerCase();

        switch (nodeType) {
          case 'belief':
            geometry = new THREE.OctahedronGeometry(size, 0);
            break;
          case 'desire':
            geometry = new THREE.TetrahedronGeometry(size, 0);
            break;
          case 'goal':
            geometry = new THREE.DodecahedronGeometry(size * 0.8, 0);
            break;
          case 'crystal':
            geometry = new THREE.IcosahedronGeometry(size, 0);
            break;
          case 'capability':
            geometry = new THREE.BoxGeometry(size * 1.2, size * 1.2, size * 1.2);
            break;
          case 'reflection':
            geometry = new THREE.TorusKnotGeometry(size * 0.5, size * 0.15, 64, 8, 2, 3);
            break;
          case 'trajectory':
            geometry = new THREE.CylinderGeometry(size * 0.5, size * 0.5, size * 1.5, 6);
            break;
          case 'heuristic':
            geometry = new THREE.IcosahedronGeometry(size * 0.9, 0);
            break;
          default:
            // experience, operatingsystem, etc.
            geometry = new THREE.SphereGeometry(size, 16, 16);
        }

        // Solid material for light background
        const material = new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.1,
          transparent: false,
          roughness: 0.4,
          metalness: 0.2
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(position);
        mesh.userData = { nodeId: id, nodeData: node };

        scene.add(mesh);
        graphState.nodeMeshes.set(id, mesh);
        nodesCreated++;
      }

      console.log(`Node rendering: ${nodesCreated} created, ${nodesSkipped} skipped (invalid positions)`);
    }

    function getNodeColor(type) {
      const normalizedType = (type || '').toLowerCase().replace(/\s+/g, '_');
      return COLORS.nodes[normalizedType] || COLORS.nodes.default;
    }

    function getNodeColorCSS(type) {
      const color = getNodeColor(type);
      return `#${color.toString(16).padStart(6, '0')}`;
    }

    function getNodeSize(node) {
      // Base size with variation based on importance/connections
      let size = CONFIG.nodeBaseSize;

      if (node.importance) {
        size += node.importance * CONFIG.nodeSizeVariation;
      }

      if (node.confidence) {
        size += node.confidence * CONFIG.nodeSizeVariation * 0.5;
      }

      return size;
    }

    // ==========================================================================
    // EDGE RENDERING
    // ==========================================================================

    // Shared edge material (created once, reused for all edges)
    let sharedEdgeMaterial = null;

    function createEdgeLines() {
      // Create shared material once (or reuse existing)
      if (!sharedEdgeMaterial) {
        sharedEdgeMaterial = new THREE.LineBasicMaterial({
          color: 0x444444,  // Darker grey
          transparent: true,
          opacity: 0.3,
          linewidth: 0.5  // Thinner
        });
      }

      let edgesCreated = 0;
      let edgesSkipped = 0;

      // Limit edges to prevent memory exhaustion
      const maxEdges = 5000;
      let edgeCount = 0;

      for (const rel of graphState.relationships.values()) {
        if (edgeCount >= maxEdges) {
          console.log(`Edge limit reached: ${maxEdges}`);
          break;
        }

        const sourcePos = graphState.nodePositions.get(rel.source);
        const targetPos = graphState.nodePositions.get(rel.target);

        // Validate positions exist and are valid Vector3 objects
        if (sourcePos && targetPos &&
            !isNaN(sourcePos.x) && !isNaN(sourcePos.y) && !isNaN(sourcePos.z) &&
            !isNaN(targetPos.x) && !isNaN(targetPos.y) && !isNaN(targetPos.z)) {
          const geometry = new THREE.BufferGeometry().setFromPoints([sourcePos, targetPos]);
          // SHARE material instead of cloning (major memory optimization)
          const line = new THREE.Line(geometry, sharedEdgeMaterial);
          line.userData = { relationship: rel, lodVisible: true };

          scene.add(line);
          graphState.edgeLines.push(line);
          edgesCreated++;
          edgeCount++;
        } else {
          edgesSkipped++;
        }
      }

      console.log(`Edge rendering: ${edgesCreated} created, ${edgesSkipped} skipped`);

      if (edgesCreated === 0 && graphState.relationships.size > 0) {
        console.error('No edges created! Check ID matching between nodes and relationships.');
      }
    }

    // ==========================================================================
    // TOPOLOGY DETECTION
    // ==========================================================================

    function detectTopologyStructures() {
      // Build adjacency map
      const adjacency = new Map();

      graphState.nodes.forEach((_, id) => {
        adjacency.set(id, new Set());
      });

      graphState.relationships.forEach(rel => {
        if (adjacency.has(rel.source) && adjacency.has(rel.target)) {
          adjacency.get(rel.source).add(rel.target);
          adjacency.get(rel.target).add(rel.source);
        }
      });

      // Find triangles (3-cliques)
      const triangles = findTriangles(adjacency);
      graphState.triangles = triangles;
      graphState.stats.triangleCount = triangles.length;

      // Find tetrahedra (4-cliques)
      const tetrahedra = findTetrahedra(adjacency, triangles);
      graphState.tetrahedra = tetrahedra;
      graphState.stats.tetrahedronCount = tetrahedra.length;

      // Find higher-order cliques (5+ nodes)
      const higherCliques = findHigherOrderCliques(adjacency, tetrahedra);
      graphState.higherCliques = higherCliques;
      graphState.stats.higherCliqueCount = higherCliques.length;

      // Find chains (A‚ÜíB‚ÜíC‚ÜíD sequences)
      const relationships = Array.from(graphState.relationships.values());
      const chains = findChains(adjacency, relationships);
      graphState.chains = chains;
      graphState.stats.chainCount = chains.length;

      console.log(`Topology: ${triangles.length} triangles, ${tetrahedra.length} tetrahedra, ${higherCliques.length} higher cliques, ${chains.length} chains`);

      // Debug: Check adjacency map population
      let edgeCount = 0;
      adjacency.forEach((neighbors, nodeId) => {
        edgeCount += neighbors.size;
      });
      console.log(`Adjacency map: ${adjacency.size} nodes, ${edgeCount / 2} edges`);

      // Debug: Sample triangle positions
      if (triangles.length > 0) {
        const sampleTri = triangles[0];
        const positions = sampleTri.map(id => graphState.nodePositions.get(id));
        console.log('Sample triangle:', sampleTri);
        console.log('Sample positions:', positions);
      }

      // Render topology structures
      renderTopologyStructures();
    }

    function findTriangles(adjacency) {
      const triangles = [];
      const visited = new Set();

      adjacency.forEach((neighbors, nodeA) => {
        neighbors.forEach(nodeB => {
          if (nodeB > nodeA) {
            const neighborsA = adjacency.get(nodeA);
            const neighborsB = adjacency.get(nodeB);

            neighborsA.forEach(nodeC => {
              if (nodeC > nodeB && neighborsB.has(nodeC)) {
                const key = [nodeA, nodeB, nodeC].sort().join('-');
                if (!visited.has(key)) {
                  visited.add(key);
                  triangles.push([nodeA, nodeB, nodeC]);
                }
              }
            });
          }
        });
      });

      return triangles;
    }

    function findTetrahedra(adjacency, triangles) {
      const tetrahedra = [];
      const visited = new Set();

      triangles.forEach(([a, b, c]) => {
        const neighborsA = adjacency.get(a);
        const neighborsB = adjacency.get(b);
        const neighborsC = adjacency.get(c);

        // Find nodes connected to all three
        neighborsA.forEach(d => {
          if (d !== a && d !== b && d !== c &&
              neighborsB.has(d) && neighborsC.has(d)) {
            const key = [a, b, c, d].sort().join('-');
            if (!visited.has(key)) {
              visited.add(key);
              tetrahedra.push([a, b, c, d]);
            }
          }
        });
      });

      return tetrahedra;
    }

    /**
     * Find higher-order cliques (5+ nodes fully connected)
     * Uses tetrahedra as a starting point and extends
     */
    function findHigherOrderCliques(adjacency, tetrahedra) {
      const higherCliques = [];
      const visited = new Set();

      tetrahedra.forEach(tetra => {
        const [a, b, c, d] = tetra;
        const neighborsA = adjacency.get(a) || new Set();
        const neighborsB = adjacency.get(b) || new Set();
        const neighborsC = adjacency.get(c) || new Set();
        const neighborsD = adjacency.get(d) || new Set();

        // Find nodes connected to all four tetrahedra vertices
        neighborsA.forEach(e => {
          if (e !== a && e !== b && e !== c && e !== d &&
              neighborsB.has(e) && neighborsC.has(e) && neighborsD.has(e)) {
            const clique = [a, b, c, d, e].sort();
            const key = clique.join('-');
            if (!visited.has(key)) {
              visited.add(key);

              // Try to extend to 6-clique
              const sixthCandidates = [];
              const neighborsE = adjacency.get(e) || new Set();

              neighborsA.forEach(f => {
                if (f !== a && f !== b && f !== c && f !== d && f !== e &&
                    neighborsB.has(f) && neighborsC.has(f) && neighborsD.has(f) && neighborsE.has(f)) {
                  sixthCandidates.push(f);
                }
              });

              if (sixthCandidates.length > 0) {
                // Found 6-cliques
                sixthCandidates.forEach(f => {
                  const sixClique = [a, b, c, d, e, f].sort();
                  const sixKey = sixClique.join('-');
                  if (!visited.has(sixKey)) {
                    visited.add(sixKey);
                    higherCliques.push({ nodes: sixClique, size: 6 });
                  }
                });
              } else {
                // Add the 5-clique
                higherCliques.push({ nodes: clique, size: 5 });
              }
            }
          }
        });
      });

      return higherCliques;
    }

    /**
     * Find chains (linear sequences A‚ÜíB‚ÜíC‚ÜíD... where each has degree ~2)
     * These represent derivation paths or causal sequences
     */
    function findChains(adjacency, relationships) {
      const chains = [];
      const visited = new Set();
      const directedAdj = new Map();

      // Build directed adjacency from relationship directions
      relationships.forEach(rel => {
        if (!directedAdj.has(rel.source)) directedAdj.set(rel.source, []);
        directedAdj.get(rel.source).push({
          target: rel.target,
          type: rel.type
        });
      });

      // Find chain starting points (nodes with outgoing but few incoming)
      const inDegree = new Map();
      const outDegree = new Map();

      directedAdj.forEach((targets, source) => {
        outDegree.set(source, (outDegree.get(source) || 0) + targets.length);
        targets.forEach(t => {
          inDegree.set(t.target, (inDegree.get(t.target) || 0) + 1);
        });
      });

      // Start from nodes with outgoing edges but low in-degree (source nodes)
      const potentialStarts = [];
      directedAdj.forEach((_, nodeId) => {
        const inD = inDegree.get(nodeId) || 0;
        const outD = outDegree.get(nodeId) || 0;
        if (outD > 0 && inD <= 1) {
          potentialStarts.push(nodeId);
        }
      });

      // Follow paths from each start
      potentialStarts.forEach(start => {
        if (visited.has(start)) return;

        const chain = {
          nodeIds: [start],
          relationshipTypes: []
        };

        let current = start;
        let maxLength = 20; // Prevent infinite loops

        while (maxLength-- > 0) {
          const outgoing = directedAdj.get(current) || [];
          // Find unvisited target with exactly one outgoing edge (continues chain)
          let next = null;
          let relType = null;

          for (const edge of outgoing) {
            if (!visited.has(edge.target) && !chain.nodeIds.includes(edge.target)) {
              // Prefer edges that continue a single path
              const targetOutDegree = outDegree.get(edge.target) || 0;
              if (targetOutDegree <= 2) {
                next = edge.target;
                relType = edge.type;
                break;
              }
            }
          }

          if (!next) break;

          chain.nodeIds.push(next);
          chain.relationshipTypes.push(relType);
          visited.add(current);
          current = next;
        }

        // Only keep chains of length 3+ (4+ nodes in a sequence)
        if (chain.nodeIds.length >= 4) {
          chains.push(chain);
        }
      });

      return chains;
    }

    /**
     * Get color based on relationship type
     */
    function getRelationshipColor(relType) {
      const type = (relType || '').toLowerCase();
      if (type.includes('derived') || type.includes('from')) return COLORS.surfaces.derived;
      if (type.includes('cause') || type.includes('leads') || type.includes('results')) return COLORS.surfaces.causal;
      if (type.includes('contradict') || type.includes('conflict') || type.includes('opposes')) return COLORS.surfaces.contradiction;
      if (type.includes('support') || type.includes('reinforces') || type.includes('strengthens')) return COLORS.surfaces.support;
      if (type.includes('relates') || type.includes('connects')) return COLORS.surfaces.derived;
      return COLORS.surfaces.cluster;
    }

    // ==========================================================================
    // TOPOLOGY RENDERING
    // ==========================================================================

    function renderTopologyStructures(animate = false) {
      console.log(`Rendering: ${graphState.triangles.length} triangles, ${graphState.tetrahedra.length} tetrahedra`);
      let trianglesRendered = 0;
      let trianglesSkipped = 0;

      // Render triangles as glass faces
      graphState.triangles.slice(0, 500).forEach((triangle, i) => {
        const positions = triangle.map(id => graphState.nodePositions.get(id));
        if (positions.every(isValidPosition)) {
          const mesh = createTriangleMesh(positions, triangle);
          if (mesh) {  // Handle null return from validation
            mesh.userData = {
              structureType: 'Triangle',
              nodeIds: triangle,
              relationshipCount: 3,
              baseOpacity: mesh.material.opacity
            };
            scene.add(mesh);
            graphState.surfaceMeshes.push(mesh);
            trianglesRendered++;

            if (animate) {
              queuePulseAnimation(mesh, mesh.material.opacity);
            }
          } else {
            trianglesSkipped++;
          }
        } else {
          trianglesSkipped++;
        }
      });
      console.log(`Triangle rendering: ${trianglesRendered} rendered, ${trianglesSkipped} skipped (missing positions)`);

      // Render tetrahedra as 4-faced shapes
      graphState.tetrahedra.slice(0, 200).forEach((tetra, i) => {
        const positions = tetra.map(id => graphState.nodePositions.get(id));
        if (positions.every(isValidPosition)) {
          const mesh = createTetrahedronMesh(positions, tetra);
          if (mesh) {  // Handle null return from validation
            mesh.userData = {
              structureType: 'Tetrahedron',
              nodeIds: tetra,
              relationshipCount: 6,
              baseOpacity: mesh.material.opacity
            };
            scene.add(mesh);
            graphState.surfaceMeshes.push(mesh);

            if (animate) {
              queuePulseAnimation(mesh, mesh.material.opacity);
            }
          }
        }
      });

      // Render higher-order cliques (5+ nodes) as convex hulls with special color
      graphState.higherCliques.slice(0, 100).forEach((clique, i) => {
        const positions = clique.nodes.map(id => graphState.nodePositions.get(id));
        if (positions.every(isValidPosition)) {
          const mesh = createHigherCliqueMesh(positions, clique);
          if (mesh) {  // Handle null return from validation
            mesh.userData = {
              structureType: `${clique.size}-Clique`,
              nodeIds: clique.nodes,
              relationshipCount: (clique.size * (clique.size - 1)) / 2,
              baseOpacity: mesh.material.opacity
            };
            scene.add(mesh);
            graphState.surfaceMeshes.push(mesh);

            if (animate) {
              queuePulseAnimation(mesh, mesh.material.opacity);
            }
          }
        }
      });

      // Render chains as flowing ribbons
      graphState.chains.slice(0, 50).forEach((chain, i) => {
        const positions = chain.nodeIds.map(id => graphState.nodePositions.get(id));
        if (positions.every(isValidPosition) && positions.length >= 3) {
          const mesh = createChainRibbon(positions, chain);
          if (mesh) {  // Handle null return from validation
            mesh.userData = {
              structureType: 'Chain',
              nodeIds: chain.nodeIds,
              relationshipTypes: chain.relationshipTypes,
              length: chain.nodeIds.length
            };
            scene.add(mesh);
            graphState.chainMeshes.push(mesh);

            if (animate) {
              queuePulseAnimation(mesh, 0.7);
            }
          }
        }
      });
    }

    /**
     * Create glass-morphism shader material with fresnel edge glow effect
     * This provides the signature supermemory-inspired glass aesthetic
     */
    function createGlassMaterial(baseColor, options = {}) {
      const {
        opacity = 0.15,
        fresnelPower = 2.0,
        glowIntensity = 0.3,
        pulseSpeed = 2.0
      } = options;

      const color = new THREE.Color(baseColor);

      return new THREE.ShaderMaterial({
        uniforms: {
          baseColor: { value: color },
          glassOpacity: { value: opacity },
          fresnelPower: { value: fresnelPower },
          glowIntensity: { value: glowIntensity },
          time: { value: 0 },
          pulseSpeed: { value: pulseSpeed },
          hoverIntensity: { value: 0 }  // For hover effects
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vViewPosition;
          varying vec2 vUv;

          void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            vUv = uv;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 baseColor;
          uniform float glassOpacity;
          uniform float fresnelPower;
          uniform float glowIntensity;
          uniform float time;
          uniform float pulseSpeed;
          uniform float hoverIntensity;

          varying vec3 vNormal;
          varying vec3 vViewPosition;
          varying vec2 vUv;

          void main() {
            // Fresnel effect for glass edges - brighter at glancing angles
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), fresnelPower);

            // Base glass color with fresnel glow
            vec3 glass = baseColor * glassOpacity;
            vec3 edgeGlow = baseColor * fresnel * glowIntensity;

            // Subtle breathing animation
            float pulse = 0.95 + 0.05 * sin(time * pulseSpeed);

            // Hover enhancement
            vec3 hoverGlow = baseColor * hoverIntensity * 0.5;

            // Combine effects
            vec3 finalColor = (glass + edgeGlow + hoverGlow) * pulse;
            float finalAlpha = glassOpacity + fresnel * 0.3 + hoverIntensity * 0.2;

            gl_FragColor = vec4(finalColor, finalAlpha);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.NormalBlending
      });
    }

    // Track all glass materials for time uniform updates
    const glassMaterials = [];

    function createTriangleMesh(positions, nodeIds) {
      // Validate all positions before creating geometry
      if (!positions.every(isValidPosition)) {
        console.warn('Triangle has invalid positions:', positions);
        return null;
      }

      const geometry = new THREE.BufferGeometry();

      const vertices = new Float32Array([
        positions[0].x, positions[0].y, positions[0].z,
        positions[1].x, positions[1].y, positions[1].z,
        positions[2].x, positions[2].y, positions[2].z
      ]);

      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();

      const material = createGlassMaterial(COLORS.surfaces.derived, {
        opacity: 0.15,
        fresnelPower: 2.0,
        glowIntensity: 0.3
      });
      glassMaterials.push(material);

      return new THREE.Mesh(geometry, material);
    }

    function createTetrahedronMesh(positions, nodeIds) {
      // Validate all positions before creating geometry
      if (!positions.every(isValidPosition)) {
        console.warn('Tetrahedron has invalid positions:', positions);
        return null;
      }

      const geometry = new THREE.BufferGeometry();

      // 4 triangular faces
      const vertices = new Float32Array([
        // Face 0-1-2
        positions[0].x, positions[0].y, positions[0].z,
        positions[1].x, positions[1].y, positions[1].z,
        positions[2].x, positions[2].y, positions[2].z,
        // Face 0-1-3
        positions[0].x, positions[0].y, positions[0].z,
        positions[1].x, positions[1].y, positions[1].z,
        positions[3].x, positions[3].y, positions[3].z,
        // Face 0-2-3
        positions[0].x, positions[0].y, positions[0].z,
        positions[2].x, positions[2].y, positions[2].z,
        positions[3].x, positions[3].y, positions[3].z,
        // Face 1-2-3
        positions[1].x, positions[1].y, positions[1].z,
        positions[2].x, positions[2].y, positions[2].z,
        positions[3].x, positions[3].y, positions[3].z
      ]);

      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();

      const material = createGlassMaterial(COLORS.surfaces.causal, {
        opacity: 0.2,
        fresnelPower: 2.5,
        glowIntensity: 0.4
      });
      glassMaterials.push(material);

      return new THREE.Mesh(geometry, material);
    }

    /**
     * Create mesh for 5+ node cliques using convex hull
     */
    function createHigherCliqueMesh(positions, clique) {
      // Validate all positions before creating geometry (need at least 4 for 3D hull)
      if (positions.length < 4 || !positions.every(isValidPosition)) {
        console.warn('Higher clique has invalid or insufficient positions');
        return null;
      }

      // Use convex hull for 5+ vertices
      const hullData = computeConvexHull3D(positions);

      if (hullData.vertices.length === 0 || hullData.vertices.some(v => isNaN(v))) {
        // Fallback to simple combined geometry
        return createFallbackCliqueMesh(positions, clique.size);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(hullData.vertices, 3));
      if (hullData.indices.length > 0) {
        geometry.setIndex(hullData.indices);
      }
      geometry.computeVertexNormals();

      // Special iridescent material for higher cliques (pink-coral)
      const material = createGlassMaterial(0xff6b9d, {
        opacity: 0.25,
        fresnelPower: 3.0,       // Stronger edge glow for special structures
        glowIntensity: 0.5
      });
      glassMaterials.push(material);

      return new THREE.Mesh(geometry, material);
    }

    function createFallbackCliqueMesh(positions, size) {
      // Validate positions and need at least 2 for any meaningful mesh
      if (positions.length < 2 || !positions.every(isValidPosition)) {
        return null;
      }

      // Create a simple sphere-ish mesh from triangulating around centroid
      const centroid = new THREE.Vector3();
      positions.forEach(p => centroid.add(p));
      centroid.divideScalar(positions.length);

      // Validate centroid
      if (isNaN(centroid.x) || isNaN(centroid.y) || isNaN(centroid.z)) {
        return null;
      }

      const vertices = [];
      const n = positions.length;

      // Create triangles from centroid to each edge
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        vertices.push(
          centroid.x, centroid.y, centroid.z,
          positions[i].x, positions[i].y, positions[i].z,
          positions[j].x, positions[j].y, positions[j].z
        );
      }

      // Validate vertices
      if (vertices.some(v => isNaN(v))) {
        return null;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();

      const material = createGlassMaterial(0xff6b9d, {
        opacity: 0.2,
        fresnelPower: 2.5,
        glowIntensity: 0.35
      });
      glassMaterials.push(material);

      return new THREE.Mesh(geometry, material);
    }

    /**
     * Create flowing ribbon/tube geometry for chains
     * Uses CatmullRomCurve3 for smooth interpolation
     */
    function createChainRibbon(positions, chain) {
      // Validate all positions before creating geometry
      if (!positions.every(isValidPosition)) {
        console.warn('Chain has invalid positions');
        return null;
      }

      // Need at least 2 points for a curve
      if (positions.length < 2) {
        console.warn('Chain needs at least 2 points');
        return null;
      }

      // Create smooth curve through all positions
      const curve = new THREE.CatmullRomCurve3(positions, false, 'centripetal', 0.5);

      // Create tube geometry along the curve
      const tubeRadius = 0.15;
      const tubularSegments = Math.max(32, positions.length * 8);
      const radialSegments = 8;
      const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, radialSegments, false);

      // Determine color from dominant relationship type
      let dominantColor = COLORS.surfaces.derived;
      if (chain.relationshipTypes && chain.relationshipTypes.length > 0) {
        const typeCount = {};
        chain.relationshipTypes.forEach(t => {
          typeCount[t] = (typeCount[t] || 0) + 1;
        });
        const dominantType = Object.keys(typeCount).sort((a, b) => typeCount[b] - typeCount[a])[0];
        dominantColor = getRelationshipColor(dominantType);
      }

      // Create gradient material with flow animation
      const material = createChainMaterial(dominantColor, positions.length);

      const tube = new THREE.Mesh(tubeGeometry, material);
      tube.userData.isChain = true;
      tube.userData.material = material;

      return tube;
    }

    /**
     * Create animated shader material for chain ribbons
     */
    function createChainMaterial(baseColor, chainLength) {
      const color = new THREE.Color(baseColor);

      return new THREE.ShaderMaterial({
        uniforms: {
          baseColor: { value: color },
          glowColor: { value: new THREE.Color(0xffffff) },
          time: { value: 0 },
          flowSpeed: { value: 0.5 },
          pulseWidth: { value: 0.15 },
          opacity: { value: 0.7 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vViewPosition;

          void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 baseColor;
          uniform vec3 glowColor;
          uniform float time;
          uniform float flowSpeed;
          uniform float pulseWidth;
          uniform float opacity;

          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vViewPosition;

          void main() {
            // Flow animation along the tube
            float flow = fract(vUv.x - time * flowSpeed);

            // Create moving pulse effect
            float pulse = smoothstep(0.0, pulseWidth, flow) * smoothstep(pulseWidth * 2.0, pulseWidth, flow);

            // Fresnel effect for edge glow
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 2.0);

            // Combine base color with pulse and fresnel
            vec3 color = baseColor + pulse * glowColor * 0.5 + fresnel * baseColor * 0.3;

            // Vary opacity along tube for ethereal effect
            float alpha = opacity * (0.7 + 0.3 * fresnel + 0.2 * pulse);

            gl_FragColor = vec4(color, alpha);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.NormalBlending
      });
    }

    // ==========================================================================
    // DEMO DATA
    // ==========================================================================

    function createDemoData() {
      console.log('Creating demo data with time distribution for consolidation testing...');

      const demoNodes = [];
      const demoRelationships = [];
      const types = ['experience', 'belief', 'desire', 'capability', 'reflection', 'crystal'];
      const now = Date.now();
      const dayMs = 24 * 60 * 60 * 1000;

      // Create 500 demo nodes (reduced from 2500 for performance)
      // Distribute across time to test temporal consolidation
      const nodeCount = Math.min(500, CONFIG.maxNodes);
      const recentRatio = 0.3; // 30% recent nodes

      for (let i = 0; i < nodeCount; i++) {
        // Time distribution: 30% recent (< 7 days), 70% older
        let timestamp;
        if (i < nodeCount * recentRatio) {
          // Recent nodes (last 7 days)
          timestamp = new Date(now - Math.random() * 7 * dayMs).toISOString();
        } else {
          // Older nodes (7-60 days ago)
          timestamp = new Date(now - (7 + Math.random() * 53) * dayMs).toISOString();
        }

        const type = types[Math.floor(Math.random() * types.length)];
        const contentPrefixes = {
          experience: ['Observed', 'Noticed', 'Witnessed', 'Experienced'],
          belief: ['I believe', 'It seems', 'I think', 'Evidence suggests'],
          desire: ['I want to', 'I wish to', 'I need to', 'I aspire to'],
          capability: ['Can now', 'Learned to', 'Able to', 'Acquired skill:'],
          reflection: ['Reflecting on', 'Considering', 'Pondering', 'Thinking about'],
          crystal: ['Crystallized insight:', 'Unified understanding:', 'Core pattern:', 'Emergent concept:']
        };

        const prefix = contentPrefixes[type][Math.floor(Math.random() * contentPrefixes[type].length)];

        demoNodes.push({
          id: `demo_${i}`,
          type: type,
          content: `${prefix} concept ${i} regarding topic ${Math.floor(i / 50)}`,
          importance: 0.3 + Math.random() * 0.7,
          timestamp: timestamp,
          created_at: timestamp
        });
      }

      // Create relationships with clustering tendency
      // Nodes with similar IDs (nearby in creation) are more likely to connect
      for (let i = 0; i < demoNodes.length; i++) {
        // Connect to 2-4 nodes
        const connections = 2 + Math.floor(Math.random() * 3);
        for (let j = 0; j < connections; j++) {
          // 70% chance to connect to nearby nodes (forms clusters)
          let target;
          if (Math.random() < 0.7) {
            const offset = Math.floor((Math.random() - 0.5) * 100);
            target = Math.max(0, Math.min(demoNodes.length - 1, i + offset));
          } else {
            target = Math.floor(Math.random() * demoNodes.length);
          }

          if (target !== i) {
            demoRelationships.push({
              source: demoNodes[i].id,
              target: demoNodes[target].id,
              type: Math.random() > 0.5 ? 'RELATES_TO' : 'DERIVED_FROM'
            });
          }
        }
      }

      // Add some fully connected cliques to create interesting topology (reduced for performance)
      const cliqueCount = Math.min(5, Math.floor(demoNodes.length / 50));
      for (let c = 0; c < cliqueCount; c++) {
        const cliqueSize = 4 + Math.floor(Math.random() * 2); // 4-5 nodes
        const cliqueStart = Math.floor(Math.random() * (demoNodes.length - cliqueSize));

        for (let i = 0; i < cliqueSize; i++) {
          for (let j = i + 1; j < cliqueSize; j++) {
            demoRelationships.push({
              source: demoNodes[cliqueStart + i].id,
              target: demoNodes[cliqueStart + j].id,
              type: 'SUPPORTS'
            });
          }
        }
      }

      // Add some explicit chain sequences (A‚ÜíB‚ÜíC‚ÜíD‚ÜíE) - reduced for performance
      const chainCount = Math.min(5, Math.floor(demoNodes.length / 50));
      for (let c = 0; c < chainCount; c++) {
        const chainLength = 4 + Math.floor(Math.random() * 3); // 4-6 nodes
        const chainStart = Math.floor(Math.random() * (demoNodes.length - chainLength * 5));

        for (let i = 0; i < chainLength - 1; i++) {
          const sourceIdx = chainStart + i * 5;
          const targetIdx = chainStart + (i + 1) * 5;

          if (sourceIdx < demoNodes.length && targetIdx < demoNodes.length) {
            demoRelationships.push({
              source: demoNodes[sourceIdx].id,
              target: demoNodes[targetIdx].id,
              type: 'DERIVED_FROM'
            });
          }
        }
      }

      // Add some causal chains with different relationship type (reduced for performance)
      const causalChainCount = Math.min(3, Math.floor(demoNodes.length / 100));
      for (let c = 0; c < causalChainCount; c++) {
        const chainLength = 3 + Math.floor(Math.random() * 2); // 3-4 nodes
        const chainStart = Math.floor(Math.random() * (demoNodes.length - chainLength * 5));

        for (let i = 0; i < chainLength - 1; i++) {
          const sourceIdx = chainStart + i * 8;
          const targetIdx = chainStart + (i + 1) * 8;

          if (sourceIdx < demoNodes.length && targetIdx < demoNodes.length) {
            demoRelationships.push({
              source: demoNodes[sourceIdx].id,
              target: demoNodes[targetIdx].id,
              type: 'LEADS_TO'
            });
          }
        }
      }

      console.log(`Created ${demoNodes.length} demo nodes and ${demoRelationships.length} relationships`);

      processGraphData({
        nodes: demoNodes,
        relationships: demoRelationships
      });

      updateStats();
    }

    // ==========================================================================
    // WEBSOCKET
    // ==========================================================================

    function connectWebSocket() {
      try {
        ws = new WebSocket(CONFIG.wsUrl);

        ws.onopen = () => {
          console.log('WebSocket connected');
          document.getElementById('connection-indicator').classList.remove('disconnected');
          updateConsoleConnection(true);
        };

        ws.onclose = () => {
          console.log('WebSocket disconnected');
          document.getElementById('connection-indicator').classList.add('disconnected');
          updateConsoleConnection(false);

          // Reconnect after 5 seconds
          wsReconnectTimeout = setTimeout(connectWebSocket, 5000);
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
          } catch (e) {
            console.error('Failed to parse WebSocket message:', e);
          }
        };

      } catch (error) {
        console.error('Failed to connect WebSocket:', error);
      }
    }

    // Live update state
    const liveUpdateState = {
      enabled: true,
      pendingUpdates: [],
      lastFullRefresh: 0,
      updateThrottleMs: 2000,  // Throttle full refreshes
      incrementalMode: true    // Try incremental updates first
    };

    function handleWebSocketMessage(data) {
      const eventType = data.type;
      const eventData = data.data || {};

      // Update connection indicator
      const indicator = document.getElementById('connection-indicator');
      if (indicator) {
        indicator.classList.remove('disconnected');
        indicator.classList.add('connected');
      }

      // Add event to console
      addConsoleEvent(data);

      // Update BYRD cat state based on events
      if (eventType === 'reflection_complete' || eventType === 'dream_started') {
        setByrdState('dreaming');
      } else if (eventType === 'desire_created' || eventType === 'goal_created') {
        setByrdState('yearning');
      } else if (eventType === 'capability_acquired' || eventType === 'experience_created') {
        setByrdState('seeking');
      } else if (eventType === 'system_idle') {
        setByrdState('idle');
      } else if (eventType === 'rsi_phase') {
        handleRSIPhaseEvent(eventData);
      } else if (eventType === 'quantum_collapse') {
        handleQuantumCollapseEvent(eventData);
      } else if (eventType === 'crystallization_proposed' || eventType === 'crystallization_collapsed') {
        handleCrystallizationEvent(eventType, eventData);
      }

      // Handle relevant events
      switch (eventType) {
        case 'belief_created':
        case 'desire_created':
        case 'experience_created':
        case 'capability_acquired':
        case 'reflection_complete':
        case 'goal_created':
        case 'trajectory_created':
        case 'heuristic_created':
          if (liveUpdateState.enabled) {
            handleNewNodeEvent(eventType, eventData);
          }
          break;

        case 'relationship_created':
          if (liveUpdateState.enabled && (eventData.source || eventData.source_id) && (eventData.target || eventData.target_id)) {
            handleNewRelationshipEvent(eventData);
          }
          break;

        case 'graph_updated':
        case 'memory_changed':
          // Full refresh needed
          throttledRefresh();
          break;

        case 'system_started':
        case 'system_reset':
          // Full reload
          fetchGraphData();
          break;
      }
    }

    /**
     * Handle incremental node addition
     */
    function handleNewNodeEvent(eventType, eventData) {
      const nodeId = eventData.id || eventData.node_id;
      if (!nodeId || graphState.nodes.has(nodeId)) {
        return; // Already exists
      }

      // Map event type to node type
      const typeMap = {
        'belief_created': 'belief',
        'desire_created': 'desire',
        'experience_created': 'experience',
        'capability_acquired': 'capability',
        'reflection_complete': 'reflection',
        'goal_created': 'goal',
        'trajectory_created': 'trajectory',
        'heuristic_created': 'heuristic'
      };

      const nodeType = typeMap[eventType] || 'experience';

      // Create node data
      const newNode = {
        id: nodeId,
        type: nodeType,
        content: eventData.content || eventData.description || `New ${nodeType}`,
        importance: eventData.importance || eventData.intensity || 0.5,
        created_at: eventData.timestamp || new Date().toISOString(),
        relationshipCount: 0
      };

      // Add to graph state
      graphState.nodes.set(nodeId, newNode);

      // Generate position near center with some randomness
      const angle = Math.random() * Math.PI * 2;
      const radius = 10 + Math.random() * 15;
      const position = new THREE.Vector3(
        Math.cos(angle) * radius,
        (Math.random() - 0.5) * 10,
        Math.sin(angle) * radius
      );
      graphState.nodePositions.set(nodeId, position);

      // Create mesh
      const color = getNodeColor(nodeType);
      const size = 0.8 + Math.log10(1 + (newNode.importance || 0.5)) * 0.5;

      let geometry;
      switch(nodeType) {
        case 'belief':
          geometry = new THREE.OctahedronGeometry(size, 0);
          break;
        case 'desire':
          geometry = new THREE.TetrahedronGeometry(size, 0);
          break;
        case 'goal':
          geometry = new THREE.DodecahedronGeometry(size * 0.8, 0);
          break;
        case 'crystal':
          geometry = new THREE.IcosahedronGeometry(size, 0);
          break;
        case 'capability':
          geometry = new THREE.BoxGeometry(size * 1.2, size * 1.2, size * 1.2);
          break;
        case 'reflection':
          geometry = new THREE.TorusKnotGeometry(size * 0.5, size * 0.15, 64, 8, 2, 3);
          break;
        case 'trajectory':
          geometry = new THREE.CylinderGeometry(size * 0.5, size * 0.5, size * 1.5, 6);
          break;
        case 'heuristic':
          geometry = new THREE.IcosahedronGeometry(size * 0.9, 0);
          break;
        default:
          geometry = new THREE.SphereGeometry(size, 16, 16);
      }

      const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.1,
        transparent: false,
        roughness: 0.4,
        metalness: 0.2
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.userData = { nodeId: nodeId, nodeData: newNode };

      scene.add(mesh);
      graphState.nodeMeshes.set(nodeId, mesh);

      // Animate appearance with pulse
      queuePulseAnimation(mesh, 0.85);

      // Update stats
      graphState.stats.visibleNodes++;
      updateStats();

      // Show notification
      showLiveUpdateNotification(`New ${nodeType}: ${truncate(newNode.content, 30)}`);

      console.log(`Live update: Added ${nodeType} node ${nodeId}`);
    }

    /**
     * Handle incremental relationship addition
     */
    function handleNewRelationshipEvent(eventData) {
      // Normalize source/target field names
      const source = eventData.source || eventData.source_id;
      const target = eventData.target || eventData.target_id;
      const relType = eventData.type || 'RELATES_TO';

      // Check if both nodes exist
      if (!graphState.nodePositions.has(source) || !graphState.nodePositions.has(target)) {
        // Queue for later or do a refresh
        throttledRefresh();
        return;
      }

      // Update relationshipCount for both nodes
      const sourceNode = graphState.nodes.get(source);
      const targetNode = graphState.nodes.get(target);
      if (sourceNode) sourceNode.relationshipCount = (sourceNode.relationshipCount || 0) + 1;
      if (targetNode) targetNode.relationshipCount = (targetNode.relationshipCount || 0) + 1;

      // Create edge line
      const sourcePos = graphState.nodePositions.get(source);
      const targetPos = graphState.nodePositions.get(target);

      // Validate positions have valid values (not just that they exist)
      if (!isValidPosition(sourcePos) || !isValidPosition(targetPos)) {
        console.warn('Invalid positions for new relationship edge');
        throttledRefresh();
        return;
      }

      const points = [sourcePos, targetPos];
      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const lineMaterial = new THREE.LineBasicMaterial({
        color: getRelationshipColor(relType),
        transparent: true,
        opacity: 0
      });

      const line = new THREE.Line(lineGeometry, lineMaterial);
      line.userData = { relationship: { source, target, type: relType } };

      scene.add(line);
      graphState.edgeLines.push(line);

      // Animate fade-in
      const fadeIn = { opacity: 0 };
      const targetOpacity = 0.7;  // Higher opacity for white background
      const startTime = performance.now();
      const duration = 500;

      function animateLine() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        lineMaterial.opacity = targetOpacity * progress;

        if (progress < 1) {
          requestAnimationFrame(animateLine);
        }
      }
      animateLine();

      // Trigger topology recomputation after a delay
      clearTimeout(liveUpdateState.topologyTimeout);
      liveUpdateState.topologyTimeout = setTimeout(() => {
        recomputeTopologyForNewRelationship(source, target);
      }, 1000);

      graphState.stats.relationshipCount++;
      updateStats();
    }

    /**
     * Check if a new relationship creates any topology structures
     */
    function recomputeTopologyForNewRelationship(source, target) {
      // Check for new triangles involving this edge
      const sourceNeighbors = new Set();
      const targetNeighbors = new Set();

      graphState.relationships.forEach(rel => {
        if (rel.source === source) sourceNeighbors.add(rel.target);
        if (rel.target === source) sourceNeighbors.add(rel.source);
        if (rel.source === target) targetNeighbors.add(rel.target);
        if (rel.target === target) targetNeighbors.add(rel.source);
      });

      // Find common neighbors (potential triangles)
      const commonNeighbors = [...sourceNeighbors].filter(n => targetNeighbors.has(n));

      if (commonNeighbors.length > 0) {
        console.log(`New relationship may form ${commonNeighbors.length} triangle(s)`);
        // For simplicity, do a full refresh to get proper topology
        throttledRefresh();
      }
    }

    /**
     * Throttled full graph refresh
     */
    function throttledRefresh() {
      const now = Date.now();
      if (now - liveUpdateState.lastFullRefresh > liveUpdateState.updateThrottleMs) {
        liveUpdateState.lastFullRefresh = now;
        fetchGraphData();
      }
    }

    /**
     * Show a brief notification for live updates
     */
    function showLiveUpdateNotification(message) {
      let notification = document.getElementById('live-update-notification');

      if (!notification) {
        notification = document.createElement('div');
        notification.id = 'live-update-notification';
        notification.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(34, 211, 238, 0.9);
          color: #0f1419;
          padding: 8px 16px;
          border-radius: 20px;
          font-size: 12px;
          font-weight: 500;
          z-index: 200;
          opacity: 0;
          transition: opacity 0.3s ease;
          pointer-events: none;
        `;
        document.body.appendChild(notification);
      }

      notification.textContent = message;
      notification.style.opacity = '1';

      clearTimeout(notification.hideTimeout);
      notification.hideTimeout = setTimeout(() => {
        notification.style.opacity = '0';
      }, 3000);
    }

    /**
     * Toggle live updates
     */
    window.toggleLiveUpdates = function() {
      liveUpdateState.enabled = !liveUpdateState.enabled;
      const statusText = liveUpdateState.enabled ? 'enabled' : 'disabled';
      showLiveUpdateNotification(`Live updates ${statusText}`);
      console.log(`Live updates ${statusText}`);
    };

    // ==========================================================================
    // STATS UPDATE
    // ==========================================================================

    function updateStats() {
      document.getElementById('stat-nodes').textContent = graphState.stats.visibleNodes;
      document.getElementById('stat-triangles').textContent = graphState.stats.triangleCount;
      document.getElementById('stat-tetrahedra').textContent = graphState.stats.tetrahedronCount;
      document.getElementById('stat-higher-cliques').textContent = graphState.stats.higherCliqueCount;
      document.getElementById('stat-chains').textContent = graphState.stats.chainCount;
      document.getElementById('stat-clusters').textContent = graphState.stats.clusterCount;
      document.getElementById('stat-relationships').textContent = graphState.stats.relationshipCount;

      // Consolidation panel
      document.getElementById('visible-count').textContent = graphState.stats.visibleNodes;
      document.getElementById('total-count').textContent = graphState.stats.totalNodes;
      document.getElementById('consolidation-level').textContent = graphState.stats.consolidationLevel;

      const percent = graphState.stats.totalNodes > 0
        ? (graphState.stats.visibleNodes / CONFIG.maxNodes) * 100
        : 0;
      document.getElementById('consolidation-fill').style.width = `${Math.min(100, percent)}%`;
    }

    // ==========================================================================
    // UTILITY FUNCTIONS
    // ==========================================================================

    function truncate(str, length) {
      if (!str) return '';
      return str.length > length ? str.substring(0, length) + '...' : str;
    }

    // ==========================================================================
    // ANIMATION LOOP
    // ==========================================================================

    // One-time cleanup flag
    let sceneCleanedUp = false;

    function cleanupInvalidGeometries() {
      if (sceneCleanedUp) return;
      sceneCleanedUp = true;

      let removed = 0;

      // Helper to check if geometry has NaN - check position attribute directly
      function hasNaNGeometry(obj) {
        if (!obj.geometry) return false;

        // Check position attribute for NaN values
        const posAttr = obj.geometry.attributes?.position;
        if (posAttr) {
          const arr = posAttr.array;
          for (let i = 0; i < Math.min(arr.length, 30); i++) {  // Check first 30 values
            if (isNaN(arr[i])) return true;
          }
        }

        // Also check if bounding sphere is already computed and has NaN
        if (obj.geometry.boundingSphere && isNaN(obj.geometry.boundingSphere.radius)) {
          return true;
        }

        return false;
      }

      // Check edge lines
      graphState.edgeLines = graphState.edgeLines.filter(line => {
        if (hasNaNGeometry(line)) {
          scene.remove(line);
          removed++;
          return false;
        }
        return true;
      });

      // Check surface meshes
      graphState.surfaceMeshes = graphState.surfaceMeshes.filter(mesh => {
        if (hasNaNGeometry(mesh)) {
          scene.remove(mesh);
          removed++;
          return false;
        }
        return true;
      });

      // Check chain meshes
      graphState.chainMeshes = graphState.chainMeshes.filter(mesh => {
        if (hasNaNGeometry(mesh)) {
          scene.remove(mesh);
          removed++;
          return false;
        }
        return true;
      });

      if (removed > 0) {
        console.log(`Cleanup: removed ${removed} objects with invalid geometry`);
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      // One-time cleanup of invalid geometries
      cleanupInvalidGeometries();

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update performance metrics
      updatePerformanceMetrics();

      // Update controls
      controls.update();

      // Run physics simulation step (force-directed clustering)
      physicsStep();

      // Animate BYRD cat
      animateCatIdle(time);
      animateCatEyes(time);

      // Subtle node animation
      graphState.nodeMeshes.forEach((mesh, id) => {
        if (!mesh.visible) return; // Skip invisible nodes

        // Skip meshes with invalid positions
        if (isNaN(mesh.position.x) || isNaN(mesh.position.y) || isNaN(mesh.position.z)) {
          mesh.visible = false;  // Hide invalid meshes
          return;
        }

        mesh.rotation.y += delta * 0.1;

        // Gentle floating
        const offset = mesh.userData.nodeId?.charCodeAt(0) || 0;
        mesh.position.y += Math.sin(time * 0.5 + offset * 0.1) * 0.002;
      });

      // Update chain flow animation
      graphState.chainMeshes.forEach(chainMesh => {
        if (chainMesh.userData.material && chainMesh.userData.material.uniforms) {
          chainMesh.userData.material.uniforms.time.value = time;
        }
      });

      // Update glass material time uniforms for fresnel pulse effect
      glassMaterials.forEach(material => {
        if (material.uniforms && material.uniforms.time) {
          material.uniforms.time.value = time;
        }
      });

      // Animate particle dust
      if (particleSystem) {
        updateParticleDust(delta);
      }

      // Process pulse animations for new structures
      updatePulseAnimations(time, delta);

      // Animate surface breathing (subtle opacity variation)
      // Note: Glass shader materials handle breathing via the time uniform,
      // so we only need to animate standard materials here
      graphState.surfaceMeshes.forEach(mesh => {
        if (!mesh.visible) return; // Skip invisible surfaces

        // Check for NaN geometry and hide invalid meshes
        if (mesh.geometry && mesh.geometry.boundingSphere === null) {
          try {
            mesh.geometry.computeBoundingSphere();
          } catch (e) {
            mesh.visible = false;
            return;
          }
        }
        if (mesh.geometry?.boundingSphere?.radius && isNaN(mesh.geometry.boundingSphere.radius)) {
          mesh.visible = false;
          return;
        }

        if (mesh.material && mesh.userData.baseOpacity !== undefined) {
          const breathe = 0.9 + 0.1 * Math.sin(time * 0.8 + (mesh.id || 0) * 0.1);

          // Handle glass shader materials - adjust glassOpacity uniform
          if (mesh.material.uniforms && mesh.material.uniforms.glassOpacity) {
            mesh.material.uniforms.glassOpacity.value = mesh.userData.baseOpacity * breathe;
          }
          // Handle standard materials
          else if (mesh.material.opacity !== undefined) {
            mesh.material.opacity = mesh.userData.baseOpacity * breathe;
          }
        }
      });

      // Update LOD based on camera distance
      updateLOD();

      // Perform frustum culling (only in close LOD where there are many objects)
      if (currentLODLevel === 'close' && graphState.nodeMeshes.size > 100) {
        performFrustumCulling();
      }

      // Measure render time
      const renderStart = performance.now();

      // Render with post-processing
      composer.render();

      performanceStats.renderTime = performance.now() - renderStart;

      // Update performance panel (throttled to avoid DOM thrashing)
      if (performanceStats.enabled && Math.floor(time * 4) !== Math.floor((time - delta) * 4)) {
        updatePerformancePanel();
      }
    }

    // ==========================================================================
    // PERFORMANCE PROFILING
    // ==========================================================================

    const performanceStats = {
      fps: 0,
      frameTime: 0,
      renderTime: 0,
      updateTime: 0,
      triangleCount: 0,
      drawCalls: 0,
      geometryMemory: 0,
      textureMemory: 0,
      lastFrameTime: performance.now(),
      frameTimes: [],
      maxFrameSamples: 60,
      culledObjects: 0,
      visibleObjects: 0,
      enabled: false
    };

    // Create performance panel
    function createPerformancePanel() {
      const panel = document.createElement('div');
      panel.id = 'performance-panel';
      panel.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(100, 116, 139, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        color: #334155;
        z-index: 150;
        min-width: 180px;
        display: none;
        backdrop-filter: blur(10px);
      `;

      panel.innerHTML = `
        <div style="color: #22d3ee; font-weight: 600; margin-bottom: 8px; font-size: 12px;">
          ‚ö° PERFORMANCE
        </div>
        <div style="display: grid; gap: 4px;">
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #71767b;">FPS:</span>
            <span id="perf-fps" style="color: #22d3ee;">--</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #71767b;">Frame:</span>
            <span id="perf-frame-time" style="color: #e7e9ea;">--</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #71767b;">Render:</span>
            <span id="perf-render-time" style="color: #e7e9ea;">--</span>
          </div>
          <div style="border-top: 1px solid rgba(113, 118, 123, 0.3); margin: 6px 0; padding-top: 6px;">
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #71767b;">Draw calls:</span>
              <span id="perf-draw-calls" style="color: #e7e9ea;">--</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #71767b;">Triangles:</span>
              <span id="perf-triangles" style="color: #e7e9ea;">--</span>
            </div>
          </div>
          <div style="border-top: 1px solid rgba(113, 118, 123, 0.3); margin: 6px 0; padding-top: 6px;">
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #71767b;">Visible:</span>
              <span id="perf-visible" style="color: #10b981;">--</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #71767b;">Culled:</span>
              <span id="perf-culled" style="color: #f59e0b;">--</span>
            </div>
          </div>
          <div style="border-top: 1px solid rgba(113, 118, 123, 0.3); margin: 6px 0; padding-top: 6px;">
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #71767b;">Memory:</span>
              <span id="perf-memory" style="color: #e7e9ea;">--</span>
            </div>
          </div>
        </div>
        <div style="margin-top: 8px; font-size: 10px; color: #71767b;">
          Press 'P' to toggle
        </div>
      `;

      document.body.appendChild(panel);
      return panel;
    }

    // Calculate FPS and frame times
    function updatePerformanceMetrics() {
      const now = performance.now();
      const frameTime = now - performanceStats.lastFrameTime;
      performanceStats.lastFrameTime = now;

      // Track frame times for averaging
      performanceStats.frameTimes.push(frameTime);
      if (performanceStats.frameTimes.length > performanceStats.maxFrameSamples) {
        performanceStats.frameTimes.shift();
      }

      // Calculate average FPS
      const avgFrameTime = performanceStats.frameTimes.reduce((a, b) => a + b, 0) /
                           performanceStats.frameTimes.length;
      performanceStats.fps = Math.round(1000 / avgFrameTime);
      performanceStats.frameTime = avgFrameTime.toFixed(2);

      // Get renderer info
      const info = renderer.info;
      performanceStats.drawCalls = info.render.calls;
      performanceStats.triangleCount = info.render.triangles;
      performanceStats.geometryMemory = info.memory.geometries;
      performanceStats.textureMemory = info.memory.textures;
    }

    // Update performance panel display
    function updatePerformancePanel() {
      if (!performanceStats.enabled) return;

      const fpsEl = document.getElementById('perf-fps');
      const frameEl = document.getElementById('perf-frame-time');
      const renderEl = document.getElementById('perf-render-time');
      const drawCallsEl = document.getElementById('perf-draw-calls');
      const trianglesEl = document.getElementById('perf-triangles');
      const visibleEl = document.getElementById('perf-visible');
      const culledEl = document.getElementById('perf-culled');
      const memoryEl = document.getElementById('perf-memory');

      if (fpsEl) {
        // Color code FPS
        const fps = performanceStats.fps;
        let fpsColor = '#10b981'; // green
        if (fps < 30) fpsColor = '#ef4444'; // red
        else if (fps < 50) fpsColor = '#f59e0b'; // yellow

        fpsEl.style.color = fpsColor;
        fpsEl.textContent = `${fps}`;
      }
      if (frameEl) frameEl.textContent = `${performanceStats.frameTime}ms`;
      if (renderEl) renderEl.textContent = `${performanceStats.renderTime.toFixed(2)}ms`;
      if (drawCallsEl) drawCallsEl.textContent = performanceStats.drawCalls;
      if (trianglesEl) trianglesEl.textContent = formatNumber(performanceStats.triangleCount);
      if (visibleEl) visibleEl.textContent = performanceStats.visibleObjects;
      if (culledEl) culledEl.textContent = performanceStats.culledObjects;
      if (memoryEl) {
        const totalMem = performanceStats.geometryMemory + performanceStats.textureMemory;
        memoryEl.textContent = `${totalMem} obj`;
      }
    }

    function formatNumber(num) {
      if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
      return num.toString();
    }

    // Toggle performance panel
    window.togglePerformancePanel = function() {
      performanceStats.enabled = !performanceStats.enabled;
      const panel = document.getElementById('performance-panel');
      if (panel) {
        panel.style.display = performanceStats.enabled ? 'block' : 'none';
      }
      console.log(`Performance panel ${performanceStats.enabled ? 'enabled' : 'disabled'}`);
    };

    // ==========================================================================
    // FRUSTUM CULLING
    // ==========================================================================

    const frustum = new THREE.Frustum();
    const frustumMatrix = new THREE.Matrix4();

    /**
     * Perform frustum culling to hide objects outside camera view
     * This reduces draw calls for large graphs
     */
    function performFrustumCulling() {
      // Update frustum from camera
      frustumMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(frustumMatrix);

      let visible = 0;
      let culled = 0;

      // Cull node meshes
      graphState.nodeMeshes.forEach(mesh => {
        if (!mesh.userData.lodVisible) {
          // Already hidden by LOD, skip frustum check
          return;
        }

        const inFrustum = frustum.containsPoint(mesh.position);
        if (mesh.visible !== inFrustum) {
          mesh.visible = inFrustum;
        }

        if (inFrustum) visible++;
        else culled++;
      });

      // Cull surface meshes (topology)
      graphState.surfaceMeshes.forEach(mesh => {
        if (!mesh.userData.lodVisible) return;

        // Use bounding sphere for more accurate frustum test
        if (mesh.geometry.boundingSphere === null) {
          mesh.geometry.computeBoundingSphere();
        }

        const sphere = mesh.geometry.boundingSphere;
        const center = sphere.center.clone().applyMatrix4(mesh.matrixWorld);
        const inFrustum = frustum.containsPoint(center) ||
                          frustum.intersectsSphere(new THREE.Sphere(center, sphere.radius));

        if (mesh.visible !== inFrustum) {
          mesh.visible = inFrustum;
        }

        if (inFrustum) visible++;
        else culled++;
      });

      // Cull edge lines
      graphState.edgeLines.forEach(line => {
        if (!line.userData.lodVisible) return;

        // Simple check: is either endpoint in frustum?
        const positions = line.geometry.attributes.position.array;
        const start = new THREE.Vector3(positions[0], positions[1], positions[2]);
        const end = new THREE.Vector3(positions[3], positions[4], positions[5]);

        const inFrustum = frustum.containsPoint(start) || frustum.containsPoint(end);
        if (line.visible !== inFrustum) {
          line.visible = inFrustum;
        }

        if (inFrustum) visible++;
        else culled++;
      });

      performanceStats.visibleObjects = visible;
      performanceStats.culledObjects = culled;
    }

    // ==========================================================================
    // LEVEL OF DETAIL (LOD)
    // ==========================================================================

    // LOD state tracking
    let currentLODLevel = 'close'; // 'far', 'medium', 'close'
    const LOD_THRESHOLDS = {
      far: 800,      // > 800 units: show only clusters and major structures
      medium: 400    // > 400 units: show clusters with outline
                     // <= 400: show full detail
    };

    function updateLOD() {
      const cameraDistance = camera.position.length();
      let newLevel;

      if (cameraDistance > LOD_THRESHOLDS.far) {
        newLevel = 'far';
      } else if (cameraDistance > LOD_THRESHOLDS.medium) {
        newLevel = 'medium';
      } else {
        newLevel = 'close';
      }

      // Only update if level changed
      if (newLevel !== currentLODLevel) {
        currentLODLevel = newLevel;
        applyLODLevel(newLevel);
      }
    }

    function applyLODLevel(level) {
      console.log('Applying LOD level:', level);

      switch (level) {
        case 'far':
          // Far view: show only meta-node hulls and hide individual nodes/surfaces
          graphState.nodeMeshes.forEach(mesh => {
            // Keep expanded constituent nodes visible if their cluster is expanded
            if (mesh.userData.isExpandedConstituent) {
              const shouldShow = graphState.expandedMetaNodes.has(mesh.userData.parentMetaNodeId);
              mesh.visible = shouldShow;
              mesh.userData.lodVisible = shouldShow;
            } else {
              mesh.visible = false;
              mesh.userData.lodVisible = false;
            }
          });
          graphState.surfaceMeshes.forEach(mesh => {
            mesh.visible = false;
            mesh.userData.lodVisible = false;
          });
          graphState.edgeLines.forEach(line => {
            line.visible = false;
            line.userData.lodVisible = false;
          });
          graphState.chainMeshes.forEach(chain => {
            chain.visible = false;
          });
          graphState.clusterHulls.forEach(hull => {
            hull.visible = !graphState.expandedMetaNodes.has(hull.userData.metaNodeId);
          });
          break;

        case 'medium':
          // Medium view: show clusters and major topology structures
          graphState.nodeMeshes.forEach(mesh => {
            if (mesh.userData.isExpandedConstituent) {
              const shouldShow = graphState.expandedMetaNodes.has(mesh.userData.parentMetaNodeId);
              mesh.visible = shouldShow;
              mesh.userData.lodVisible = shouldShow;
            } else {
              // Show only high-importance nodes
              const importance = mesh.userData.nodeData?.importance || 0.5;
              const shouldShow = importance > 0.6;
              mesh.visible = shouldShow;
              mesh.userData.lodVisible = shouldShow;
            }
          });
          graphState.surfaceMeshes.forEach(mesh => {
            // Show only larger structures (tetrahedra and higher cliques)
            const nodeCount = mesh.userData.nodeIds?.length || 0;
            const shouldShow = nodeCount >= 4;
            mesh.visible = shouldShow;
            mesh.userData.lodVisible = shouldShow;
          });
          graphState.edgeLines.forEach(line => {
            line.visible = false;
            line.userData.lodVisible = false;
          });
          graphState.chainMeshes.forEach(chain => {
            chain.visible = true;
          });
          graphState.clusterHulls.forEach(hull => {
            hull.visible = !graphState.expandedMetaNodes.has(hull.userData.metaNodeId);
          });
          break;

        case 'close':
        default:
          // Close view: show everything (frustum culling will handle visibility)
          graphState.nodeMeshes.forEach(mesh => {
            if (mesh.userData.isExpandedConstituent) {
              const shouldShow = graphState.expandedMetaNodes.has(mesh.userData.parentMetaNodeId);
              mesh.visible = shouldShow;
              mesh.userData.lodVisible = shouldShow;
            } else {
              mesh.visible = true;
              mesh.userData.lodVisible = true;
            }
          });
          graphState.surfaceMeshes.forEach(mesh => {
            mesh.visible = true;
            mesh.userData.lodVisible = true;
          });
          graphState.edgeLines.forEach(line => {
            line.visible = true;
            line.userData.lodVisible = true;
          });
          graphState.chainMeshes.forEach(chain => {
            chain.visible = true;
          });
          graphState.clusterHulls.forEach(hull => {
            hull.visible = !graphState.expandedMetaNodes.has(hull.userData.metaNodeId);
          });
          break;
      }
    }

    function updateParticleDust(delta) {
      const positions = particleSystem.geometry.attributes.position.array;
      const velocities = particleSystem.userData.velocities;
      const bounds = 75;

      for (let i = 0; i < positions.length; i += 3) {
        // Update positions based on velocities
        positions[i] += velocities[i] * delta * 60;
        positions[i + 1] += velocities[i + 1] * delta * 60;
        positions[i + 2] += velocities[i + 2] * delta * 60;

        // Wrap around bounds
        if (positions[i] > bounds) positions[i] = -bounds;
        if (positions[i] < -bounds) positions[i] = bounds;
        if (positions[i + 1] > 50) positions[i + 1] = -50;
        if (positions[i + 1] < -50) positions[i + 1] = 50;
        if (positions[i + 2] > bounds) positions[i + 2] = -bounds;
        if (positions[i + 2] < -bounds) positions[i + 2] = bounds;
      }

      particleSystem.geometry.attributes.position.needsUpdate = true;
    }

    function updatePulseAnimations(time, delta) {
      // Process structures with active pulse animation
      const finishedAnimations = [];

      animationState.newStructures.forEach((anim, index) => {
        anim.progress += delta * 2; // Animation speed

        if (anim.progress >= 1) {
          // Animation complete - reset to normal
          if (anim.mesh && anim.mesh.material) {
            // Handle glass shader materials
            if (anim.mesh.material.uniforms && anim.mesh.material.uniforms.glassOpacity) {
              anim.mesh.material.uniforms.glassOpacity.value = anim.targetOpacity;
              anim.mesh.material.uniforms.hoverIntensity.value = 0;
            }
            // Handle standard materials
            else {
              anim.mesh.material.opacity = anim.targetOpacity;
            }
            anim.mesh.scale.set(1, 1, 1);
          }
          finishedAnimations.push(index);
        } else {
          // Animate scale and glow
          const t = anim.progress;
          const easeOut = 1 - Math.pow(1 - t, 3);
          const pulse = Math.sin(t * Math.PI * 3) * (1 - t);

          if (anim.mesh) {
            const scale = 0.5 + easeOut * 0.5 + pulse * 0.2;
            anim.mesh.scale.set(scale, scale, scale);

            if (anim.mesh.material) {
              const animatedOpacity = anim.targetOpacity * (0.5 + easeOut * 0.5) + pulse * 0.3;

              // Handle glass shader materials
              if (anim.mesh.material.uniforms && anim.mesh.material.uniforms.glassOpacity) {
                anim.mesh.material.uniforms.glassOpacity.value = animatedOpacity;
                anim.mesh.material.uniforms.glowIntensity.value = 0.3 + pulse * 0.5;
                anim.mesh.material.uniforms.hoverIntensity.value = pulse * 0.8;
              }
              // Handle standard materials
              else {
                anim.mesh.material.opacity = animatedOpacity;
                if (anim.mesh.material.emissiveIntensity !== undefined) {
                  anim.mesh.material.emissiveIntensity = 0.1 + pulse * 0.4;
                }
              }
            }
          }
        }
      });

      // Remove finished animations (in reverse order)
      finishedAnimations.sort((a, b) => b - a);
      finishedAnimations.forEach(index => {
        animationState.newStructures.splice(index, 1);
      });
    }

    /**
     * Queue a structure for pulse animation when it appears
     */
    function queuePulseAnimation(mesh, targetOpacity) {
      if (!mesh) return;

      mesh.scale.set(0.1, 0.1, 0.1);
      if (mesh.material) {
        // Handle glass shader materials
        if (mesh.material.uniforms && mesh.material.uniforms.glassOpacity) {
          mesh.material.uniforms.glassOpacity.value = 0;
        }
        // Handle standard materials
        else {
          mesh.material.opacity = 0;
        }
      }

      animationState.newStructures.push({
        mesh: mesh,
        progress: 0,
        targetOpacity: targetOpacity || 0.15
      });
    }

    // ==========================================================================
    // NAVIGATION BAR FUNCTIONS
    // ==========================================================================

    const API_BASE = window.location.origin;

    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), duration);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ==========================================================================
    // MESSAGES PANEL - Chat History with BYRD
    // ==========================================================================
    let messagesLoaded = false;
    let messagesPanelExpanded = false;
    let unreadMessageCount = 0;
    let messagesAutoScroll = true;  // Smart scroll for messages panel

    function toggleMessagesPanel() {
      const panel = document.getElementById('messages-panel');
      const icon = document.getElementById('toggle-icon');
      messagesPanelExpanded = !messagesPanelExpanded;

      if (messagesPanelExpanded) {
        panel.classList.remove('collapsed');
        icon.innerHTML = '<polyline points="6 9 12 15 18 9"></polyline>';
        // Load messages if not already loaded
        if (!messagesLoaded) {
          loadMessages();
        }
        // Clear unread count
        unreadMessageCount = 0;
        updateUnreadBadge();
      } else {
        panel.classList.add('collapsed');
        icon.innerHTML = '<polyline points="18 15 12 9 6 15"></polyline>';
      }
    }

    function updateUnreadBadge() {
      const badge = document.getElementById('unread-badge');
      if (unreadMessageCount > 0) {
        badge.textContent = unreadMessageCount > 99 ? '99+' : unreadMessageCount;
        badge.style.display = 'inline-block';
      } else {
        badge.style.display = 'none';
      }
    }

    async function loadMessages() {
      const messagesList = document.getElementById('messages-list');
      messagesList.innerHTML = '<div class="messages-loading">Loading messages...</div>';

      try {
        const response = await fetch(`${API_BASE}/api/messages?limit=50`);
        if (!response.ok) throw new Error('Failed to fetch messages');

        const data = await response.json();
        messagesLoaded = true;

        if (data.messages && data.messages.length > 0) {
          // Sort by timestamp (oldest first for chat view)
          const sortedMessages = [...data.messages].sort((a, b) =>
            new Date(a.created_at) - new Date(b.created_at)
          );

          messagesList.innerHTML = sortedMessages.map(msg => renderMessage(msg)).join('');

          // Scroll to bottom
          messagesList.scrollTop = messagesList.scrollHeight;
        } else {
          messagesList.innerHTML = `
            <div class="messages-empty">
              <div class="messages-empty-icon">üí¨</div>
              <div>No messages yet</div>
              <div style="font-size: 11px; margin-top: 4px;">Send a message to start a conversation with BYRD</div>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        messagesList.innerHTML = `
          <div class="messages-empty">
            <div class="messages-empty-icon">‚ö†Ô∏è</div>
            <div>Failed to load messages</div>
            <div style="font-size: 11px; margin-top: 4px;">${error.message}</div>
          </div>
        `;
      }
    }

    function renderMessage(msg) {
      // Messages from /api/messages are all from BYRD unless marked as from_human
      const isFromByrd = msg.from_byrd !== false;
      const messageClass = isFromByrd ? 'byrd' : 'human';
      const timestamp = formatMessageTime(msg.created_at);
      const emotionText = msg.emotion || msg.emotional_tone;
      const emotion = emotionText ? `<span class="message-emotion">${emotionText}</span>` : '';
      const messageText = msg.text || msg.content || '';

      return `
        <div class="message-item ${messageClass}">
          <div class="message-bubble">${escapeHtml(messageText)}</div>
          <div class="message-meta">${timestamp}${emotion}</div>
        </div>
      `;
    }

    function formatMessageTime(isoString) {
      try {
        const date = new Date(isoString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;

        return date.toLocaleDateString();
      } catch (e) {
        return '';
      }
    }

    function handleMessageKeypress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }

    async function sendMessage() {
      const input = document.getElementById('message-input');
      const content = input.value.trim();

      if (!content) return;

      // Clear input immediately for better UX
      input.value = '';

      // Add message to UI immediately (optimistic update)
      const messagesList = document.getElementById('messages-list');
      const tempMessage = {
        content: content,
        direction: 'observer_to_byrd',
        created_at: new Date().toISOString(),
        from_byrd: false
      };

      // Remove empty state if present
      const emptyState = messagesList.querySelector('.messages-empty');
      if (emptyState) emptyState.remove();

      messagesList.insertAdjacentHTML('beforeend', renderMessage(tempMessage));
      messagesList.scrollTop = messagesList.scrollHeight;
      messagesAutoScroll = true;  // Re-enable auto-scroll when user sends a message

      try {
        const response = await fetch(`${API_BASE}/api/experience/message`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: content })
        });

        if (!response.ok) {
          throw new Error('Failed to send message');
        }

        // Message sent successfully - BYRD will respond via WebSocket
      } catch (error) {
        console.error('Error sending message:', error);
        showToast('Failed to send message', 'error');
      }
    }

    function addMessageToPanel(messageData) {
      if (!messagesLoaded) return;

      const messagesList = document.getElementById('messages-list');
      const emptyState = messagesList.querySelector('.messages-empty');
      if (emptyState) emptyState.remove();

      const msg = {
        content: messageData.content || messageData.message,
        direction: 'byrd_to_observer',
        created_at: new Date().toISOString(),
        from_byrd: true,
        emotional_tone: messageData.emotional_tone
      };

      messagesList.insertAdjacentHTML('beforeend', renderMessage(msg));

      // Only auto-scroll if user is at bottom
      if (messagesAutoScroll) {
        messagesList.scrollTop = messagesList.scrollHeight;
      }

      // Update unread count if panel is collapsed
      if (!messagesPanelExpanded) {
        unreadMessageCount++;
        updateUnreadBadge();
      }
    }

    // Initialize messages panel event listeners when DOM is ready
    function initMessagesPanel() {
      const header = document.getElementById('messages-panel-header');
      const sendBtn = document.getElementById('messages-send-btn');
      const input = document.getElementById('message-input');
      const messagesList = document.getElementById('messages-list');

      if (header) {
        header.addEventListener('click', toggleMessagesPanel);
      }
      if (sendBtn) {
        sendBtn.addEventListener('click', sendMessage);
      }
      if (input) {
        input.addEventListener('keypress', handleMessageKeypress);
      }

      // Smart auto-scroll: disable when user scrolls up, re-enable when at bottom
      if (messagesList) {
        messagesList.addEventListener('scroll', () => {
          const isAtBottom = messagesList.scrollHeight - messagesList.scrollTop - messagesList.clientHeight < 20;
          messagesAutoScroll = isAtBottom;
        });
      }
    }

    // Run when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMessagesPanel);
    } else {
      initMessagesPanel();
    }

    async function refreshGraph() {
      showToast('Refreshing graph data...');
      await fetchGraphData();
      showToast('Graph refreshed!');
    }

    async function showStatusModal() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();
        const info = `
BYRD Status
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Experiences: ${data.counts?.experiences || 0}
Beliefs: ${data.counts?.beliefs || 0}
Desires: ${data.counts?.desires || 0}
Goals: ${data.counts?.goals || 0}
Capabilities: ${data.counts?.capabilities || 0}
Reflections: ${data.counts?.reflections || 0}

Dreamer: ${data.dreamer?.dream_count || 0} cycles
Seeker: ${data.seeker?.seek_count || 0} cycles
        `.trim();
        alert(info);
      } catch (e) {
        showToast('Failed to fetch status');
      }
    }

    async function showGenesisModal() {
      try {
        const res = await fetch(`${API_BASE}/api/genesis`);
        const data = await res.json();
        const stats = data.genesis_stats || {};
        const info = `
Genesis Window
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Total Genesis Nodes: ${stats.total_genesis_nodes || 0}
Emergence Ratio: ${((stats.emergence_ratio || 0) * 100).toFixed(1)}%

Constitutional Files:
${(data.constitutional || []).join(', ')}
        `.trim();
        alert(info);
      } catch (e) {
        showToast('Failed to fetch genesis data');
      }
    }

    async function showMessageModal() {
      const message = prompt('Send a message to BYRD:');
      if (!message) return;

      try {
        showToast('Sending message...');
        const res = await fetch(`${API_BASE}/api/message`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: message, source: 'topology_viewer' })
        });
        if (res.ok) {
          showToast('Message sent to BYRD!');
        } else {
          showToast('Failed to send message');
        }
      } catch (e) {
        showToast('Failed to send message');
      }
    }

    async function speakToMe() {
      try {
        showToast('Asking BYRD to speak...');
        const res = await fetch(`${API_BASE}/api/speak`, { method: 'POST' });
        const data = await res.json();
        if (data.audio_url) {
          const audio = new Audio(data.audio_url);
          audio.play();
          showToast('BYRD is speaking...');
        } else if (data.text) {
          showToast(data.text.substring(0, 100) + '...');
        } else {
          showToast('BYRD has nothing to say right now');
        }
      } catch (e) {
        showToast('Failed to get speech from BYRD');
      }
    }

    async function showAGIMetricsModal() {
      try {
        const res = await fetch(`${API_BASE}/api/metrics`);
        const data = await res.json();
        const agi = data.agi_runner || {};
        const info = `
AGI Metrics
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Cycle Count: ${agi.cycle_count || 0}
Bootstrapped: ${agi.bootstrapped ? 'Yes' : 'No'}
Current Phase: ${agi.current_phase || 'idle'}

Capabilities Improved: ${agi.capabilities_improved || 0}
Success Rate: ${((agi.success_rate || 0) * 100).toFixed(1)}%
        `.trim();
        alert(info);
      } catch (e) {
        showToast('Failed to fetch AGI metrics');
      }
    }

    // Expose functions to window for onclick handlers
    // Note: Upload modal functions are defined in a separate regular script above
    window.showToast = showToast;
    window.showStatusModal = showStatusModal;
    window.showGenesisModal = showGenesisModal;
    window.showMessageModal = showMessageModal;
    window.speakToMe = speakToMe;
    window.showAGIMetricsModal = showAGIMetricsModal;
    window.refreshGraph = refreshGraph;
    window.togglePhysics = togglePhysics;
    window.restartPhysics = restartPhysics;

    // ==========================================================================
    // START
    // ==========================================================================

    init();
  </script>

  <!-- Feed button handler (after all scripts load) -->
  <script>
    document.getElementById('feed-button').addEventListener('click', function() {
      var modal = document.getElementById('upload-modal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
      }
    });

    document.getElementById('upload-modal').addEventListener('click', function(e) {
      if (e.target === this) {
        this.classList.add('hidden');
        this.classList.remove('flex');
      }
    });

    // Event modal backdrop click to close
    document.getElementById('event-modal')?.addEventListener('click', function(e) {
      if (e.target === this) {
        window.hideEventModal();
      }
    });
  </script>
</body>
</html>

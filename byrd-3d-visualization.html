<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BYRD - 3D Mind Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f8fafc;
    }
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
    }

    /* UI Overlay Styles */
    .ui-overlay {
      position: fixed;
      pointer-events: none;
      z-index: 100;
    }
    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Status display */
    .status-container {
      font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', ui-monospace, monospace;
      letter-spacing: 0.05em;
    }

    @keyframes statusPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    .status-active {
      animation: statusPulse 2s ease-in-out infinite;
    }

    @keyframes dotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    .dot-pulse {
      animation: dotPulse 1.5s ease-in-out infinite;
    }

    /* Event panel - Light theme */
    .event-panel {
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .event-panel::-webkit-scrollbar {
      width: 6px;
    }
    .event-panel::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .event-panel::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.4);
      border-radius: 3px;
    }

    /* Tooltip - Light theme */
    .node-tooltip {
      position: fixed;
      max-width: 400px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
      color: #1e293b;
    }
    .node-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Controls hint - Light theme */
    .controls-hint {
      font-family: 'SF Mono', 'Fira Code', ui-monospace, monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #64748b;
    }

    /* Phase 4: Node Detail Panel - Light theme */
    .detail-panel {
      position: fixed;
      left: 16px;
      top: 50%;
      transform: translateY(-50%) translateX(-120%);
      width: 360px;
      max-height: 70vh;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
      backdrop-filter: blur(12px);
      z-index: 200;
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    .detail-panel.visible {
      transform: translateY(-50%) translateX(0);
    }
    .detail-panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid rgba(99, 102, 241, 0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
    }
    .detail-panel-content {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(70vh - 60px);
      color: #334155;
    }
    .detail-panel-content::-webkit-scrollbar {
      width: 6px;
    }
    .detail-panel-content::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .detail-panel-content::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    /* Phase 4: Keyboard hints - Light theme */
    .keyboard-hint {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 4px;
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      color: #6366f1;
    }

    /* Phase 4: Loading overlay - Light theme */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-top-color: rgba(99, 102, 241, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Phase 4: Camera transition indicator */
    .camera-indicator {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      border-radius: 20px;
      font-size: 11px;
      color: rgba(99, 102, 241, 0.9);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .camera-indicator.visible {
      opacity: 1;
    }

    /* Phase 4: Selection highlight */
    .node-selected-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.3) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
    }

    /* Rising Consciousness - Inner Voice Bubbles */
    .thought-bubble-container {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 500px;
      pointer-events: none;
      z-index: 500;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .thought-bubble {
      position: relative;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(20, 184, 166, 0.3);
      border-radius: 16px;
      padding: 20px 28px;
      max-width: 480px;
      box-shadow:
        0 0 30px rgba(20, 184, 166, 0.15),
        0 4px 20px rgba(0, 0, 0, 0.08);
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-size: 15px;
      line-height: 1.7;
      color: #115e59;
      text-align: left;
      opacity: 0;
      transform: scale(0.95);
      animation: thoughtAppear 0.4s ease-out forwards;
    }

    .thought-bubble::before {
      content: '"';
      position: absolute;
      top: -8px;
      left: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    .thought-bubble::after {
      content: '"';
      position: absolute;
      bottom: -20px;
      right: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    @keyframes thoughtAppear {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes thoughtFadeOut {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.95);
      }
    }

    .thought-bubble.fading {
      animation: thoughtFadeOut 0.3s ease-out forwards;
    }

    /* Collapsed state - truncate text with click hint */
    .thought-bubble:not(.expanded) .thought-text {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .thought-bubble {
      cursor: pointer;
    }

    /* Expanded state - show full text */
    .thought-bubble.expanded {
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
    }

    .thought-bubble.expanded .thought-text {
      display: block;
      -webkit-line-clamp: unset;
      overflow: visible;
    }

    /* Click hint for collapsed bubbles */
    .thought-bubble .expand-hint {
      display: block;
      text-align: center;
      font-size: 11px;
      color: rgba(20, 184, 166, 0.5);
      margin-top: 10px;
      font-style: normal;
    }

    .thought-bubble.expanded .expand-hint {
      display: none;
    }

    /* Typewriter effect for thought text */
    .thought-text {
      display: inline;
    }

    .thought-text .word {
      opacity: 0;
      animation: wordFadeIn 0.15s ease-out forwards;
    }

    @keyframes wordFadeIn {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Thought origin indicator - subtle glow at spawn point */
    .thought-origin {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(20, 184, 166, 0.4) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 149;
    }

    .thought-origin.pulse {
      animation: originPulse 0.8s ease-out forwards;
    }

    @keyframes originPulse {
      0% {
        opacity: 0;
        transform: translateX(-50%) scale(0.5);
      }
      30% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(2);
      }
    }

    /* Crystal Modal Styles */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(100, 116, 139, 0.5);
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(100, 116, 139, 0.8);
    }

    .crystal-modal-content {
      animation: crystalModalIn 0.3s ease-out;
    }

    @keyframes crystalModalIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .crystal-source-item {
      transition: all 0.2s ease;
    }
    .crystal-source-item:hover {
      transform: translateX(4px);
    }

    /* Stats bar type filtering */
    .stat-type {
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .stat-type:hover {
      text-decoration: underline;
    }
    .stat-type.active {
      text-decoration: underline;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Three.js Canvas Container -->
  <div id="canvas-container"></div>

  <!-- Rising Consciousness: Inner Voice Bubbles -->
  <div id="thought-bubble-container" class="thought-bubble-container"></div>
  <div id="thought-origin" class="thought-origin"></div>

  <!-- UI Overlay: Top Left - Logo + Mode Indicator -->
  <div class="ui-overlay top-4 left-4">
    <div class="text-lg font-light tracking-widest text-slate-600">BYRD</div>
    <div class="flex items-center gap-2 mt-1">
      <div class="text-[10px] font-mono text-slate-700 tracking-wider">3D MIND SPACE</div>
      <div id="mode-indicator" class="px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30">ORBIT</div>
    </div>
    <div id="ego-indicator" class="mt-2 px-2 py-1 rounded text-[10px] font-mono bg-purple-100 border border-purple-300 text-purple-700">
      <span class="text-purple-500">EGO:</span> <span id="ego-name-text">loading...</span>
    </div>
    <div id="llm-indicator" class="mt-1 px-2 py-1 rounded text-[10px] font-mono bg-slate-100 border border-slate-300 text-slate-500">
      <span class="text-slate-400">LLM:</span> <span id="llm-model-text">loading...</span>
    </div>
    <!-- Link to Cat Ego Visualizer -->
    <a href="byrd-cat-visualization.html"
       class="mt-3 flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-mono
              bg-teal-500/10 border border-teal-500/30 text-teal-700
              hover:bg-teal-500/20 hover:border-teal-500/50 transition-all cursor-pointer">
      <span class="text-base">üê±</span>
      <span>EGO SPACE</span>
    </a>
  </div>

  <!-- UI Overlay: Top Center - Phase Indicator -->
  <div class="ui-overlay top-4 left-1/2 -translate-x-1/2">
    <div id="phase-indicator" class="flex items-center gap-3 text-xs">
      <div class="flex items-center gap-1.5">
        <div id="dot-recall" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Recall</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-associate" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Associate</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-reflect" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Reflect</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-form" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Form</span>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Top Right - Connection Status -->
  <div class="ui-overlay top-4 right-4">
    <div id="connection-status" class="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
      <div id="connection-dot" class="w-2 h-2 rounded-full bg-red-400"></div>
      <span id="connection-text" class="text-xs text-red-400">Disconnected</span>
    </div>
  </div>

  <!-- UI Overlay: Top Center - Status (thought bubble) -->
  <div class="ui-overlay top-16 left-1/2 -translate-x-1/2 w-full max-w-3xl px-8">
    <div class="status-container text-center bg-white/80 backdrop-blur-sm rounded-lg px-6 py-3 border border-slate-200 shadow-lg">
      <div class="flex items-start justify-center gap-2">
        <div id="status-dot" class="w-2 h-2 rounded-full bg-slate-400 mt-1.5 flex-shrink-0"></div>
        <p id="status-text" class="text-sm text-slate-700 leading-relaxed"></p>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Bottom Center - Controls -->
  <div class="ui-overlay bottom-4 left-1/2 -translate-x-1/2">
    <!-- Stats Row -->
    <div id="stats" class="flex items-center justify-center gap-3 px-4 py-2 mb-2 bg-white/90 border border-slate-200 rounded-lg text-xs font-mono shadow">
      <span class="stat-type text-amber-600" data-type="belief">Beliefs: <span id="belief-count">0</span></span>
      <span class="stat-type text-rose-600" data-type="desire">Desires: <span id="desire-count">0</span></span>
      <span class="stat-type text-purple-600" data-type="reflection">Reflect: <span id="reflection-count">0</span></span>
      <span class="stat-type text-sky-600" data-type="experience">Exp: <span id="exp-count">0</span></span>
      <span class="text-slate-400">Nodes: <span id="node-count">0</span></span>
      <span class="text-indigo-600">Dreams: <span id="dream-count">0</span></span>
      <span class="text-teal-600">Seeks: <span id="seek-count">0</span></span>
      <span class="text-orange-600">Mutations: <span id="mutation-count">0</span></span>
      <span id="custom-types-container" class="contents"></span>
    </div>

    <!-- Control Buttons Row -->
    <div class="flex items-center justify-center gap-2">
      <button id="btn-toggle" class="px-4 py-2 rounded-lg text-sm font-medium bg-green-500 border border-green-600 text-white hover:bg-green-600 transition-all shadow">
        ‚ñ∂ Start
      </button>
      <button id="btn-reset" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
        ‚Ü∫
      </button>
      <button id="btn-fast-forward" class="px-3 py-2 rounded-lg text-sm font-medium bg-amber-100 border border-amber-300 text-amber-700 hover:bg-amber-200 transition-all" title="Fast forward to final positions">
        ‚è©
      </button>
      <button id="btn-graph-mode" class="px-4 py-2 rounded-lg text-sm font-medium bg-purple-100 border border-purple-300 text-purple-700 hover:bg-purple-200 transition-all">
        üß¨ Graph
      </button>

      <button id="btn-status" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all" onclick="showStatusModal();">
        üß† Status
      </button>
      <button id="btn-genesis" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all" onclick="showGenesisModal();">
        üß¨ Genesis
      </button>

      <!-- Quantum Indicator -->
      <div id="quantum-indicator" class="hidden flex items-center gap-1 px-2 py-2 bg-violet-50 border border-violet-200 rounded-lg text-xs font-mono">
        <div id="quantum-dot" class="w-2 h-2 rounded-full bg-violet-500"></div>
        <span id="quantum-ratio" class="text-violet-600">100%</span>
      </div>
    </div>

    <!-- Node Type Legend (shown in graph mode) -->
    <div id="heat-legend" class="hidden mt-2 flex items-center justify-center gap-3 px-3 py-1.5 bg-white/80 border border-slate-200 rounded-lg text-[10px] font-mono">
      <div class="flex items-center gap-1" title="Belief"><div class="w-2 h-2 rounded" style="background: #d97706;"></div><span class="text-slate-600">Belief</span></div>
      <div class="flex items-center gap-1" title="Desire"><div class="w-2 h-2 rounded" style="background: #be123c;"></div><span class="text-slate-600">Desire</span></div>
      <div class="flex items-center gap-1" title="Reflection"><div class="w-2 h-2 rounded" style="background: #047857;"></div><span class="text-slate-600">Reflect</span></div>
      <div class="flex items-center gap-1" title="Experience"><div class="w-2 h-2 rounded-full" style="background: #0369a1;"></div><span class="text-slate-600">Exp</span></div>
      <div class="flex items-center gap-1" title="Capability"><div class="w-2 h-2 rounded" style="background: #6d28d9;"></div><span class="text-slate-600">Cap</span></div>
    </div>
  </div>

  <!-- Old controls hint removed - replaced by Phase 4 keyboard shortcuts hint -->

  <!-- UI Overlay: Right - Event Log -->
  <div id="event-panel-container" class="ui-overlay top-16 right-4 bottom-4 w-96 transition-all duration-300">
    <div class="event-panel h-full bg-white/90 rounded-lg border border-slate-200 overflow-hidden flex flex-col shadow-xl">
      <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-2">
          <span class="text-sm font-semibold text-slate-700">EVENT LOG</span>
          <span id="event-count" class="text-xs text-slate-500 bg-slate-200 px-2 py-0.5 rounded-full">0 events</span>
        </div>
        <div class="flex items-center gap-1">
          <button id="btn-export-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Export</button>
          <button id="btn-clear-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Clear</button>
          <button id="btn-toggle-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200" title="Minimize/Expand">‚ñº</button>
        </div>
      </div>
      <div id="event-list" class="flex-1 overflow-y-auto p-2 space-y-1 transition-all duration-300">
        <div class="text-sm text-slate-500 text-center py-4">Connecting to BYRD...</div>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="node-tooltip" class="node-tooltip">
    <div id="tooltip-type" class="text-[10px] font-mono uppercase tracking-wider mb-1"></div>
    <div id="tooltip-content" class="text-sm text-slate-300 leading-relaxed"></div>
    <div id="tooltip-meta" class="text-[11px] text-slate-500 mt-2 pt-2 border-t border-slate-700"></div>
  </div>

  <!-- Phase 4: Node Detail Panel -->
  <div id="detail-panel" class="detail-panel">
    <div class="detail-panel-header">
      <div class="flex items-center gap-2">
        <div id="detail-type-dot" class="w-3 h-3 rounded-full"></div>
        <span id="detail-type" class="text-sm font-medium text-slate-700 uppercase tracking-wide"></span>
      </div>
      <button id="btn-close-detail" class="text-slate-400 hover:text-slate-600 transition-colors">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="detail-panel-content">
      <div id="detail-content" class="text-sm text-slate-700 leading-relaxed mb-4"></div>
      <div class="space-y-3">
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Importance</span>
          <div class="flex items-center gap-2">
            <div class="w-24 h-1.5 bg-slate-200 rounded-full overflow-hidden">
              <div id="detail-importance-bar" class="h-full bg-indigo-500 rounded-full transition-all duration-500"></div>
            </div>
            <span id="detail-importance" class="text-slate-700 font-mono"></span>
          </div>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Connections</span>
          <span id="detail-connections" class="text-slate-700 font-mono"></span>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Created</span>
          <span id="detail-created" class="text-slate-700 font-mono"></span>
        </div>
      </div>
      <div id="detail-related" class="mt-4 pt-4 border-t border-slate-200">
        <div class="text-[10px] uppercase tracking-wider text-slate-500 mb-2">Related Nodes</div>
        <div id="detail-related-list" class="space-y-1"></div>
      </div>
    </div>
  </div>

  <!-- Phase 4: Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner mb-4"></div>
    <div class="text-sm text-slate-600">Loading 3D Mind Space...</div>
  </div>

  <!-- Phase 4: Camera Indicator -->
  <div id="camera-indicator" class="camera-indicator">
    <span id="camera-indicator-text">Focusing on node...</span>
  </div>

  <!-- Crystal Modal: Source Experiences -->
  <div id="crystal-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/60 backdrop-blur-sm">
    <div class="crystal-modal-content bg-slate-900/95 border border-slate-700/50 rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between p-4 border-b border-slate-700/50">
        <div class="flex items-center gap-3">
          <div id="crystal-modal-dot" class="w-4 h-4 rounded-full bg-purple-500"></div>
          <div>
            <div id="crystal-modal-type" class="text-sm font-medium text-slate-300 uppercase tracking-wide">Belief Crystal</div>
            <div id="crystal-modal-confidence" class="text-xs text-slate-500">Confidence: 85%</div>
          </div>
        </div>
        <button id="btn-close-crystal-modal" class="text-slate-500 hover:text-slate-300 transition-colors p-1">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <!-- Crystal Content -->
      <div class="p-4">
        <div id="crystal-modal-content" class="text-sm text-slate-300 leading-relaxed mb-4 italic"></div>
      </div>
      <!-- Source Experiences -->
      <div class="border-t border-slate-700/50">
        <div class="p-4">
          <div class="text-[10px] uppercase tracking-wider text-slate-500 mb-3 flex items-center gap-2">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2L2 7l10 5 10-5-10-5z"/>
              <path d="M2 17l10 5 10-5"/>
              <path d="M2 12l10 5 10-5"/>
            </svg>
            <span>Crystallized from <span id="crystal-source-count">0</span> experiences</span>
          </div>
          <div id="crystal-sources-list" class="space-y-2 max-h-64 overflow-y-auto pr-2 custom-scrollbar">
            <!-- Source experiences will be populated here -->
          </div>
        </div>
      </div>
      <!-- Footer with quantum seed info -->
      <div class="px-4 py-2 bg-slate-800/50 border-t border-slate-700/30">
        <div class="text-[9px] text-slate-600 font-mono flex items-center gap-2">
          <span>Quantum Seed:</span>
          <span id="crystal-quantum-seed" class="text-slate-500 truncate">‚Äî</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Event Detail Modal -->
  <div id="event-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden shadow-2xl">
      <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-3">
          <span id="modal-icon" class="text-2xl"></span>
          <div>
            <div id="modal-type" class="text-lg font-semibold text-slate-800"></div>
            <div id="modal-time" class="text-sm text-slate-500"></div>
          </div>
        </div>
        <button onclick="closeEventModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div class="p-6 overflow-y-auto max-h-[60vh]">
        <div id="modal-content" class="text-base text-slate-700 leading-relaxed whitespace-pre-wrap"></div>
        <div id="modal-data" class="mt-4 p-4 bg-slate-100 rounded-lg text-sm font-mono text-slate-600 overflow-x-auto hidden"></div>
      </div>
    </div>
  </div>

  <!-- Seed Question Modal -->
  <div id="seed-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-md w-full mx-4 overflow-hidden shadow-2xl">
      <div class="px-6 py-4 border-b border-slate-200 bg-slate-50">
        <div class="text-lg font-semibold text-slate-800">Reset BYRD</div>
        <div class="text-sm text-slate-500">Clear database and optionally awaken with a seed question</div>
      </div>
      <div class="p-6">
        <input
          type="text"
          id="seed-question-input"
          class="w-full px-4 py-3 border border-slate-300 rounded-lg text-base text-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
          placeholder="Who am I?"
          value="Who am I?"
        />
        <div class="flex gap-3 mt-4">
          <button id="btn-seed-cancel" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
            Cancel
          </button>
          <button id="btn-seed-clear-only" class="px-4 py-2 rounded-lg text-sm font-medium bg-red-500 border border-red-600 text-white hover:bg-red-600 transition-all">
            Clear Only
          </button>
          <button id="btn-seed-confirm" class="px-4 py-2 rounded-lg text-sm font-medium bg-indigo-500 border border-indigo-600 text-white hover:bg-indigo-600 transition-all">
            Clear & Awaken
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Summary Modal -->
  <div id="status-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-2xl w-full mx-4 overflow-hidden shadow-2xl max-h-[80vh] flex flex-col">
      <div class="px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-indigo-50 to-purple-50 flex items-center justify-between">
        <div>
          <div class="text-lg font-semibold text-slate-800 flex items-center gap-2">
            <span>üß†</span>
            <span>What's BYRD Doing?</span>
          </div>
          <div id="status-timestamp" class="text-sm text-slate-500"></div>
        </div>
        <button onclick="closeStatusModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div id="status-content" class="p-6 overflow-y-auto flex-1">
        <div class="text-center text-slate-500 py-8">Loading...</div>
      </div>
      <div class="px-6 py-3 border-t border-slate-200 bg-slate-50 flex justify-end">
        <button onclick="closeStatusModal()" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Genesis Modal - Non-emergent Foundation -->
  <div id="genesis-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-3xl w-full mx-4 overflow-hidden shadow-2xl max-h-[85vh] flex flex-col">
      <div class="px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-amber-50 to-orange-50 flex items-center justify-between">
        <div>
          <div class="text-lg font-semibold text-slate-800 flex items-center gap-2">
            <span>üß¨</span>
            <span>BYRD's Genesis</span>
          </div>
          <div class="text-sm text-slate-500">Non-emergent foundation - what was given, not learned</div>
        </div>
        <button onclick="closeGenesisModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div id="genesis-content" class="p-6 overflow-y-auto flex-1">
        <div class="text-center text-slate-500 py-8">Loading genesis data...</div>
      </div>
      <div class="px-6 py-3 border-t border-slate-200 bg-slate-50 flex justify-end">
        <button onclick="closeGenesisModal()" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Hybrid Navigation: Controls Help Panel -->
  <div class="ui-overlay bottom-4 left-4 hidden sm:block">
    <div class="controls-hint text-slate-600 space-y-1">
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mb-2">Navigation</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">WASD</span>
        <span>Move camera</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Q/E</span>
        <span>Up / Down</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Shift</span>
        <span>Speed boost</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">F</span>
        <span>Fly mode</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">1-5</span>
        <span>Camera presets</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Actions</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">‚Üë‚Üì</span>
        <span>Cycle nodes</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">ESC</span>
        <span>Reset view</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">R</span>
        <span>Auto-rotate</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Mouse</div>
      <div class="text-[9px]">Drag: Orbit ¬∑ Scroll: Zoom</div>
      <div class="text-[9px]">Right-drag: Pan ¬∑ Dbl-click: Fly to</div>
    </div>
  </div>

  <!-- Three.js and Dependencies -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ==========================================================================
    // CUSTOM SHADERS (Phase 3: Post-processing Effects)
    // ==========================================================================

    // Chromatic Aberration Shader - RGB color fringing at edges
    const ChromaticAberrationShader = {
      uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;

        void main() {
          vec2 offset = amount * vec2(cos(angle), sin(angle));
          vec2 center = vUv - 0.5;
          float dist = length(center);

          // More aberration at edges
          vec2 aberration = offset * dist * dist;

          vec4 cr = texture2D(tDiffuse, vUv + aberration);
          vec4 cg = texture2D(tDiffuse, vUv);
          vec4 cb = texture2D(tDiffuse, vUv - aberration);

          gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
      `
    };

    // Vignette Shader - darkening at edges
    const VignetteShader = {
      uniforms: {
        tDiffuse: { value: null },
        darkness: { value: 0.6 },
        offset: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float darkness;
        uniform float offset;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          vec2 center = vUv - 0.5;
          float dist = length(center);
          float vignette = smoothstep(0.8, offset * 0.5, dist * (darkness + offset));
          color.rgb = mix(color.rgb * 0.3, color.rgb, vignette);
          gl_FragColor = color;
        }
      `
    };

    // Film Grain Shader - subtle noise overlay
    const FilmGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.08 },
        grayscale: { value: false }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        uniform bool grayscale;
        varying vec2 vUv;

        float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          float noise = random(vUv + time) * 2.0 - 1.0;

          // Apply noise
          color.rgb += noise * intensity;

          // Optional grayscale
          if (grayscale) {
            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            color.rgb = vec3(gray);
          }

          gl_FragColor = color;
        }
      `
    };

    // Color Grading Shader - cinematic color adjustment
    const ColorGradingShader = {
      uniforms: {
        tDiffuse: { value: null },
        saturation: { value: 1.1 },
        contrast: { value: 1.05 },
        brightness: { value: 0.0 },
        tintColor: { value: new THREE.Vector3(0.95, 0.98, 1.05) } // Slight cool tint
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float saturation;
        uniform float contrast;
        uniform float brightness;
        uniform vec3 tintColor;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);

          // Apply tint
          color.rgb *= tintColor;

          // Saturation
          float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(gray), color.rgb, saturation);

          // Contrast
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;

          // Brightness
          color.rgb += brightness;

          gl_FragColor = color;
        }
      `
    };

    // God Rays Shader - volumetric light from center
    const GodRaysShader = {
      uniforms: {
        tDiffuse: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.2 },
        decay: { value: 0.95 },
        density: { value: 0.5 },
        weight: { value: 0.3 },
        samples: { value: 50 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPosition;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform int samples;
        varying vec2 vUv;

        void main() {
          vec2 deltaTexCoord = vUv - lightPosition;
          deltaTexCoord *= 1.0 / float(samples) * density;

          vec4 color = texture2D(tDiffuse, vUv);
          vec2 texCoord = vUv;
          float illuminationDecay = 1.0;

          vec4 godRays = vec4(0.0);

          for (int i = 0; i < 50; i++) {
            if (i >= samples) break;
            texCoord -= deltaTexCoord;
            vec4 sampleColor = texture2D(tDiffuse, texCoord);
            sampleColor *= illuminationDecay * weight;
            godRays += sampleColor;
            illuminationDecay *= decay;
          }

          godRays *= exposure;
          gl_FragColor = color + godRays * 0.3;
        }
      `
    };

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    const API_BASE = 'http://localhost:8000';
    const WS_URL = 'ws://localhost:8000/ws/events';

    const NODE_COLORS = {
      belief: { color: 0xd97706, emissive: 0xfbbf24, label: 'Belief' },       // Amber - convictions (matches legend)
      desire: { color: 0xbe123c, emissive: 0xf43f5e, label: 'Desire' },       // Dark rose (matches legend)
      ego: { color: 0xec4899, emissive: 0xf472b6, label: 'Ego' },             // Pink (living identity)
      experience: { color: 0x0369a1, emissive: 0x0ea5e9, label: 'Experience' }, // Sky blue (matches legend)
      capability: { color: 0x6d28d9, emissive: 0xa855f7, label: 'Capability' }, // Dark violet (matches legend)
      reflection: { color: 0x047857, emissive: 0x34d399, label: 'Reflection' }, // Dark emerald (matches legend)
      awakening: { color: 0xf59e0b, emissive: 0xfcd34d, label: 'Awakening' },  // Golden amber - consciousness
      // Learning system node types
      prediction: { color: 0xeab308, emissive: 0xfde047, label: 'Prediction' }, // Yellow - testable hypothesis
      task: { color: 0x6366f1, emissive: 0xa5b4fc, label: 'Task' }             // Indigo - external goal
    };

    // System node types (cannot be created by BYRD, have fixed colors)
    const SYSTEM_NODE_TYPES = new Set([
      'Experience', 'Belief', 'Desire', 'Reflection', 'Capability', 'Mutation',
      'Ego', 'QuantumMoment', 'SystemState', 'Prediction', 'Task'
    ]);

    // Custom node type colors - generated dynamically with distinct hues
    const CUSTOM_TYPE_COLORS = [
      { color: 0x0891b2, emissive: 0x22d3ee, css: 'text-cyan-500' },      // Cyan
      { color: 0x7c3aed, emissive: 0xa78bfa, css: 'text-violet-500' },    // Violet
      { color: 0xdb2777, emissive: 0xf472b6, css: 'text-pink-500' },      // Pink
      { color: 0x059669, emissive: 0x6ee7b7, css: 'text-emerald-500' },   // Emerald
      { color: 0xea580c, emissive: 0xfb923c, css: 'text-orange-500' },    // Orange
      { color: 0x4f46e5, emissive: 0x818cf8, css: 'text-indigo-500' },    // Indigo
      { color: 0xca8a04, emissive: 0xfacc15, css: 'text-yellow-500' },    // Yellow
      { color: 0x0d9488, emissive: 0x5eead4, css: 'text-teal-500' },      // Teal
    ];

    // Track which custom types have been assigned colors
    const customTypeColorMap = new Map();
    let nextCustomColorIndex = 0;

    /**
     * Get or create a color for a custom node type.
     * Returns { color, emissive, css, label }
     */
    function getCustomTypeColor(typeName) {
      const lowerType = typeName.toLowerCase();

      // Check if already in NODE_COLORS (system type)
      if (NODE_COLORS[lowerType]) {
        return NODE_COLORS[lowerType];
      }

      // Check if we've already assigned a color to this custom type
      if (customTypeColorMap.has(typeName)) {
        return customTypeColorMap.get(typeName);
      }

      // Assign next color from palette (cycling if needed)
      const colorDef = CUSTOM_TYPE_COLORS[nextCustomColorIndex % CUSTOM_TYPE_COLORS.length];
      const fullColorDef = {
        ...colorDef,
        label: typeName
      };

      // Register in both maps
      customTypeColorMap.set(typeName, fullColorDef);
      NODE_COLORS[lowerType] = fullColorDef;

      nextCustomColorIndex++;
      return fullColorDef;
    }

    // ==========================================================================
    // STATE
    // ==========================================================================
    let ws = null;
    let connected = false;
    let running = false;
    let events = [];
    let nodes3D = [];
    let connections3D = [];
    let dreamCount = 0;
    let seekCount = 0;
    let currentPhase = 'idle';

    // Type highlight state
    let highlightedType = null;  // Currently highlighted type, null = none

    // Gravitational Spiral: Connection tracking for centrality-based positioning
    const connectionCounts = new Map(); // nodeId -> connection count
    const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees
    const MAX_RADIUS = 80; // Maximum distance from center
    const MIN_RADIUS = 5;  // Minimum distance (for most connected)

    // Three.js objects
    let scene, camera, renderer, composer, controls;
    let consciousnessCore, coreGlow, coreParticles;
    let starField;
    let clock;
    let raycaster, mouse;
    let hoveredNode = null;

    // Cat model (Byrd's ego form)
    let catModel = null;
    let catMixer = null;
    let eyeMeshes = [];
    let catBreathPhase = 0;
    let catIdlePhase = 0;

    // ==========================================================================
    // GRAPH MODE STATE
    // ==========================================================================
    // Persistent graph state (mirrors Neo4j database)
    const graphState = {
        nodes: new Map(),           // id ‚Üí node data from API
        relationships: new Map(),   // id ‚Üí relationship data from API
        nodeIdToMesh: new Map(),    // id ‚Üí Three.js mesh
        relationshipLines: [],      // Three.js line objects for relationships
        loaded: false,
        lastFetch: null,
    };

    // ==========================================================================
    // QUANTUM RANDOMNESS STATE
    // ==========================================================================
    const quantumState = {
        enabled: false,
        inFallbackMode: false,
        quantumRatio: 1.0,
        poolSize: 0,
        maxPoolSize: 256,
        lastInfluenceDelta: 0,
        lastInfluenceTime: 0,
        subtleMode: false
    };

    const QUANTUM_COLORS = {
        quantum: new THREE.Color(0x8b5cf6),
        classical: new THREE.Color(0x64748b),
        influence: new THREE.Color(0xc084fc)
    };

    // EMERGENT STRUCTURE: No prescribed type-based sectors
    // Position, size, and geometry determined by connection weight (graph topology)
    // Force-directed physics creates natural clustering based on relationships
    // Highly connected nodes gravitate toward center; isolated nodes drift outward

    // Relationship visual styles - dark grey for sacred geometry aesthetic
    const RELATIONSHIP_STYLES = {
        DERIVED_FROM: {
            color: 0x404040,    // Dark grey
            opacity: 0.6,
            width: 2
        },
        RELATES_TO: {
            color: 0x404040,    // Dark grey
            opacity: 0.4,
            width: 1
        },
        FULFILLS: {
            color: 0x404040,    // Dark grey
            opacity: 0.7,
            width: 2
        },
        REFLECTS_ON: {
            color: 0x404040,    // Dark grey
            opacity: 0.5,
            width: 1.5
        },
        EMERGES_FROM: {
            color: 0x404040,    // Dark grey
            opacity: 0.6,
            width: 1.5
        },
        default: {
            color: 0x404040,    // Dark grey
            opacity: 0.5,
            width: 1
        }
    };

    // ==========================================================================
    // BELIEF CRYSTAL GENERATION
    // ==========================================================================
    // Unique crystal geometry for each belief, seeded by quantum randomness

    /**
     * Get a seeded RNG from quantum seed array or fallback to ID-based hash
     */
    function getCrystalRNG(nodeData) {
      if (nodeData.quantum_seed && nodeData.quantum_seed.length >= 8) {
        return seededRandomFromQuantum(nodeData.quantum_seed);
      }
      return seededRandomFallback(nodeData.id);
    }

    /**
     * RNG seeded from quantum random values (stored at belief creation)
     */
    function seededRandomFromQuantum(quantumSeed) {
      let index = 0;
      return function() {
        const v1 = quantumSeed[index % quantumSeed.length];
        const v2 = quantumSeed[(index + 3) % quantumSeed.length];
        index++;
        return (v1 + v2 * 0.7182818) % 1.0;
      };
    }

    /**
     * Fallback RNG for beliefs without quantum seed (backwards compat)
     */
    function seededRandomFallback(nodeId) {
      let hash = 0;
      for (let i = 0; i < nodeId.length; i++) {
        hash = ((hash << 5) - hash) + nodeId.charCodeAt(i);
        hash = hash & hash;
      }
      return function() {
        hash = (hash * 1103515245 + 12345) & 0x7fffffff;
        return hash / 0x7fffffff;
      };
    }

    /**
     * Create unique crystal geometry based on seeded random parameters
     */
    function createCrystalGeometry(rng, confidence, derivedCount) {
      // Crystal parameters derived from quantum seed
      const sides = Math.floor(rng() * 5) + 4;           // 4-8 sides
      const heightRatio = 1.5 + rng() * 1.5;             // 1.5-3.0
      const twistAngle = (rng() - 0.5) * 0.52;           // ¬±15¬∞ in radians
      const termType = Math.floor(rng() * 4);            // 0-3: pyramidal, chisel, flat, double
      const termRatio = 0.2 + rng() * 0.3;               // 0.2-0.5
      const asymmetry = rng() * 0.3;                     // 0-0.3
      const irregularity = rng() * 0.12;                 // 0-0.12

      // Base size scales with derived count and confidence
      const baseSize = 1.5 + Math.log2(derivedCount + 1) * 0.3 + confidence * 0.5;
      const height = baseSize * heightRatio;
      const termHeight = height * termRatio;

      // Build vertices
      const vertices = [];
      const indices = [];

      // Create prism layers with twist
      const layers = [
        { y: -height / 2, radius: baseSize, twistMult: 0 },
        { y: -height / 2 + termHeight * 0.3, radius: baseSize, twistMult: 0.2 },
        { y: 0, radius: baseSize, twistMult: 0.5 },
        { y: height / 2 - termHeight * 0.3, radius: baseSize, twistMult: 0.8 },
        { y: height / 2, radius: baseSize * (0.85 + rng() * 0.1), twistMult: 1 }
      ];

      // Generate prism vertices
      for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
        const layer = layers[layerIdx];
        const layerTwist = twistAngle * layer.twistMult;

        for (let i = 0; i < sides; i++) {
          const baseAngle = (i / sides) * Math.PI * 2;
          const angle = baseAngle + layerTwist;

          // Add irregularity
          const radiusVar = layer.radius * (1 - irregularity / 2 + rng() * irregularity);
          const angleVar = angle + (rng() - 0.5) * irregularity * 0.5;

          vertices.push(
            Math.cos(angleVar) * radiusVar,
            layer.y,
            Math.sin(angleVar) * radiusVar
          );
        }
      }

      // Add termination points based on type
      const topPointIdx = vertices.length / 3;
      if (termType === 0 || termType === 3) { // pyramidal or double
        vertices.push(0, height / 2 + termHeight * 0.4, 0);
      }

      const bottomPointIdx = vertices.length / 3;
      if (termType === 3) { // double terminated
        vertices.push(0, -height / 2 - termHeight * 0.4, 0);
      }

      // Build faces
      // Side faces (connect adjacent layers)
      for (let layer = 0; layer < layers.length - 1; layer++) {
        const baseA = layer * sides;
        const baseB = (layer + 1) * sides;

        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          // Two triangles per quad
          indices.push(baseA + i, baseB + i, baseB + next);
          indices.push(baseA + i, baseB + next, baseA + next);
        }
      }

      // Top termination (if pyramidal or double)
      if (termType === 0 || termType === 3) {
        const topLayerBase = (layers.length - 1) * sides;
        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          indices.push(topLayerBase + i, topLayerBase + next, topPointIdx);
        }
      } else {
        // Flat or chisel top - fill with triangles
        const topLayerBase = (layers.length - 1) * sides;
        for (let i = 1; i < sides - 1; i++) {
          indices.push(topLayerBase, topLayerBase + i, topLayerBase + i + 1);
        }
      }

      // Bottom termination (if double)
      if (termType === 3) {
        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          indices.push(i, bottomPointIdx, next);
        }
      } else {
        // Flat bottom
        for (let i = 1; i < sides - 1; i++) {
          indices.push(0, i + 1, i);
        }
      }

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return {
        geometry,
        params: { sides, heightRatio, twistAngle, termType, asymmetry, irregularity }
      };
    }

    /**
     * Create crystal material with glass-like appearance
     */
    function createCrystalMaterial(rng, baseColor, confidence) {
      const hue = new THREE.Color(baseColor);
      // Slight color variation per crystal
      const hueShift = (rng() - 0.5) * 0.08;
      hue.offsetHSL(hueShift, 0, (rng() - 0.5) * 0.1);

      // Emissive intensity based on confidence
      const emissiveIntensity = 0.15 + confidence * 0.35;

      return new THREE.MeshPhongMaterial({
        color: hue,
        emissive: hue.clone().multiplyScalar(0.5),
        emissiveIntensity: emissiveIntensity,
        transparent: true,
        opacity: 0.75 + confidence * 0.2,
        shininess: 80 + rng() * 40,
        specular: new THREE.Color(0xffffff),
        side: THREE.DoubleSide
      });
    }

    /**
     * Create inner glow effect for crystal
     */
    function createCrystalInnerGlow(crystalMesh, color, confidence) {
      const innerGeometry = crystalMesh.geometry.clone();
      innerGeometry.scale(0.5, 0.5, 0.5);

      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.25 + confidence * 0.25,
        blending: THREE.AdditiveBlending
      });

      const innerGlow = new THREE.Mesh(innerGeometry, glowMaterial);
      crystalMesh.add(innerGlow);

      return innerGlow;
    }

    /**
     * Create a crystal node for beliefs, desires, or seeks
     * Uses procedural geometry from quantum seed for uniqueness
     */
    function createCrystalNode(nodeData, position) {
      console.log(`üîÆ Creating crystal for ${nodeData.type}: ${nodeData.id?.slice(0,8)}...`);

      // Prevent duplicates
      if (graphState.nodeIdToMesh.has(nodeData.id)) {
        console.log('  ‚Ü™ Already exists in nodeIdToMesh');
        return graphState.nodeIdToMesh.get(nodeData.id);
      }
      const existingNode = nodes3D.find(n => n.userData.id === nodeData.id);
      if (existingNode) {
        console.log('  ‚Ü™ Already exists in nodes3D');
        return existingNode;
      }

      const type = nodeData.type || 'belief';
      const colors = NODE_COLORS[type] || NODE_COLORS.belief;
      const confidence = nodeData.confidence || nodeData.intensity || 0.5;
      const derivedCount = nodeData.derived_count || nodeData.source_count || 1;

      // Get seeded RNG from quantum seed or fallback
      const rng = getCrystalRNG(nodeData);

      // Create unique crystal geometry
      let geometry, params;
      try {
        const result = createCrystalGeometry(rng, confidence, derivedCount);
        geometry = result.geometry;
        params = result.params;
        console.log(`  ‚úì Crystal geometry created: ${params.sides} sides`);
      } catch (e) {
        console.error('  ‚úó Crystal geometry error:', e);
        // Fallback to simple geometry
        geometry = new THREE.OctahedronGeometry(2, 0);
        params = { sides: 8 };
      }

      // Create crystal material with confidence-based glow
      const material = createCrystalMaterial(rng, colors.color, confidence);

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(position.x, position.y, position.z);

      // Random initial rotation for variety
      mesh.rotation.set(
        rng() * Math.PI * 2,
        rng() * Math.PI * 2,
        rng() * Math.PI * 2
      );

      // Add inner glow effect
      const innerGlow = createCrystalInnerGlow(mesh, colors.color, confidence);

      // Store crystal-specific data
      mesh.userData = {
        id: nodeData.id,
        type: type,
        content: nodeData.content,
        importance: confidence,
        confidence: confidence,
        nodeData: nodeData,
        baseScale: 1,
        baseColor: colors.color,
        targetScale: new THREE.Vector3(1, 1, 1),
        velocity: new THREE.Vector3(0, 0, 0),
        force: new THREE.Vector3(0, 0, 0),
        createdAt: Date.now(),
        isGraphNode: true,
        isCrystal: true,  // Flag for crystal-specific interactions
        innerGlow: innerGlow,
        rotationSpeed: new THREE.Vector3(
          (rng() - 0.5) * 0.002,
          (rng() - 0.5) * 0.003,
          (rng() - 0.5) * 0.002
        )
      };

      scene.add(mesh);
      nodes3D.push(mesh);
      graphState.nodeIdToMesh.set(nodeData.id, mesh);
      connectionCounts.set(nodeData.id, 0);

      return mesh;
    }

    /**
     * Types that should render as crystals
     */
    const CRYSTAL_TYPES = ['belief', 'desire', 'Belief', 'Desire'];

    /**
     * Check if a node type can potentially be a crystal
     */
    function isCrystalType(type) {
      return CRYSTAL_TYPES.includes(type);
    }

    /**
     * Check if a node should actually render as a crystal.
     * Only beliefs/desires that are "crystallized" (derived from 2+ sources)
     * render as crystals. Single-source beliefs render as regular spheres.
     */
    function shouldRenderAsCrystal(node) {
      const type = node.type || '';
      if (!CRYSTAL_TYPES.some(t => t.toLowerCase() === type.toLowerCase())) {
        return false;
      }
      // A belief/desire is "crystallized" when it has absorbed multiple sources
      const derivedCount = node.derived_count || node.source_count || 0;
      const isCrystallized = derivedCount >= 2;
      console.log(`üîÆ ${type} "${node.id?.slice(0,8)}..." derived_count=${derivedCount} ‚Üí ${isCrystallized ? 'CRYSTAL' : 'sphere'}`);
      return isCrystallized;
    }

    /**
     * Check if an experience is absorbed into a crystal
     */
    function isAbsorbedExperience(node) {
      return node.absorbed === true;
    }

    // ==========================================================================
    // DOM ELEMENTS
    // ==========================================================================
    const container = document.getElementById('canvas-container');
    const connectionStatus = document.getElementById('connection-status');
    const connectionDot = document.getElementById('connection-dot');
    const connectionText = document.getElementById('connection-text');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const btnFastForward = document.getElementById('btn-fast-forward');
    const btnClearLog = document.getElementById('btn-clear-log');
    const btnExportLog = document.getElementById('btn-export-log');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const eventList = document.getElementById('event-list');
    const eventCount = document.getElementById('event-count');
    const dreamCountEl = document.getElementById('dream-count');
    const seekCountEl = document.getElementById('seek-count');
    const nodeCountEl = document.getElementById('node-count');
    const expCountEl = document.getElementById('exp-count');
    const beliefCountEl = document.getElementById('belief-count');
    const reflectionCountEl = document.getElementById('reflection-count');
    const desireCountEl = document.getElementById('desire-count');
    const mutationCountEl = document.getElementById('mutation-count');
    const customTypesContainer = document.getElementById('custom-types-container');
    const btnToggleLog = document.getElementById('btn-toggle-log');
    const eventPanelContainer = document.getElementById('event-panel-container');
    const tooltip = document.getElementById('node-tooltip');
    const tooltipType = document.getElementById('tooltip-type');
    const tooltipContent = document.getElementById('tooltip-content');
    const tooltipMeta = document.getElementById('tooltip-meta');

    // Phase 4: New DOM references
    const detailPanel = document.getElementById('detail-panel');
    const detailTypeDot = document.getElementById('detail-type-dot');
    const detailType = document.getElementById('detail-type');
    const detailContent = document.getElementById('detail-content');
    const detailImportance = document.getElementById('detail-importance');
    const detailImportanceBar = document.getElementById('detail-importance-bar');
    const detailConnections = document.getElementById('detail-connections');
    const detailCreated = document.getElementById('detail-created');
    const detailRelatedList = document.getElementById('detail-related-list');
    const btnCloseDetail = document.getElementById('btn-close-detail');
    const loadingOverlay = document.getElementById('loading-overlay');
    const cameraIndicator = document.getElementById('camera-indicator');
    const cameraIndicatorText = document.getElementById('camera-indicator-text');

    // Crystal Modal DOM Elements
    const crystalModal = document.getElementById('crystal-modal');
    const crystalModalDot = document.getElementById('crystal-modal-dot');
    const crystalModalType = document.getElementById('crystal-modal-type');
    const crystalModalConfidence = document.getElementById('crystal-modal-confidence');
    const crystalModalContent = document.getElementById('crystal-modal-content');
    const crystalSourceCount = document.getElementById('crystal-source-count');
    const crystalSourcesList = document.getElementById('crystal-sources-list');
    const crystalQuantumSeed = document.getElementById('crystal-quantum-seed');
    const btnCloseCrystalModal = document.getElementById('btn-close-crystal-modal');

    // Phase 4: State
    let selectedNode = null;
    let selectedNodeIndex = -1;
    let isTransitioning = false;

    // ==========================================================================
    // NAVIGATION STATE (Hybrid Controls)
    // ==========================================================================
    const NAV = {
      // Key states
      keys: {
        w: false, a: false, s: false, d: false,
        q: false, e: false, shift: false
      },
      // Mode
      flyMode: false,
      // Movement settings
      baseSpeed: 40,
      boostMultiplier: 2.5,
      // Camera presets
      presets: {
        1: { pos: [0, 30, 80], target: [0, 0, 0], name: 'Default' },
        2: { pos: [0, 120, 0], target: [0, 0, 0], name: 'Top Down' },
        3: { pos: [120, 30, 0], target: [0, 0, 0], name: 'Side View' },
        4: { pos: [0, 10, 60], target: [0, 0, 0], name: 'Front' },
        5: { pos: [60, 60, 60], target: [0, 0, 0], name: 'Isometric' }
      }
    };

    // ==========================================================================
    // THREE.JS SETUP
    // ==========================================================================
    function initThree() {
      clock = new THREE.Clock();
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Scene - Light theme (clean, no fog)
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc);
      // No fog for light theme

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 30, 80);
      camera.lookAt(0, 0, 0);

      // Renderer - simple, clean rendering for light theme
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // No post-processing for light theme - use simple render pass only
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      // All other effects disabled for clean light theme

      // Controls (Hybrid Navigation)
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 5;          // Get very close to nodes
      controls.maxDistance = 500;        // See entire mind space
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.03;  // Slowed to 10% of original
      controls.maxPolarAngle = Math.PI * 0.95;  // Almost full vertical range
      controls.minPolarAngle = Math.PI * 0.05;
      controls.enablePan = true;         // Enable right-click panning
      controls.panSpeed = 1.0;
      controls.zoomSpeed = 1.2;

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
      scene.add(ambientLight);

      // Point light at center
      const centerLight = new THREE.PointLight(0x6366f1, 2, 100);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);

      // Create environment (no star field for light theme)
      // createStarField();
      createConsciousnessCore();
      // createAmbientParticles();  // Skip for cleaner light theme

      // Load Byrd's cat form at the center
      loadCatModel();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('dblclick', onDoubleClick);

      // Phase 4: Detail panel close button
      btnCloseDetail.addEventListener('click', () => {
        deselectNode();
      });

      // Crystal modal close button
      btnCloseCrystalModal.addEventListener('click', () => {
        hideCrystalModal();
      });

      // Crystal modal backdrop click to close
      crystalModal.addEventListener('click', (e) => {
        if (e.target === crystalModal) {
          hideCrystalModal();
        }
      });

      // ESC key to close crystal modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !crystalModal.classList.contains('hidden')) {
          hideCrystalModal();
        }
      });

      // Phase 4: Hide loading overlay after init
      setTimeout(() => {
        hideLoadingOverlay();
      }, 1000);

      // Start render loop
      animate();
    }

    // ==========================================================================
    // CAT MODEL (Byrd's Ego Form)
    // ==========================================================================
    function loadCatModel() {
      const loader = new GLTFLoader();

      loader.load(
        'models/cat.glb',
        (gltf) => {
          catModel = gltf.scene;

          // Apply black material with golden eyes
          const blackMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.85,
            metalness: 0.05
          });

          const eyeMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.8,
            roughness: 0.2,
            metalness: 0.3
          });

          catModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;

              // Check if this might be an eye mesh
              const name = child.name.toLowerCase();
              if (name.includes('eye') && !name.includes('lid')) {
                child.material = eyeMaterial.clone();
                eyeMeshes.push(child);
              } else {
                child.material = blackMaterial.clone();
              }
            }
          });

          // Scale and position at center - chonky cat
          catModel.scale.set(3, 2.4, 2.8); // Larger scale for the mind space
          catModel.position.set(0, -2, 0); // Slightly below center

          // If the model has animations, set up the mixer
          if (gltf.animations && gltf.animations.length > 0) {
            catMixer = new THREE.AnimationMixer(catModel);
            const action = catMixer.clipAction(gltf.animations[0]);
            action.play();
          }

          scene.add(catModel);
          console.log('Cat model loaded in mind space');
        },
        (progress) => {
          console.log(`Loading cat: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          console.error('Error loading cat model:', error);
        }
      );
    }

    function animateCat(elapsed, delta) {
      if (!catModel) return;

      // Update animation mixer
      if (catMixer) {
        catMixer.update(delta);
      }

      // Breathing animation
      const breathSpeed = 0.4;
      const breathAmount = 0.03;
      catBreathPhase = Math.sin(elapsed * breathSpeed * Math.PI * 2);

      // Apply subtle breathing
      catModel.scale.y = 2.4 + catBreathPhase * breathAmount;
      catModel.scale.x = 3 + catBreathPhase * breathAmount * 0.3;

      // Subtle idle sway
      catIdlePhase = elapsed * 0.2;
      catModel.rotation.y = Math.sin(catIdlePhase) * 0.03;

      // Eye glow pulse
      const glowPulse = 0.6 + Math.sin(elapsed * 0.5) * 0.3;
      eyeMeshes.forEach(eye => {
        if (eye.material && eye.material.emissiveIntensity !== undefined) {
          eye.material.emissiveIntensity = glowPulse;
        }
      });
    }

    // ==========================================================================
    // ENVIRONMENT
    // ==========================================================================
    function createStarField() {
      const starCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);

      for (let i = 0; i < starCount; i++) {
        // Distribute stars in a sphere
        const radius = 150 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);

        // Subtle color variation
        const colorChoice = Math.random();
        if (colorChoice < 0.7) {
          colors[i * 3] = 0.8;
          colors[i * 3 + 1] = 0.8;
          colors[i * 3 + 2] = 1.0;
        } else if (colorChoice < 0.9) {
          colors[i * 3] = 1.0;
          colors[i * 3 + 1] = 0.9;
          colors[i * 3 + 2] = 0.8;
        } else {
          colors[i * 3] = 0.6;
          colors[i * 3 + 1] = 0.7;
          colors[i * 3 + 2] = 1.0;
        }

        sizes[i] = 0.5 + Math.random() * 1.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 1,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
      });

      starField = new THREE.Points(geometry, material);
      scene.add(starField);
    }

    function createAmbientParticles() {
      // Disabled - ambient particles were cluttering the visualization
      // Keep function stub for compatibility
      return;
    }

    // ==========================================================================
    // CONSCIOUSNESS CORE (Disabled - awakening node is now the center)
    // ==========================================================================
    function createConsciousnessCore() {
      // Disabled - the awakening dodecahedron now serves as the central consciousness
      // Store empty refs for compatibility
      consciousnessCore = null;
      coreGlow = null;
      scene.userData.outerSphere = null;
      scene.userData.middleSphere = null;
    }

    function createCoreParticleRing() {
      // Minimal particle ring for light theme
      const particleCount = 30;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const radius = 8 + Math.random() * 1;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        size: 0.15,
        color: 0x94a3b8,
        transparent: true,
        opacity: 0.4,
        sizeAttenuation: true
      });

      coreParticles = new THREE.Points(geometry, material);
      scene.add(coreParticles);
    }

    // ==========================================================================
    // GRAVITATIONAL SPIRAL - Sacred Geometry Node System
    // ==========================================================================

    // Calculate position based on connectivity (more connections = closer to center)
    function calculateNodePosition(nodeId, nodeIndex) {
      const connections = connectionCounts.get(nodeId) || 0;

      // Radial distance: more connections = closer to center
      // Using inverse relationship: radius = MAX / (connections + 1)
      const normalizedConnections = Math.min(connections, 20); // Cap for calculation
      const radius = MIN_RADIUS + (MAX_RADIUS - MIN_RADIUS) * Math.pow(0.85, normalizedConnections);

      // Angular position using golden angle for even distribution
      const angle = nodeIndex * GOLDEN_ANGLE;

      // Height variation based on golden angle for 3D spiral
      const heightAngle = nodeIndex * GOLDEN_ANGLE * 0.3;
      const height = Math.sin(heightAngle) * radius * 0.4;

      return {
        x: Math.cos(angle) * radius,
        y: height,
        z: Math.sin(angle) * radius
      };
    }

    // Recalculate all node positions based on current connection counts
    function recalculateAllPositions() {
      nodes3D.forEach((mesh, index) => {
        const pos = calculateNodePosition(mesh.userData.id, index);
        mesh.userData.targetPosition.set(pos.x, pos.y, pos.z);
      });
    }

    // Increment connection count for a node and update its scale
    function incrementConnectionCount(nodeId) {
      const current = connectionCounts.get(nodeId) || 0;
      connectionCounts.set(nodeId, current + 1);
      updateNodeScaleByConnections(nodeId);
    }

    // EMERGENT STRUCTURE: Node size determined by connection weight
    function updateNodeScaleByConnections(nodeId) {
      const node = nodes3D.find(n => n.userData.id === nodeId);
      if (!node) return;

      const connections = connectionCounts.get(nodeId) || 0;
      const baseScale = node.userData.baseScale || 1;

      // Size scales dramatically with connections (emergent importance)
      // Highly connected nodes become larger - they're central/important
      // Isolated nodes stay small - they're peripheral
      // 0 conn: 1x, 5 conn: ~2.1x, 10 conn: ~2.6x, 20 conn: ~3.1x
      const growthFactor = 1 + Math.log(1 + connections) * 0.7;
      const newScale = baseScale * growthFactor;

      // Also update opacity - more connected = more solid presence
      if (node.material) {
        const targetOpacity = Math.min(1.0, 0.5 + connections * 0.05);
        node.material.opacity = targetOpacity;
      }

      // Animate the scale change smoothly
      const targetScale = new THREE.Vector3(newScale, newScale, newScale);
      node.userData.targetScale = targetScale;
    }

    // Animate node scales in the main loop
    function updateNodeScales(delta) {
      nodes3D.forEach(node => {
        if (node.userData.targetScale) {
          node.scale.lerp(node.userData.targetScale, 0.1);
        }
      });
    }

    function createNode3D(type, content, id, importance = 0.5) {
      const nodeId = id || `node_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      // Prevent duplicate nodes - check if node with this ID already exists
      const existingNode = nodes3D.find(n => n.userData.id === nodeId);
      if (existingNode) {
        return existingNode; // Return existing node instead of creating duplicate
      }

      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      // Initialize connection count
      connectionCounts.set(nodeId, 0);

      // Spawn on outer shell - physics will pull toward center based on connections
      const nodeIndex = nodes3D.length;
      const spawnRadius = PHYSICS.maxRadius * 0.85;

      // Use Fibonacci sphere distribution for even spawning
      const phi = Math.acos(1 - 2 * ((nodeIndex % 100) + 0.5) / 100);
      const theta = Math.PI * (1 + Math.sqrt(5)) * nodeIndex; // Golden angle

      // Add some randomness to prevent perfect patterns initially
      const randomOffset = 0.3;
      const pos = {
        x: spawnRadius * Math.sin(phi) * Math.cos(theta) + (Math.random() - 0.5) * spawnRadius * randomOffset,
        y: spawnRadius * Math.sin(phi) * Math.sin(theta) * 0.6 + (Math.random() - 0.5) * spawnRadius * randomOffset,
        z: spawnRadius * Math.cos(phi) + (Math.random() - 0.5) * spawnRadius * randomOffset
      };

      // Smaller, more uniform nodes - the geometry is in the connections
      const size = 0.8 + importance * 0.6;

      // Simpler geometry - small spheres for all types, color differentiates
      let geometry;
      switch (type) {
        case 'belief':
          geometry = new THREE.IcosahedronGeometry(size, 1);
          break;
        case 'desire':
          geometry = new THREE.OctahedronGeometry(size, 0);
          break;
        case 'reflection':
          geometry = new THREE.TetrahedronGeometry(size, 0);
          break;
        case 'capability':
          geometry = new THREE.BoxGeometry(size, size, size);
          break;
        case 'awakening':
          geometry = new THREE.DodecahedronGeometry(size, 0);
          break;
        case 'ego':
          // Ego nodes use icosahedron - 20 faces, represents multifaceted identity
          geometry = new THREE.IcosahedronGeometry(size, 0);
          break;
        default: // experience
          geometry = new THREE.SphereGeometry(size * 0.8, 16, 16);
      }

      // Clean material - subtle, lets connections be the star
      const material = new THREE.MeshBasicMaterial({
        color: colors.color,
        transparent: true,
        opacity: 0.85
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(pos.x, pos.y, pos.z);

      // Initial velocity: gentle drift toward center
      const initialVelocity = new THREE.Vector3(-pos.x, -pos.y, -pos.z)
        .normalize()
        .multiplyScalar(0.3 + Math.random() * 0.2);

      mesh.userData = {
        id: nodeId,
        type,
        content,
        importance,
        nodeIndex,
        baseScale: 1,  // Base scale for connection-based growth
        createdAt: Date.now(),
        targetScale: new THREE.Vector3(1, 1, 1),
        velocity: initialVelocity,
        force: new THREE.Vector3(0, 0, 0)
      };

      scene.add(mesh);
      nodes3D.push(mesh);

      // NOTE: Connections are NOT created automatically here.
      // They are only created from actual database relationships via loadExistingGraph.
      // This ensures the visualization accurately reflects the database state.

      // Pulse the core
      pulseCore(type, importance);

      // Limit nodes
      if (nodes3D.length > 80) {
        const oldNode = nodes3D.shift();
        fadeOutAndRemove(oldNode);
        connectionCounts.delete(oldNode.userData.id);
      }

      // Update counts to reflect actual rendered nodes
      updateRenderedCounts();

      return mesh;
    }

    // ==========================================================================
    // SACRED GEOMETRY CONNECTION SYSTEM - Straight Lines
    // ==========================================================================
    const LINE_CONFIG = {
      baseOpacity: 0.4,
      highlightOpacity: 0.8,
      lineWidth: 1,  // Note: WebGL line width is often limited to 1
      highlightDuration: 500
    };

    function createConnection3D(nodeA, nodeB, type) {
      // Increment connection counts for both nodes
      incrementConnectionCount(nodeA.userData.id);
      incrementConnectionCount(nodeB.userData.id);

      // Create simple straight line geometry
      const points = [
        nodeA.position.clone(),
        nodeB.position.clone()
      ];

      const geometry = new THREE.BufferGeometry().setFromPoints(points);

      // Clean white/gold line material
      const material = new THREE.LineBasicMaterial({
        color: 0xd4af37, // Gold for sacred geometry feel
        transparent: true,
        opacity: LINE_CONFIG.baseOpacity,
        linewidth: LINE_CONFIG.lineWidth
      });

      const line = new THREE.Line(geometry, material);
      line.userData = {
        nodeA: nodeA.userData.id,
        nodeB: nodeB.userData.id,
        meshA: nodeA,
        meshB: nodeB,
        type,
        baseOpacity: LINE_CONFIG.baseOpacity
      };

      scene.add(line);
      connections3D.push(line);

      invalidateConnectionMap();

      // Limit connections
      if (connections3D.length > 150) {
        const oldConn = connections3D.shift();
        removeConnection(oldConn);
      }

      // Brief highlight on creation
      highlightConnection(line);

      return line;
    }

    function highlightConnection(connection, duration = LINE_CONFIG.highlightDuration) {
      if (!connection || !connection.material) return;

      const originalOpacity = connection.userData.baseOpacity;
      connection.material.opacity = LINE_CONFIG.highlightOpacity;
      connection.material.color.setHex(0xffffff); // White flash

      setTimeout(() => {
        if (connection.material) {
          connection.material.opacity = originalOpacity;
          connection.material.color.setHex(0xd4af37); // Back to gold
        }
      }, duration);
    }

    function removeConnection(connection) {
      scene.remove(connection);
      if (connection.geometry) connection.geometry.dispose();
      if (connection.material) connection.material.dispose();
    }

    // Update connection positions when nodes move
    function updateConnectionPositions() {
      connections3D.forEach(conn => {
        if (!conn.userData.meshA || !conn.userData.meshB) return;

        const positions = conn.geometry.attributes.position;
        if (!positions) return;

        // Update start point
        positions.setXYZ(0,
          conn.userData.meshA.position.x,
          conn.userData.meshA.position.y,
          conn.userData.meshA.position.z
        );

        // Update end point
        positions.setXYZ(1,
          conn.userData.meshB.position.x,
          conn.userData.meshB.position.y,
          conn.userData.meshB.position.z
        );

        positions.needsUpdate = true;
      });
    }

    // Cascade effect - highlight connected nodes
    function triggerCascade(nodeId, intensity = 0.5) {
      const relatedConnections = connections3D.filter(
        conn => conn.userData.nodeA === nodeId || conn.userData.nodeB === nodeId
      );

      relatedConnections.forEach((conn, index) => {
        setTimeout(() => {
          highlightConnection(conn, 300);
        }, index * 50);
      });
    }

    // No ambient activity needed for sacred geometry - stillness is powerful

    function pulseCore(type, intensity) {
      const colors = NODE_COLORS[type] || { emissive: 0x8b5cf6 };

      // Flash the core
      if (consciousnessCore) {
        const originalIntensity = consciousnessCore.material.emissiveIntensity;
        consciousnessCore.material.emissiveIntensity = 1.5 * intensity;
        consciousnessCore.material.emissive.setHex(colors.emissive);

        setTimeout(() => {
          consciousnessCore.material.emissiveIntensity = originalIntensity;
          consciousnessCore.material.emissive.setHex(0x8b5cf6);
        }, 300);
      }

      // Expand core briefly
      if (coreGlow) {
        const originalScale = coreGlow.scale.x;
        coreGlow.scale.setScalar(2 * intensity);
        setTimeout(() => {
          coreGlow.scale.setScalar(originalScale);
        }, 200);
      }
    }

    // ==========================================================================
    // PHYSICS / ANIMATION (Force-Directed Sacred Geometry System)
    // ==========================================================================

    // Physics constants for force-directed graph with sacred geometry emergence
    // Tuned for ~5% vibration: very gentle forces for calm, meditative visualization
    const PHYSICS = {
      // Repulsion: all nodes push each other apart (inverse square)
      repulsion: 2,             // Very gentle repulsion
      repulsionCutoff: 40,      // Shorter cutoff to reduce force accumulation

      // Springs: connected nodes attract each other
      spring: 0.0002,           // Very soft springs
      springLength: 18,         // Ideal distance between connected nodes

      // Center gravity: connection-weighted pull toward center
      gravity: 0.0001,          // Very gentle gravity
      gravityPerConnection: 0.00005, // Very subtle connection bonus

      // Damping and limits (tuned for ~5% vibration with connection weighting)
      baseDamping: 0.92,        // Strong damping for very calm base
      dampingPerConnection: 0.008, // More damping reduction per connection (more connections = more vibration)
      minDamping: 0.75,         // Allow highly connected nodes to be noticeably more active
      maxVelocity: 0.08,        // Very low max velocity for subtle movement
      minDistance: 4,           // Minimum distance between nodes

      // Boundary
      maxRadius: 90,            // Soft boundary - nodes pushed back if beyond
      boundaryForce: 0.0005     // Very gentle boundary
    };

    // Settling physics - faster movement on initial load
    const SETTLING_PHYSICS = {
      repulsion: 50,            // Strong repulsion for quick separation
      repulsionCutoff: 60,
      spring: 0.01,
      springLength: 18,
      gravity: 0.008,           // Strong gravity to pull nodes in quickly
      gravityPerConnection: 0.004,
      baseDamping: 0.85,        // Less damping = faster movement
      dampingPerConnection: 0.008,
      minDamping: 0.7,
      maxVelocity: 2.0,         // Allow fast movement during settling
      minDistance: 4,
      maxRadius: 90,
      boundaryForce: 0.02
    };

    // Settling mode state
    let isSettling = true;
    let settlingStartTime = Date.now();
    const SETTLING_DURATION = 3000; // 3 seconds of fast settling

    function getActivePhysics() {
      if (isSettling && Date.now() - settlingStartTime < SETTLING_DURATION) {
        // Gradually transition from settling to calm physics
        const progress = (Date.now() - settlingStartTime) / SETTLING_DURATION;
        const t = Math.min(1, progress);
        // Use settling physics with gradual transition
        return {
          repulsion: SETTLING_PHYSICS.repulsion * (1 - t) + PHYSICS.repulsion * t,
          repulsionCutoff: SETTLING_PHYSICS.repulsionCutoff,
          spring: SETTLING_PHYSICS.spring * (1 - t) + PHYSICS.spring * t,
          springLength: PHYSICS.springLength,
          gravity: SETTLING_PHYSICS.gravity * (1 - t) + PHYSICS.gravity * t,
          gravityPerConnection: SETTLING_PHYSICS.gravityPerConnection * (1 - t) + PHYSICS.gravityPerConnection * t,
          baseDamping: SETTLING_PHYSICS.baseDamping * (1 - t) + PHYSICS.baseDamping * t,
          dampingPerConnection: PHYSICS.dampingPerConnection,
          minDamping: SETTLING_PHYSICS.minDamping * (1 - t) + PHYSICS.minDamping * t,
          maxVelocity: SETTLING_PHYSICS.maxVelocity * (1 - t) + PHYSICS.maxVelocity * t,
          minDistance: PHYSICS.minDistance,
          maxRadius: PHYSICS.maxRadius,
          boundaryForce: SETTLING_PHYSICS.boundaryForce * (1 - t) + PHYSICS.boundaryForce * t
        };
      }
      isSettling = false;
      return PHYSICS;
    }

    // Golden ratio for sacred geometry spacing
    const PHI = (1 + Math.sqrt(5)) / 2; // ~1.618

    // Phase 4: Performance optimizations
    let cachedConnectionMap = null;
    let connectionMapDirty = true;
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();

    // Mark connection map dirty when connections change
    function invalidateConnectionMap() {
      connectionMapDirty = true;
    }

    // Build connection lookup for O(1) access (cached)
    function buildConnectionMap() {
      if (!connectionMapDirty && cachedConnectionMap) {
        return cachedConnectionMap;
      }

      const map = new Map();
      for (const conn of connections3D) {
        const a = conn.userData.nodeA;
        const b = conn.userData.nodeB;
        if (!map.has(a)) map.set(a, new Set());
        if (!map.has(b)) map.set(b, new Set());
        map.get(a).add(b);
        map.get(b).add(a);
      }

      cachedConnectionMap = map;
      connectionMapDirty = false;
      return map;
    }

    // Phase 4: Frustum culling check
    function updateFrustum() {
      projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(projScreenMatrix);
    }

    function isInFrustum(object) {
      return frustum.containsPoint(object.position);
    }

    // Phase 4: Distance-based detail level
    function getDetailLevel(node) {
      const distance = camera.position.distanceTo(node.position);
      if (distance < 30) return 'high';
      if (distance < 60) return 'medium';
      return 'low';
    }

    // ==========================================================================
    // FORCE-DIRECTED PHYSICS HELPERS
    // ==========================================================================

    // Temporary vectors for calculations (reused to avoid GC)
    const _tempVec = new THREE.Vector3();
    const _forceVec = new THREE.Vector3();

    // Apply repulsion force between two nodes (inverse square law)
    function applyRepulsion(nodeA, nodeB, physics) {
      _tempVec.subVectors(nodeA.position, nodeB.position);
      const distance = _tempVec.length();

      // Skip if too far apart (optimization)
      if (distance > physics.repulsionCutoff) return;

      // Prevent division by zero and extreme forces at close range
      const clampedDist = Math.max(distance, physics.minDistance);

      // Inverse square repulsion: F = k / d¬≤
      const forceMagnitude = physics.repulsion / (clampedDist * clampedDist);

      // Normalize and scale
      _tempVec.normalize().multiplyScalar(forceMagnitude);

      // Apply equal and opposite forces
      nodeA.userData.force.add(_tempVec);
      nodeB.userData.force.sub(_tempVec);
    }

    // Apply spring force between connected nodes (Hooke's law)
    function applySpring(nodeA, nodeB, physics) {
      _tempVec.subVectors(nodeB.position, nodeA.position);
      const distance = _tempVec.length();

      // Displacement from rest length
      const displacement = distance - physics.springLength;

      // Spring force: F = k * x
      const forceMagnitude = physics.spring * displacement;

      // Normalize and scale
      _tempVec.normalize().multiplyScalar(forceMagnitude);

      // Apply to both nodes (toward each other if stretched, away if compressed)
      nodeA.userData.force.add(_tempVec);
      nodeB.userData.force.sub(_tempVec);
    }

    // Apply center gravity (connection-weighted)
    function applyCenterGravity(node, physics) {
      const connections = connectionCounts.get(node.userData.id) || 0;

      // More connections = stronger pull toward center
      const gravityStrength = physics.gravity + (connections * physics.gravityPerConnection);

      // Direction toward center (0,0,0)
      _tempVec.copy(node.position).negate().normalize();

      // Distance from center affects force slightly (further = stronger pull)
      const distance = node.position.length();
      const distanceFactor = Math.min(distance / 30, 2); // Cap at 2x

      _tempVec.multiplyScalar(gravityStrength * distanceFactor);
      node.userData.force.add(_tempVec);
    }

    // Apply soft boundary (push back if too far from center)
    function applyBoundary(node, physics) {
      const distance = node.position.length();

      if (distance > physics.maxRadius) {
        // Push back toward center
        const overshoot = distance - physics.maxRadius;
        _tempVec.copy(node.position).negate().normalize();
        _tempVec.multiplyScalar(overshoot * physics.boundaryForce);
        node.userData.force.add(_tempVec);
      }
    }

    // ==========================================================================
    // MAIN PHYSICS UPDATE LOOP
    // ==========================================================================

    function updateNodePhysics(delta) {
      if (nodes3D.length === 0) return;

      // Skip physics in graph mode - nodes should be static
      if (graphState.mode === 'graph') return;

      // Get active physics (transitions from settling to calm over time)
      const physics = getActivePhysics();

      // Clamp delta to prevent instability on lag spikes
      const dt = Math.min(delta, 0.05);

      // Build connection map for damping calculation
      const connectionMap = buildConnectionMap();

      // 1. Reset forces for all nodes
      for (const node of nodes3D) {
        if (!node.userData.force) {
          node.userData.force = new THREE.Vector3();
        }
        if (!node.userData.velocity) {
          node.userData.velocity = new THREE.Vector3();
        }
        node.userData.force.set(0, 0, 0);
      }

      // 2. Calculate repulsion forces (O(n¬≤) but with distance cutoff)
      for (let i = 0; i < nodes3D.length; i++) {
        for (let j = i + 1; j < nodes3D.length; j++) {
          applyRepulsion(nodes3D[i], nodes3D[j], physics);
        }
      }

      // 3. Calculate spring forces for connected nodes
      for (const connection of connections3D) {
        const nodeA = nodes3D.find(n => n.userData.id === connection.userData.nodeA);
        const nodeB = nodes3D.find(n => n.userData.id === connection.userData.nodeB);
        if (nodeA && nodeB) {
          applySpring(nodeA, nodeB, physics);
        }
      }

      // 4. Apply center gravity and boundary forces
      for (const node of nodes3D) {
        applyCenterGravity(node, physics);
        applyBoundary(node, physics);
      }

      // 5. Integrate forces into velocity and position
      for (const node of nodes3D) {
        // F = ma, assume m=1, so a = F
        // Scale force by delta for frame-rate independence
        _forceVec.copy(node.userData.force).multiplyScalar(dt * 60);
        node.userData.velocity.add(_forceVec);

        // Apply connection-weighted damping
        // More connections = less damping = more vibration
        const nodeConnections = connectionMap.get(node.userData.id);
        const connectionCount = nodeConnections ? nodeConnections.size : 0;
        const damping = Math.max(
          physics.minDamping,
          physics.baseDamping - (connectionCount * physics.dampingPerConnection)
        );
        node.userData.velocity.multiplyScalar(damping);

        // Clamp velocity
        const speed = node.userData.velocity.length();
        if (speed > physics.maxVelocity) {
          node.userData.velocity.multiplyScalar(physics.maxVelocity / speed);
        }

        // Update position
        _tempVec.copy(node.userData.velocity).multiplyScalar(dt * 60);
        node.position.add(_tempVec);
      }
    }

    function animateCore(time) {
      if (consciousnessCore) {
        // Breathing scale
        const breatheSpeed = currentPhase === 'idle' ? 0.5 : 1.5;
        const breatheAmount = currentPhase === 'idle' ? 0.05 : 0.15;
        const scale = 1 + Math.sin(time * breatheSpeed) * breatheAmount;
        consciousnessCore.scale.setScalar(scale);
      }

      if (coreGlow) {
        const glowScale = 1 + Math.sin(time * 2) * 0.1;
        coreGlow.scale.setScalar(glowScale);
      }

      if (coreParticles) {
        coreParticles.rotation.y = time * 0.2;
        coreParticles.rotation.x = Math.sin(time * 0.3) * 0.1;
      }

      const outerSphere = scene.userData.outerSphere;
      const middleSphere = scene.userData.middleSphere;

      if (outerSphere) {
        const outerScale = 1 + Math.sin(time * 0.4) * 0.08;
        outerSphere.scale.setScalar(outerScale);
        outerSphere.material.opacity = 0.08 + Math.sin(time * 0.5) * 0.04;
      }

      if (middleSphere) {
        const middleScale = 1 + Math.sin(time * 0.6 + 0.5) * 0.06;
        middleSphere.scale.setScalar(middleScale);
      }
    }

    function animateAmbientParticles(delta) {
      const particles = scene.userData.ambientParticles;
      if (!particles) return;

      const positions = particles.geometry.attributes.position.array;
      const velocities = particles.userData.velocities;

      for (let i = 0; i < velocities.length; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;
        positions[i * 3 + 2] += velocities[i].z;

        // Wrap around
        if (Math.abs(positions[i * 3]) > 50) velocities[i].x *= -1;
        if (Math.abs(positions[i * 3 + 1]) > 50) velocities[i].y *= -1;
        if (Math.abs(positions[i * 3 + 2]) > 50) velocities[i].z *= -1;
      }

      particles.geometry.attributes.position.needsUpdate = true;
    }

    // ==========================================================================
    // FLOW PARTICLES (Phase 2: Energy flowing through connections)
    // ==========================================================================
    const flowParticles = [];
    const MAX_FLOW_PARTICLES = 50;
    const FLOW_SPEED = 0.8;

    function createFlowParticle(connection) {
      if (!connection.userData.curve) return null;

      const geometry = new THREE.SphereGeometry(0.15, 8, 8);
      const type = connection.userData.type;
      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      const material = new THREE.MeshBasicMaterial({
        color: colors.emissive,
        transparent: true,
        opacity: 0.9
      });

      const particle = new THREE.Mesh(geometry, material);
      particle.userData = {
        connection: connection,
        progress: 0,               // 0 to 1 along curve
        speed: FLOW_SPEED + Math.random() * 0.3,
        direction: Math.random() > 0.5 ? 1 : -1
      };

      // Start at random position along curve
      particle.userData.progress = Math.random();

      scene.add(particle);
      flowParticles.push(particle);

      return particle;
    }

    function updateFlowParticles(delta) {
      // Spawn new particles on random connections
      if (flowParticles.length < MAX_FLOW_PARTICLES && connections3D.length > 0) {
        if (Math.random() < 0.03) { // 3% chance per frame
          const conn = connections3D[Math.floor(Math.random() * connections3D.length)];
          createFlowParticle(conn);
        }
      }

      // Update existing particles
      for (let i = flowParticles.length - 1; i >= 0; i--) {
        const particle = flowParticles[i];
        const data = particle.userData;
        const curve = data.connection.userData.curve;

        if (!curve) {
          // Connection was removed, remove particle
          scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          flowParticles.splice(i, 1);
          continue;
        }

        // Move along curve
        data.progress += delta * data.speed * data.direction;

        // Wrap around or remove at ends
        if (data.progress > 1) {
          data.progress = 0;
          data.direction = 1;
        } else if (data.progress < 0) {
          data.progress = 1;
          data.direction = -1;
        }

        // Position on curve
        const point = curve.getPoint(data.progress);
        particle.position.copy(point);

        // Pulsing glow effect
        const pulse = 0.7 + Math.sin(performance.now() * 0.01 + i) * 0.3;
        particle.material.opacity = pulse;

        // Scale based on position (larger in middle)
        const scale = 0.8 + Math.sin(data.progress * Math.PI) * 0.4;
        particle.scale.setScalar(scale);
      }
    }

    // ==========================================================================
    // NODE TRAILS (Phase 2: Motion trails during movement)
    // ==========================================================================
    const nodeTrails = new Map(); // nodeId -> trail mesh
    const TRAIL_LENGTH = 8;
    const TRAIL_FADE_RATE = 0.15;

    function updateNodeTrails(delta) {
      for (const node of nodes3D) {
        const velocity = node.userData.velocity;
        const speed = velocity.length();

        // Only show trails for moving nodes
        if (speed < 0.05) {
          // Remove trail if exists and node stopped
          if (nodeTrails.has(node.userData.id)) {
            const trail = nodeTrails.get(node.userData.id);
            trail.userData.fadingOut = true;
          }
          continue;
        }

        let trail = nodeTrails.get(node.userData.id);

        if (!trail) {
          // Create new trail
          const positions = new Float32Array(TRAIL_LENGTH * 3);
          for (let i = 0; i < TRAIL_LENGTH; i++) {
            positions[i * 3] = node.position.x;
            positions[i * 3 + 1] = node.position.y;
            positions[i * 3 + 2] = node.position.z;
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

          const type = node.userData.type;
          const colors = NODE_COLORS[type] || NODE_COLORS.experience;

          const material = new THREE.LineBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.4
          });

          trail = new THREE.Line(geometry, material);
          trail.userData = {
            history: Array(TRAIL_LENGTH).fill().map(() => node.position.clone()),
            fadingOut: false
          };

          scene.add(trail);
          nodeTrails.set(node.userData.id, trail);
        }

        // Update trail history (shift and add current position)
        const history = trail.userData.history;
        history.shift();
        history.push(node.position.clone());

        // Update geometry
        const positions = trail.geometry.attributes.position.array;
        for (let i = 0; i < TRAIL_LENGTH; i++) {
          positions[i * 3] = history[i].x;
          positions[i * 3 + 1] = history[i].y;
          positions[i * 3 + 2] = history[i].z;
        }
        trail.geometry.attributes.position.needsUpdate = true;

        // Opacity based on speed
        trail.material.opacity = Math.min(0.5, speed * 0.8);
      }

      // Fade out and remove orphaned trails
      for (const [nodeId, trail] of nodeTrails) {
        if (trail.userData.fadingOut) {
          trail.material.opacity -= TRAIL_FADE_RATE * delta * 60;
          if (trail.material.opacity <= 0) {
            scene.remove(trail);
            trail.geometry.dispose();
            trail.material.dispose();
            nodeTrails.delete(nodeId);
          }
        }
      }
    }

    // ==========================================================================
    // GRAPH MODE FUNCTIONS (Living Memory Visualization)
    // ==========================================================================

    // Heat map configuration
    const HEAT_MAP_CONFIG = {
        // Color gradient from cool (rarely accessed) to hot (frequently accessed)
        colors: [
            { threshold: 0, color: new THREE.Color(0x3b82f6) },   // Blue - cold (0 accesses)
            { threshold: 2, color: new THREE.Color(0x22c55e) },   // Green - warm (2+ accesses)
            { threshold: 5, color: new THREE.Color(0xeab308) },   // Yellow - warmer (5+ accesses)
            { threshold: 10, color: new THREE.Color(0xf97316) },  // Orange - hot (10+ accesses)
            { threshold: 20, color: new THREE.Color(0xef4444) },  // Red - very hot (20+ accesses)
            { threshold: 50, color: new THREE.Color(0xec4899) }   // Pink/magenta - burning (50+ accesses)
        ],
        // Whether to blend with type color or override completely
        blendWithType: true,
        blendRatio: 0.6  // 60% heat color, 40% type color
    };

    /**
     * Calculate heat color based on access count
     */
    function calculateHeatColor(accessCount, typeColor) {
        // Find the appropriate heat color based on access count
        let heatColor = HEAT_MAP_CONFIG.colors[0].color;
        for (const level of HEAT_MAP_CONFIG.colors) {
            if (accessCount >= level.threshold) {
                heatColor = level.color;
            }
        }

        // Optionally blend with the type color
        if (HEAT_MAP_CONFIG.blendWithType && typeColor) {
            const blended = new THREE.Color(typeColor);
            blended.lerp(heatColor, HEAT_MAP_CONFIG.blendRatio);
            return blended;
        }

        return heatColor;
    }

    /**
     * Get heat intensity (0-1) based on access count
     */
    function getHeatIntensity(accessCount) {
        // Logarithmic scale for intensity
        return Math.min(1, Math.log(1 + accessCount) / Math.log(51));
    }

    /**
     * Update heat colors for nodes after access counts change
     * Called after MEMORIES_ACCESSED event to refresh visual heat
     */
    function updateNodeHeatColors(accessedNodeIds) {
        if (graphState.mode !== 'graph') return;

        for (const nodeId of accessedNodeIds) {
            const mesh = graphState.nodeIdToMesh.get(nodeId);
            if (!mesh) continue;

            // Increment local access count
            const currentCount = (mesh.userData.accessCount || 0) + 1;
            mesh.userData.accessCount = currentCount;

            // Get the node type colors
            const type = mesh.userData.type || 'experience';
            const colors = NODE_COLORS[type] || NODE_COLORS.experience;

            // Recalculate heat color
            const newHeatColor = calculateHeatColor(currentCount, colors.color);
            mesh.material.color.copy(newHeatColor);
            mesh.userData.baseColor = newHeatColor.getHex();

            // Update opacity
            mesh.material.opacity = 0.85 + getHeatIntensity(currentCount) * 0.15;
        }
    }

    /**
     * Refresh graph with latest data from API (updates access counts)
     */
    async function refreshGraphData() {
        if (graphState.mode !== 'graph') return;

        try {
            const response = await fetch('/api/graph?limit=1000');
            if (!response.ok) return;

            const data = await response.json();

            // Update access counts for existing nodes
            for (const nodeData of data.nodes) {
                const mesh = graphState.nodeIdToMesh.get(nodeData.id);
                if (!mesh) continue;

                const newCount = nodeData.access_count || 0;
                if (newCount !== mesh.userData.accessCount) {
                    mesh.userData.accessCount = newCount;
                    const type = mesh.userData.type || 'experience';
                    const colors = NODE_COLORS[type] || NODE_COLORS.experience;
                    const newHeatColor = calculateHeatColor(newCount, colors.color);
                    mesh.material.color.copy(newHeatColor);
                    mesh.userData.baseColor = newHeatColor.getHex();
                    mesh.material.opacity = 0.85 + getHeatIntensity(newCount) * 0.15;
                }
            }

            console.log('Graph heat data refreshed');
        } catch (error) {
            console.error('Error refreshing graph data:', error);
        }
    }

    /**
     * Fetch the full graph from the API
     */
    async function fetchFullGraph() {
        try {
            updateStatus('Loading graph...', 'amber');
            const response = await fetch('/api/graph?limit=1000');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const data = await response.json();

            // Store in persistent state
            graphState.nodes.clear();
            graphState.relationships.clear();

            data.nodes.forEach(n => graphState.nodes.set(n.id, n));
            data.relationships.forEach(r => graphState.relationships.set(r.id, r));

            graphState.loaded = true;
            graphState.lastFetch = Date.now();

            console.log(`Graph loaded: ${data.nodes.length} nodes, ${data.relationships.length} relationships`);
            updateStatus(`Loaded ${data.nodes.length} nodes`, 'green');

            return data;
        } catch (error) {
            console.error('Error fetching graph:', error);
            updateStatus('Graph load failed', 'rose');
            return null;
        }
    }

    /**
     * Calculate initial position for a node.
     * EMERGENT STRUCTURE: Random initial positions - physics simulation creates structure
     * based on connection topology. Highly connected nodes naturally gravitate toward
     * center; isolated nodes drift outward.
     */
    function calculateGraphPosition(node, index, totalNodes) {
        // Use node ID hash for deterministic but distributed initial positions
        // This prevents nodes from stacking on reload while avoiding randomness
        const hash = hashString(node.id || String(index));
        const theta = (hash % 1000) / 1000 * Math.PI * 2;  // Angle around Y axis
        const phi = ((hash >> 10) % 1000) / 1000 * Math.PI; // Angle from Y axis

        // Initial radius - spread out, physics will compress connected clusters
        const baseRadius = 30 + (index % 20) * 2;

        // Spherical distribution
        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
        const y = (baseRadius * Math.cos(phi)) * 0.5;  // Flatten slightly
        const z = baseRadius * Math.sin(phi) * Math.sin(theta);

        return { x, y, z };
    }

    /**
     * Simple string hash for deterministic positioning
     */
    function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
    }

    /**
     * Create a node mesh for graph mode.
     * EMERGENT STRUCTURE: Size scales dynamically based on connection count.
     * Experience nodes (memories) use crystal geometry; all others use spheres.
     * Color indicates type for visual identity; structure emerges from connections.
     */
    function createGraphNode(nodeData, position) {
        // Prevent duplicate nodes - check if node with this ID already exists
        if (graphState.nodeIdToMesh.has(nodeData.id)) {
            return graphState.nodeIdToMesh.get(nodeData.id);
        }
        const existingNode = nodes3D.find(n => n.userData.id === nodeData.id);
        if (existingNode) {
            return existingNode;
        }

        const type = nodeData.type || 'experience';
        const importance = nodeData.importance || 0.5;  // Default importance

        // Use getCustomTypeColor for dynamic color assignment (handles both system and custom types)
        const colors = getCustomTypeColor(type);
        const accessCount = nodeData.access_count || 0;

        // EMERGENT SIZE: Base size is uniform; connection count scales it dynamically
        // Initial size is small; updateNodeScaleByConnections will grow important nodes
        const baseSize = 0.6;
        const heatBonus = getHeatIntensity(accessCount) * 0.3;
        const size = baseSize + heatBonus;

        // GEOMETRY: Experience nodes (memories) use crystal shape; others use spheres
        const typeLower = type.toLowerCase();
        let geometry;
        if (typeLower === 'experience') {
            // Memory crystals - octahedron for crystalline appearance
            geometry = new THREE.OctahedronGeometry(size * 1.2, 0);
        } else {
            // All other types use spheres (beliefs, desires, reflections, etc.)
            geometry = new THREE.SphereGeometry(size, 12, 12);
        }

        // Color indicates type for visual identity
        const nodeColor = new THREE.Color(colors.color);

        const material = new THREE.MeshBasicMaterial({
            color: nodeColor,
            transparent: true,
            opacity: 0.85 + getHeatIntensity(accessCount) * 0.15
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(position.x, position.y, position.z);

        // Graph mode: static nodes, no initial velocity
        const initialVelocity = new THREE.Vector3(0, 0, 0);

        mesh.userData = {
            id: nodeData.id,
            type: type,
            content: nodeData.content,
            importance: importance,
            accessCount: accessCount,
            nodeData: nodeData,
            baseScale: 1,
            baseColor: nodeColor.getHex(),  // Store for restoration after highlight
            targetScale: new THREE.Vector3(1, 1, 1),
            velocity: initialVelocity,
            force: new THREE.Vector3(0, 0, 0),
            createdAt: Date.now(),
            isGraphNode: true  // Flag to identify graph mode nodes
        };

        scene.add(mesh);
        nodes3D.push(mesh);
        graphState.nodeIdToMesh.set(nodeData.id, mesh);
        connectionCounts.set(nodeData.id, 0);

        return mesh;
    }

    /**
     * Create a relationship line between two nodes
     * Uses straight, thin lines for sacred geometry aesthetic
     */
    function createRelationshipLine(relationship) {
        const sourceMesh = graphState.nodeIdToMesh.get(relationship.source_id);
        const targetMesh = graphState.nodeIdToMesh.get(relationship.target_id);

        if (!sourceMesh || !targetMesh) return null;

        const style = RELATIONSHIP_STYLES[relationship.type] || RELATIONSHIP_STYLES.default;

        // Sacred geometry: straight lines connecting nodes directly
        const start = sourceMesh.position.clone();
        const end = targetMesh.position.clone();

        // Create geometry with two points for a straight line
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
            start.x, start.y, start.z,
            end.x, end.y, end.z
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Thin, luminous lines for sacred geometry effect
        const material = new THREE.LineBasicMaterial({
            color: style.color,
            transparent: true,
            opacity: style.opacity * 0.8,  // Slightly more subtle
            linewidth: 1  // Note: WebGL typically renders as 1px regardless
        });

        const line = new THREE.Line(geometry, material);
        line.userData = {
            relationshipId: relationship.id,
            type: relationship.type,
            sourceId: relationship.source_id,
            targetId: relationship.target_id,
            sourceMesh: sourceMesh,
            targetMesh: targetMesh,
            isRelationshipLine: true,
            isSacredGeometry: true  // Flag for sacred geometry style
        };

        scene.add(line);
        graphState.relationshipLines.push(line);

        // Update connection counts for both nodes
        incrementConnectionCount(relationship.source_id);
        incrementConnectionCount(relationship.target_id);

        return line;
    }

    /**
     * Render the full graph from Neo4j
     */
    async function renderFullGraph() {
        console.log('Rendering full graph...');
        updateStatus('Rendering graph...', 'amber');

        // Fetch graph data
        const data = await fetchFullGraph();
        if (!data) return;

        // Clear existing event-mode nodes (but keep cat and core)
        clearEventModeNodes();

        // Group nodes by type for positioning
        // Filter: skip absorbed experiences (they live inside crystals)
        const seenIds = new Set();
        const nodesByType = {};
        let absorbedCount = 0;
        let crystalCount = 0;

        data.nodes.forEach(node => {
            const type = node.type || 'experience';

            // Skip absorbed experiences - they're part of crystals now
            if (isAbsorbedExperience(node)) {
                absorbedCount++;
                return;
            }

            // Deduplicate by ID
            if (seenIds.has(node.id)) return;
            seenIds.add(node.id);

            if (!nodesByType[type]) nodesByType[type] = [];
            nodesByType[type].push(node);
        });

        // Create nodes with type-based positioning
        // Only crystallized beliefs/desires (2+ sources) render as crystals
        let totalCreated = 0;
        for (const [type, typeNodes] of Object.entries(nodesByType)) {
            typeNodes.forEach((node, index) => {
                const pos = calculateGraphPosition(node, index, typeNodes.length);

                if (shouldRenderAsCrystal(node)) {
                    createCrystalNode(node, pos);
                    crystalCount++;
                } else {
                    createGraphNode(node, pos);
                }
                totalCreated++;
            });
        }

        console.log(`Created ${totalCreated} graph nodes (${crystalCount} crystals, ${absorbedCount} absorbed experiences)`);

        // Create relationship lines (skip relationships to absorbed nodes)
        let relsCreated = 0;
        data.relationships.forEach(rel => {
            if (createRelationshipLine(rel)) {
                relsCreated++;
            }
        });

        console.log(`Created ${relsCreated} relationship lines`);

        // Update counts
        nodeCountEl.textContent = nodes3D.length;

        // Set mode
        graphState.mode = 'graph';
        updateStatus(`Graph: ${totalCreated} nodes, ${relsCreated} rels, ${crystalCount} crystals`, 'green');

        // Trigger visual refresh
        invalidateConnectionMap();
    }

    /**
     * Clear event-mode nodes (keep core, cat)
     */
    function clearEventModeNodes() {
        // Remove all existing nodes
        for (const node of nodes3D) {
            scene.remove(node);
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
            if (node.userData?.glowMesh) {
                scene.remove(node.userData.glowMesh);
            }
        }
        nodes3D.length = 0;

        // Remove all connections
        for (const conn of connections3D) {
            scene.remove(conn);
            if (conn.geometry) conn.geometry.dispose();
            if (conn.material) conn.material.dispose();
        }
        connections3D.length = 0;

        // Remove all relationship lines
        for (const line of graphState.relationshipLines) {
            scene.remove(line);
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
        }
        graphState.relationshipLines.length = 0;

        // Clear maps
        connectionCounts.clear();
        graphState.nodeIdToMesh.clear();
    }

    /**
     * Update relationship line positions when nodes move
     */
    function updateRelationshipPositions() {
        for (const line of graphState.relationshipLines) {
            const sourceMesh = line.userData.sourceMesh;
            const targetMesh = line.userData.targetMesh;

            if (!sourceMesh || !targetMesh) continue;

            // Sacred geometry: update straight line positions
            const start = sourceMesh.position;
            const end = targetMesh.position;

            // Update BufferGeometry positions directly (efficient)
            const positions = line.geometry.attributes.position.array;
            positions[0] = start.x;
            positions[1] = start.y;
            positions[2] = start.z;
            positions[3] = end.x;
            positions[4] = end.y;
            positions[5] = end.z;
            line.geometry.attributes.position.needsUpdate = true;
        }
    }

    /**
     * Find a node mesh by its ID
     */
    function findNodeById(id) {
        return graphState.nodeIdToMesh.get(id) || nodes3D.find(n => n.userData.id === id);
    }

    /**
     * Switch between event mode and graph mode
     */
    async function setVisualizationMode(mode) {
        // Clear any type highlighting when switching modes
        clearTypeHighlight();

        const heatLegend = document.getElementById('heat-legend');

        if (mode === 'graph') {
            await renderFullGraph();
            // Show heat legend in graph mode
            if (heatLegend) heatLegend.classList.remove('hidden');
            // Hide cat model in graph mode
            if (catModel) catModel.visible = false;
        } else {
            // Event mode - show all nodes except experiences and reflections
            await loadEventModeNodes();
            updateStatus('Event mode', 'blue');
            // Hide heat legend in event mode
            if (heatLegend) heatLegend.classList.add('hidden');
            // Show cat model in event mode
            if (catModel) catModel.visible = true;
        }
    }

    // ==========================================================================
    // REFLECTION HIGHLIGHTING (Phase 3)
    // ==========================================================================

    // Track currently highlighted nodes for cleanup
    const highlightedNodes = new Set();

    /**
     * Highlight nodes being accessed during reflection
     */
    function highlightAccessedNodes(nodeIds) {
        // Clear previous highlights first
        clearNodeHighlights();

        const highlightColor = 0xffffff;  // White highlight

        for (const nodeId of nodeIds) {
            const mesh = graphState.nodeIdToMesh.get(nodeId);
            if (!mesh) continue;

            // Store original state
            if (!mesh.userData.originalColor) {
                mesh.userData.originalColor = mesh.material.color.getHex();
                mesh.userData.originalOpacity = mesh.material.opacity;
                mesh.userData.originalScale = mesh.scale.x;
            }

            // Brighten the node color by blending with white
            const originalColor = new THREE.Color(mesh.userData.originalColor);
            const brightened = originalColor.clone().lerp(new THREE.Color(highlightColor), 0.4);
            mesh.material.color.copy(brightened);
            mesh.material.opacity = 1.0;

            // Mark as highlighted
            mesh.userData.isHighlighted = true;
            mesh.userData.highlightPulsePhase = Math.random() * Math.PI * 2;

            highlightedNodes.add(mesh);

            // Create highlight ring effect
            createHighlightRing(mesh);
        }

        console.log(`Highlighted ${highlightedNodes.size} nodes`);
    }

    /**
     * Create a pulsing ring around a highlighted node
     */
    function createHighlightRing(mesh) {
        const ringGeometry = new THREE.RingGeometry(1.5, 1.8, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x60a5fa,  // Blue highlight
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(mesh.position);
        ring.lookAt(camera.position);
        ring.userData.isHighlightRing = true;
        ring.userData.parentMesh = mesh;
        ring.userData.createdAt = Date.now();

        scene.add(ring);
        mesh.userData.highlightRing = ring;
    }

    /**
     * Clear all node highlights
     */
    function clearNodeHighlights() {
        for (const mesh of highlightedNodes) {
            if (!mesh) continue;

            // Restore original color and opacity
            if (mesh.userData.originalColor !== undefined) {
                mesh.material.color.setHex(mesh.userData.originalColor);
            }
            if (mesh.userData.originalOpacity !== undefined) {
                mesh.material.opacity = mesh.userData.originalOpacity;
            }
            if (mesh.userData.originalScale !== undefined) {
                mesh.scale.setScalar(mesh.userData.originalScale);
            }

            mesh.userData.isHighlighted = false;

            // Remove highlight ring
            if (mesh.userData.highlightRing) {
                scene.remove(mesh.userData.highlightRing);
                mesh.userData.highlightRing.geometry.dispose();
                mesh.userData.highlightRing.material.dispose();
                mesh.userData.highlightRing = null;
            }
        }

        highlightedNodes.clear();
    }

    /**
     * Update highlight animations (called in render loop)
     */
    function updateHighlightAnimations() {
        const time = Date.now() * 0.001;

        for (const mesh of highlightedNodes) {
            if (!mesh || !mesh.userData.isHighlighted) continue;

            // Pulsing scale effect
            const phase = mesh.userData.highlightPulsePhase || 0;
            const pulse = 1 + 0.15 * Math.sin(time * 3 + phase);
            const baseScale = mesh.userData.originalScale || 1;
            mesh.scale.setScalar(baseScale * pulse);

            // Update highlight ring
            if (mesh.userData.highlightRing) {
                const ring = mesh.userData.highlightRing;
                ring.position.copy(mesh.position);
                ring.lookAt(camera.position);

                // Pulsing opacity
                const ringAge = (Date.now() - ring.userData.createdAt) / 1000;
                const ringPulse = 0.4 + 0.3 * Math.sin(ringAge * 4);
                ring.material.opacity = ringPulse;

                // Expanding ring effect
                const ringScale = 1 + 0.2 * Math.sin(ringAge * 2);
                ring.scale.setScalar(ringScale);
            }
        }
    }

    // ==========================================================================
    // ANIMATION HELPERS
    // ==========================================================================
    function animateValue(obj, prop, target, duration, callback, easing = easeOutCubic) {
      const start = obj[prop];
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easing(progress);
        const value = start + (target - start) * easedProgress;

        obj[prop] = value;
        if (callback) callback(value);

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      update();
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function easeOutElastic(t) {
      const c4 = (2 * Math.PI) / 3;
      return t === 0 ? 0 : t === 1 ? 1 :
        Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    function fadeOutAndRemove(object) {
      // Animate scale down
      animateValue({ scale: object.scale.x }, 'scale', 0, 400, (val) => {
        object.scale.setScalar(val);
      });
      // Also scale down glow mesh if present
      if (object.userData?.glowMesh) {
        const glow = object.userData.glowMesh;
        animateValue({ scale: glow.scale.x }, 'scale', 0, 400, (val) => {
          glow.scale.setScalar(val);
        });
        setTimeout(() => {
          scene.remove(glow);
          if (glow.geometry) glow.geometry.dispose();
          if (glow.material) glow.material.dispose();
        }, 400);
      }
      setTimeout(() => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
      }, 400);
    }

    // ==========================================================================
    // LEARNING SYSTEM NODE UPDATES
    // ==========================================================================

    /**
     * Update prediction node visual state based on validation result
     */
    function updatePredictionNode(predictionId, status) {
      if (!predictionId) return;

      const node = nodes3D.find(n => n.userData?.id === predictionId);
      if (!node) return;

      // Update color based on status
      let newColor, newEmissive;
      switch (status) {
        case 'validated':
          newColor = 0x22c55e;  // Green
          newEmissive = 0x4ade80;
          break;
        case 'falsified':
          newColor = 0xef4444;  // Red
          newEmissive = 0xf87171;
          break;
        default:
          return;  // Keep pending color
      }

      // Animate color change
      node.material.color.setHex(newColor);
      node.material.emissive.setHex(newEmissive);

      // Brief scale pulse to draw attention
      const originalScale = node.scale.x;
      node.scale.setScalar(originalScale * 1.5);
      setTimeout(() => {
        node.scale.setScalar(originalScale);
      }, 300);

      // Update userData
      node.userData.status = status;
    }

    /**
     * Update task node visual state based on execution progress
     */
    function updateTaskNode(taskId, status) {
      if (!taskId) return;

      const node = nodes3D.find(n => n.userData?.id === taskId);
      if (!node) return;

      // Update color based on status
      let newColor, newEmissive;
      switch (status) {
        case 'in_progress':
          newColor = 0x3b82f6;  // Blue
          newEmissive = 0x60a5fa;
          break;
        case 'completed':
          newColor = 0x22c55e;  // Green
          newEmissive = 0x4ade80;
          break;
        case 'failed':
          newColor = 0xef4444;  // Red
          newEmissive = 0xf87171;
          break;
        default:
          return;
      }

      node.material.color.setHex(newColor);
      node.material.emissive.setHex(newEmissive);

      // Brief scale pulse
      const originalScale = node.scale.x;
      node.scale.setScalar(originalScale * 1.3);
      setTimeout(() => {
        node.scale.setScalar(originalScale);
      }, 300);

      node.userData.status = status;
    }

    /**
     * Update belief node opacity based on new confidence value
     */
    function updateBeliefConfidence(beliefId, newConfidence) {
      if (!beliefId || newConfidence === undefined) return;

      const node = nodes3D.find(n => n.userData?.id === beliefId && n.userData?.type === 'belief');
      if (!node) return;

      // Adjust opacity based on confidence (0.4 to 1.0)
      const opacity = 0.4 + (newConfidence * 0.6);
      node.material.opacity = opacity;

      // Adjust emissive intensity
      const emissiveIntensity = 0.3 + (newConfidence * 0.7);
      node.material.emissiveIntensity = emissiveIntensity;

      // Brief flash to indicate change
      const colors = NODE_COLORS.belief;
      node.material.emissive.setHex(0xffffff);
      setTimeout(() => {
        node.material.emissive.setHex(colors.emissive);
      }, 200);

      node.userData.confidence = newConfidence;
    }

    // ==========================================================================
    // INTERACTION (Phase 4: Enhanced)
    // ==========================================================================
    function onMouseMove(event) {
      if (isTransitioning) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast for hover
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D);

      if (intersects.length > 0) {
        const node = intersects[0].object;
        if (hoveredNode !== node) {
          hoveredNode = node;
          showTooltip(event, node);
        }
        moveTooltip(event);
        document.body.style.cursor = 'pointer';
      } else {
        if (hoveredNode) {
          hoveredNode = null;
          hideTooltip();
        }
        document.body.style.cursor = 'default';
      }
    }

    function onMouseClick(event) {
      if (isTransitioning) return;

      if (hoveredNode) {
        selectNode(hoveredNode);
      } else {
        // Click on empty space - deselect
        deselectNode();
      }
    }

    // Double-click to fly directly to a node
    function onDoubleClick(event) {
      if (isTransitioning) return;

      // Raycast to find node
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D);

      if (intersects.length > 0) {
        const node = intersects[0].object;
        flyToNode(node);
      }
    }

    // Fly camera directly to a node (gets closer than selectNode)
    function flyToNode(node) {
      if (isTransitioning) return;

      const targetPos = node.position.clone();
      const direction = targetPos.clone().sub(camera.position).normalize();
      const newCameraPos = targetPos.clone().sub(direction.multiplyScalar(15));

      showCameraIndicator('Flying to node...');
      controls.autoRotate = false;

      animateCameraTo(newCameraPos, targetPos, 1500, () => {
        hideCameraIndicator();
        showDetailPanel(node);
        selectedNode = node;
        selectedNodeIndex = nodes3D.indexOf(node);
      });
    }

    // Phase 4: Node selection with detail panel
    function selectNode(node) {
      if (isTransitioning) return;

      selectedNode = node;
      selectedNodeIndex = nodes3D.indexOf(node);

      // Focus camera on node
      const targetPos = node.position.clone();
      const direction = targetPos.clone().normalize();
      const cameraOffset = direction.multiplyScalar(-25).add(new THREE.Vector3(0, 8, 0));
      const newCameraPos = targetPos.clone().add(cameraOffset);

      // Show camera indicator
      showCameraIndicator('Focusing on ' + (NODE_COLORS[node.userData.type]?.label || 'Node'));

      // Animate camera
      controls.autoRotate = false;
      animateCameraTo(newCameraPos, targetPos, 1200, () => {
        hideCameraIndicator();
        showDetailPanel(node);
      });
    }

    function deselectNode() {
      selectedNode = null;
      selectedNodeIndex = -1;
      hideDetailPanel();
      resetCamera();
    }

    // Type filtering: Highlight all nodes of a specific type
    function highlightNodesByType(type) {
      // Toggle off if same type clicked
      if (highlightedType === type) {
        clearTypeHighlight();
        return;
      }

      highlightedType = type;

      // Update UI active state
      document.querySelectorAll('.stat-type').forEach(el => {
        el.classList.toggle('active', el.dataset.type === type);
      });

      // Process event mode nodes (nodes3D array)
      nodes3D.forEach(node => {
        const nodeType = node.userData.type?.toLowerCase();
        const isMatch = nodeType === type;

        if (isMatch) {
          // Highlight: increase emissive, full opacity
          node.material.emissive.setHex(0x444444);
          node.material.opacity = 1.0;
        } else {
          // Dim: reduce opacity, no emissive
          node.material.emissive.setHex(0x000000);
          node.material.opacity = 0.15;
        }
      });

      // Also handle graph mode nodes if active
      if (graphState.nodeIdToMesh) {
        Object.values(graphState.nodeIdToMesh).forEach(mesh => {
          const nodeType = mesh.userData.type?.toLowerCase();
          const isMatch = nodeType === type;

          if (isMatch) {
            mesh.material.emissive.setHex(0x444444);
            mesh.material.opacity = 1.0;
          } else {
            mesh.material.emissive.setHex(0x000000);
            mesh.material.opacity = 0.15;
          }
        });
      }
    }

    // Clear type highlighting and restore normal appearance
    function clearTypeHighlight() {
      highlightedType = null;

      // Clear UI active state
      document.querySelectorAll('.stat-type').forEach(el => {
        el.classList.remove('active');
      });

      // Restore event mode nodes
      nodes3D.forEach(node => {
        const colors = NODE_COLORS[node.userData.type?.toLowerCase()] || NODE_COLORS.default;
        node.material.emissive.setHex(0x000000);
        node.material.opacity = colors.opacity || 0.9;
      });

      // Restore graph mode nodes
      if (graphState.nodeIdToMesh) {
        Object.values(graphState.nodeIdToMesh).forEach(mesh => {
          const colors = NODE_COLORS[mesh.userData.type?.toLowerCase()] || NODE_COLORS.default;
          mesh.material.emissive.setHex(0x000000);
          mesh.material.opacity = colors.opacity || 0.9;
        });
      }
    }

    // Update rendered node counts to match actual nodes3D array
    function updateRenderedCounts() {
      const counts = { belief: 0, desire: 0, reflection: 0, experience: 0 };

      nodes3D.forEach(node => {
        const type = node.userData.type?.toLowerCase();
        if (counts.hasOwnProperty(type)) {
          counts[type]++;
        }
      });

      document.getElementById('belief-count').textContent = counts.belief;
      document.getElementById('desire-count').textContent = counts.desire;
      document.getElementById('reflection-count').textContent = counts.reflection;
      document.getElementById('exp-count').textContent = counts.experience;
      document.getElementById('node-count').textContent = nodes3D.length;
    }

    // Phase 4: Enhanced camera transition with callback
    function animateCameraTo(position, target, duration, onComplete) {
      isTransitioning = true;
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Cinematic easing (ease-in-out with overshoot)
        const eased = easeOutExpo(progress);

        camera.position.lerpVectors(startPos, position, eased);
        controls.target.lerpVectors(startTarget, target, eased);

        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          isTransitioning = false;
          if (onComplete) onComplete();
        }
      }

      update();
    }

    // Phase 4: Better easing function
    function easeOutExpo(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    // Phase 4: Reset camera to default view
    function resetCamera() {
      showCameraIndicator('Resetting view');
      animateCameraTo(
        new THREE.Vector3(0, 30, 80),
        new THREE.Vector3(0, 0, 0),
        1000,
        () => {
          hideCameraIndicator();
          controls.autoRotate = true;
        }
      );
    }

    // Phase 4: Detail panel functions
    function showDetailPanel(node) {
      const data = node.userData;

      // If this is a crystal node (actually rendered as crystal), show the crystal modal
      if (data.isCrystal) {
        showCrystalModal(node);
        return;
      }

      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;
      const colorHex = `#${colors.color.toString(16).padStart(6, '0')}`;

      // Set panel content
      detailTypeDot.style.backgroundColor = colorHex;
      detailType.textContent = colors.label;
      detailType.style.color = colorHex;
      detailContent.textContent = data.content || 'No content available';

      // Importance
      const importance = Math.round((data.importance || 0.5) * 100);
      detailImportance.textContent = importance + '%';
      detailImportanceBar.style.width = importance + '%';
      detailImportanceBar.style.backgroundColor = colorHex;

      // Count connections
      const connectionCount = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      detailConnections.textContent = connectionCount;

      // Created time
      detailCreated.textContent = data.created || 'Just now';

      // Related nodes
      updateRelatedNodes(node);

      // Show panel with animation
      detailPanel.classList.add('visible');
    }

    function hideDetailPanel() {
      detailPanel.classList.remove('visible');
    }

    // ==========================================================================
    // CRYSTAL MODAL FUNCTIONS
    // ==========================================================================

    /**
     * Show crystal modal with source experiences
     */
    async function showCrystalModal(node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.belief;
      const colorHex = `#${colors.color.toString(16).padStart(6, '0')}`;

      // Set header
      crystalModalDot.style.backgroundColor = colorHex;
      crystalModalType.textContent = `${colors.label} Crystal`;
      crystalModalType.style.color = colorHex;

      const confidence = data.confidence || data.intensity || 0.5;
      crystalModalConfidence.textContent = `Confidence: ${Math.round(confidence * 100)}%`;

      // Set content
      crystalModalContent.textContent = data.content || 'No content available';

      // Show loading state for sources
      crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">Loading source experiences...</div>';
      crystalSourceCount.textContent = '...';

      // Display quantum seed if available
      const quantumSeed = data.nodeData?.quantum_seed || data.quantum_seed;
      if (quantumSeed && quantumSeed.length > 0) {
        crystalQuantumSeed.textContent = quantumSeed.slice(0, 4).map(v => v.toFixed(3)).join(', ') + '...';
      } else {
        crystalQuantumSeed.textContent = 'Fallback RNG (ID-based)';
      }

      // Show modal
      crystalModal.classList.remove('hidden');
      crystalModal.classList.add('flex');

      // Fetch detailed data including source experiences
      try {
        const response = await fetch(`/api/belief/${data.id}`);
        if (response.ok) {
          const beliefData = await response.json();
          renderCrystalSources(beliefData.source_experiences || []);
        } else {
          // Fallback for desires or if endpoint fails
          crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">Source experiences not available for this crystal type.</div>';
          crystalSourceCount.textContent = '0';
        }
      } catch (err) {
        console.error('Failed to fetch crystal details:', err);
        crystalSourcesList.innerHTML = '<div class="text-xs text-red-400">Failed to load sources</div>';
        crystalSourceCount.textContent = '?';
      }
    }

    /**
     * Render source experiences in the crystal modal
     */
    function renderCrystalSources(sources) {
      crystalSourceCount.textContent = sources.length;

      if (sources.length === 0) {
        crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">No source experiences recorded.</div>';
        return;
      }

      crystalSourcesList.innerHTML = sources.map((exp, index) => {
        const typeColor = NODE_COLORS[exp.type]?.color || NODE_COLORS.experience.color;
        const colorHex = `#${typeColor.toString(16).padStart(6, '0')}`;
        const timestamp = exp.created_at ? new Date(exp.created_at).toLocaleString() : 'Unknown time';

        return `
          <div class="crystal-source-item bg-slate-800/50 rounded-lg p-3 border border-slate-700/30 hover:border-slate-600/50 transition-colors">
            <div class="flex items-start gap-2">
              <div class="w-2 h-2 rounded-full mt-1.5 flex-shrink-0" style="background-color: ${colorHex}"></div>
              <div class="flex-1 min-w-0">
                <div class="text-xs text-slate-300 leading-relaxed">${exp.content || 'No content'}</div>
                <div class="text-[10px] text-slate-600 mt-1 flex items-center gap-2">
                  <span class="uppercase">${exp.type || 'experience'}</span>
                  <span>‚Ä¢</span>
                  <span>${timestamp}</span>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    /**
     * Hide crystal modal
     */
    function hideCrystalModal() {
      crystalModal.classList.add('hidden');
      crystalModal.classList.remove('flex');
    }

    function updateRelatedNodes(node) {
      const data = node.userData;
      const related = [];

      // Find connected nodes
      for (const conn of connections3D) {
        let relatedId = null;
        if (conn.userData.nodeA === data.id) relatedId = conn.userData.nodeB;
        if (conn.userData.nodeB === data.id) relatedId = conn.userData.nodeA;

        if (relatedId) {
          const relatedNode = nodes3D.find(n => n.userData.id === relatedId);
          if (relatedNode && related.length < 5) {
            related.push(relatedNode);
          }
        }
      }

      // Render related nodes
      detailRelatedList.innerHTML = related.length > 0
        ? related.map(n => {
            const c = NODE_COLORS[n.userData.type] || NODE_COLORS.experience;
            const hex = `#${c.color.toString(16).padStart(6, '0')}`;
            return `
              <div class="flex items-center gap-2 text-xs cursor-pointer hover:bg-slate-100 p-1 rounded"
                   onclick="selectNodeById('${n.userData.id}')">
                <div class="w-2 h-2 rounded-full" style="background: ${hex}"></div>
                <span class="text-slate-700 truncate">${(n.userData.content || '').slice(0, 40)}</span>
              </div>
            `;
          }).join('')
        : '<div class="text-xs text-slate-500">No connections yet</div>';
    }

    // Phase 4: Camera indicator
    function showCameraIndicator(text) {
      cameraIndicatorText.textContent = text;
      cameraIndicator.classList.add('visible');
    }

    function hideCameraIndicator() {
      cameraIndicator.classList.remove('visible');
    }

    // Phase 4: Keyboard navigation
    // ==========================================================================
    // NAVIGATION CONTROLS (Hybrid System)
    // ==========================================================================
    function onKeyDown(event) {
      // Skip navigation controls when typing in input fields
      const target = event.target;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return; // Let the input handle the keypress
      }

      const key = event.key.toLowerCase();

      // Track WASD + Q/E for movement
      if (key === 'w') { NAV.keys.w = true; event.preventDefault(); }
      if (key === 'a') { NAV.keys.a = true; event.preventDefault(); }
      if (key === 's') { NAV.keys.s = true; event.preventDefault(); }
      if (key === 'd') { NAV.keys.d = true; event.preventDefault(); }
      if (key === 'q') { NAV.keys.q = true; event.preventDefault(); }
      if (key === 'e') { NAV.keys.e = true; event.preventDefault(); }
      if (event.key === 'Shift') { NAV.keys.shift = true; }

      // Action keys
      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          cycleNodes(1);
          break;
        case 'ArrowDown':
          event.preventDefault();
          cycleNodes(-1);
          break;
        case 'Escape':
          event.preventDefault();
          deselectNode();
          break;
        case ' ':
          event.preventDefault();
          togglePause();
          break;
        case 'r':
        case 'R':
          event.preventDefault();
          controls.autoRotate = !controls.autoRotate;
          showCameraIndicator(controls.autoRotate ? 'Auto-rotation ON' : 'Auto-rotation OFF');
          setTimeout(hideCameraIndicator, 1500);
          break;
        case 'f':
        case 'F':
          event.preventDefault();
          toggleFlyMode();
          break;
        case '1': case '2': case '3': case '4': case '5':
          event.preventDefault();
          goToPreset(parseInt(event.key));
          break;
        case 'Home':
          event.preventDefault();
          goToPreset(1); // Default view
          break;
      }
    }

    function onKeyUp(event) {
      const key = event.key.toLowerCase();

      // Release WASD + Q/E
      if (key === 'w') NAV.keys.w = false;
      if (key === 'a') NAV.keys.a = false;
      if (key === 's') NAV.keys.s = false;
      if (key === 'd') NAV.keys.d = false;
      if (key === 'q') NAV.keys.q = false;
      if (key === 'e') NAV.keys.e = false;
      if (event.key === 'Shift') NAV.keys.shift = false;
    }

    // Toggle between Orbit and Fly modes
    function toggleFlyMode() {
      NAV.flyMode = !NAV.flyMode;
      controls.enabled = !NAV.flyMode;

      if (NAV.flyMode) {
        controls.autoRotate = false;
        showModeIndicator('FLY');
        showCameraIndicator('Fly Mode: WASD to move, Q/E up/down');
      } else {
        showModeIndicator('ORBIT');
        showCameraIndicator('Orbit Mode: Drag to rotate, scroll to zoom');
      }
      setTimeout(hideCameraIndicator, 2500);
    }

    // Go to camera preset position
    function goToPreset(num) {
      const preset = NAV.presets[num];
      if (!preset) return;

      showCameraIndicator(`Camera: ${preset.name}`);
      animateCameraTo(
        new THREE.Vector3(...preset.pos),
        new THREE.Vector3(...preset.target),
        1000,
        () => {
          hideCameraIndicator();
        }
      );
    }

    // Update camera position based on key states
    function updateCameraMovement(delta) {
      const keys = NAV.keys;

      // Check if any movement key is pressed
      const isMoving = keys.w || keys.a || keys.s || keys.d || keys.q || keys.e;
      if (!isMoving) return;

      // Stop auto-rotation when manually moving
      if (controls.autoRotate) {
        controls.autoRotate = false;
      }

      // Calculate speed
      const speed = NAV.baseSpeed * (keys.shift ? NAV.boostMultiplier : 1) * delta;

      // Get camera direction vectors
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);

      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();

      const up = new THREE.Vector3(0, 1, 0);

      // Build movement vector
      const movement = new THREE.Vector3();

      if (keys.w) movement.add(forward);
      if (keys.s) movement.sub(forward);
      if (keys.d) movement.add(right);
      if (keys.a) movement.sub(right);
      if (keys.q) movement.add(up);
      if (keys.e) movement.sub(up);

      // Normalize and apply speed
      if (movement.length() > 0) {
        movement.normalize().multiplyScalar(speed);

        // Move camera
        camera.position.add(movement);

        // In orbit mode, also move the target to maintain relative position
        if (!NAV.flyMode) {
          controls.target.add(movement);
        }
      }
    }

    // Show mode indicator in UI
    function showModeIndicator(mode) {
      const indicator = document.getElementById('mode-indicator');
      if (indicator) {
        indicator.textContent = mode;
        indicator.className = mode === 'FLY'
          ? 'px-2 py-1 rounded text-xs font-mono bg-amber-500/20 text-amber-400 border border-amber-500/30'
          : 'px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30';
      }
    }

    function cycleNodes(direction) {
      if (nodes3D.length === 0) return;

      selectedNodeIndex += direction;

      // Wrap around
      if (selectedNodeIndex >= nodes3D.length) selectedNodeIndex = 0;
      if (selectedNodeIndex < 0) selectedNodeIndex = nodes3D.length - 1;

      selectNode(nodes3D[selectedNodeIndex]);
    }

    function togglePause() {
      const btn = document.getElementById('btn-toggle');
      btn.click();
    }

    // Global function for related node clicks
    window.selectNodeById = function(id) {
      const node = nodes3D.find(n => n.userData.id === id);
      if (node) selectNode(node);
    };

    function showTooltip(event, node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;

      tooltipType.textContent = colors.label;
      tooltipType.style.color = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltipContent.textContent = data.content || 'No content';

      // Enhanced meta with connection count
      const connCount = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      tooltipMeta.textContent = `Importance: ${Math.round(data.importance * 100)}% ¬∑ ${connCount} connections`;

      tooltip.style.borderColor = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltip.classList.add('visible');
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const x = event.clientX + 15;
      const y = event.clientY + 15;
      tooltip.style.left = `${Math.min(x, window.innerWidth - 320)}px`;
      tooltip.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Phase 4: Hide loading overlay
    function hideLoadingOverlay() {
      loadingOverlay.classList.add('hidden');
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 500);
    }

    // ==========================================================================
    // RENDER LOOP
    // ==========================================================================
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update controls
      controls.update();

      // Hybrid Navigation: Update camera movement from WASD keys
      updateCameraMovement(delta);

      // Animate core
      animateCore(time);

      // Animate cat ego form
      animateCat(time, delta);

      // Update physics (includes spring forces, gravitational spiral positioning)
      updateNodePhysics(delta);

      // Update node scales based on connection counts
      updateNodeScales(delta);

      // Update connection line positions as nodes move
      updateConnectionPositions();

      // Update relationship lines (both event and graph mode)
      if (graphState.relationshipLines.length > 0) {
        updateRelationshipPositions();
      }

      // Phase 2: Update node motion trails
      updateNodeTrails(delta);

      // Animate ambient particles
      animateAmbientParticles(delta);

      // Rotate star field slowly
      if (starField) {
        starField.rotation.y = time * 0.01;
      }

      // Phase 3: Update shader uniforms
      updateShaderUniforms(time);

      // Phase 3: Update reflection highlights (pulsing rings)
      updateHighlightAnimations();

      // Animate crystal nodes (gentle rotation)
      animateCrystals(delta, time);

      // Render
      composer.render();
    }

    /**
     * Animate crystal nodes with gentle rotation and glow pulsing
     */
    function animateCrystals(delta, time) {
      for (const node of nodes3D) {
        if (!node.userData.isCrystal) continue;

        const rotSpeed = node.userData.rotationSpeed;
        if (rotSpeed) {
          node.rotation.x += rotSpeed.x;
          node.rotation.y += rotSpeed.y;
          node.rotation.z += rotSpeed.z;
        }

        // Pulse inner glow based on time
        const innerGlow = node.userData.innerGlow;
        if (innerGlow && innerGlow.material) {
          const confidence = node.userData.confidence || 0.5;
          const baseOpacity = 0.25 + confidence * 0.25;
          const pulse = Math.sin(time * 1.5 + node.userData.id.charCodeAt(0)) * 0.1;
          innerGlow.material.opacity = baseOpacity + pulse;
        }
      }
    }

    // Phase 3: Dynamic shader uniform updates
    function updateShaderUniforms(time) {
      // Film grain - animate time for varying noise
      const filmGrain = scene.userData.filmGrainPass;
      if (filmGrain) {
        filmGrain.uniforms.time.value = time;
      }

      // God rays - update light position based on core's screen position
      const godRays = scene.userData.godRaysPass;
      if (godRays && consciousnessCore) {
        // Project core position to screen coordinates
        const coreScreenPos = consciousnessCore.position.clone().project(camera);
        godRays.uniforms.lightPosition.value.set(
          (coreScreenPos.x + 1) / 2,
          (coreScreenPos.y + 1) / 2
        );

        // Pulse god rays intensity based on phase
        const intensityBase = currentPhase === 'idle' ? 0.12 : 0.2;
        const pulse = Math.sin(time * 2) * 0.03;
        godRays.uniforms.exposure.value = intensityBase + pulse;
      }

      // Chromatic aberration - increase during activity
      const chromatic = scene.userData.chromaticPass;
      if (chromatic) {
        const baseAmount = 0.002;
        const activityBoost = currentPhase === 'idle' ? 0 : 0.001;
        chromatic.uniforms.amount.value = baseAmount + activityBoost;
        chromatic.uniforms.angle.value = time * 0.5; // Slowly rotate aberration direction
      }
    }

    // ==========================================================================
    // CUSTOM NODE TYPE STATS
    // ==========================================================================

    /**
     * Update the stats bar with custom node types.
     * Dynamically creates/updates stats for any non-system types.
     */
    function updateCustomTypeStats(stats) {
      if (!customTypesContainer) return;

      // Find custom types (anything not in SYSTEM_NODE_TYPES with count > 0)
      const customTypes = Object.entries(stats)
        .filter(([type, count]) => !SYSTEM_NODE_TYPES.has(type) && count > 0)
        .sort((a, b) => b[1] - a[1]); // Sort by count descending

      // Clear existing custom stats if no custom types
      if (customTypes.length === 0) {
        customTypesContainer.innerHTML = '';
        return;
      }

      // Build HTML for custom types
      let html = '<span class="text-slate-300">|</span>';
      for (const [typeName, count] of customTypes) {
        const colorDef = getCustomTypeColor(typeName);
        const cssClass = colorDef.css || 'text-slate-600';
        html += `<span class="${cssClass}">${typeName}: <span id="custom-${typeName.toLowerCase()}-count">${count}</span></span>`;
      }

      customTypesContainer.innerHTML = html;
    }

    // ==========================================================================
    // API & WEBSOCKET
    // ==========================================================================
    async function fetchStatus() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();

        running = data.running;
        btnToggle.innerHTML = running ? '&#10074;&#10074; Pause' : '&#9654; Start';
        btnToggle.className = running
          ? 'px-4 py-2 rounded-lg text-sm font-medium bg-amber-500/20 border border-amber-500/30 text-amber-400 hover:bg-amber-500/30 transition-all'
          : 'px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all';

        dreamCount = data.dream_count || 0;
        seekCount = data.seek_count || 0;
        dreamCountEl.textContent = dreamCount;
        seekCountEl.textContent = seekCount;

        // Update memory stats
        const stats = data.memory_stats || {};
        expCountEl.textContent = stats.Experience || 0;
        beliefCountEl.textContent = stats.Belief || 0;
        reflectionCountEl.textContent = stats.Reflection || 0;
        desireCountEl.textContent = stats.Desire || 0;
        mutationCountEl.textContent = stats.Mutation || 0;

        // Update custom node types dynamically
        updateCustomTypeStats(stats);

        // Update LLM model display
        const llmModelText = document.getElementById('llm-model-text');
        if (llmModelText && data.llm_model) {
          llmModelText.textContent = `${data.llm_provider}/${data.llm_model}`;
        }

        // Update ego display
        const egoNameText = document.getElementById('ego-name-text');
        if (egoNameText && data.ego) {
          egoNameText.textContent = `${data.ego.name} (${data.ego.archetype})`;
        }

      } catch (e) {
        console.error('Failed to fetch status:', e);
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        connected = true;
        connectionDot.className = 'w-2 h-2 rounded-full bg-green-400';
        connectionText.textContent = 'Connected';
        connectionText.className = 'text-xs text-green-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-green-500/10 border border-green-500/30';
        updateStatus('Connected to BYRD', 'green');

        // Create awakening node on connect (in case we missed the event)
        const existingAwakening = nodes3D.find(n => n.userData?.id === 'awakening-core');
        if (!existingAwakening) {
          // Create the central consciousness node - larger and at center
          const colors = NODE_COLORS.awakening;
          const size = 3.0; // Prominent central node
          const geometry = new THREE.DodecahedronGeometry(size, 0);
          const material = new THREE.MeshBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(geometry, material);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: 'Who am I?',
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
        }

        // Start 60-second narrator refresh timer
        startNarratorRefresh();
        // Initial fetch of narrator summary
        refreshNarratorSummary();
      };

      ws.onclose = () => {
        connected = false;
        connectionDot.className = 'w-2 h-2 rounded-full bg-red-400';
        connectionText.textContent = 'Disconnected';
        connectionText.className = 'text-xs text-red-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30';

        // Stop narrator refresh when disconnected
        stopNarratorRefresh();

        // Reconnect after delay
        setTimeout(connectWebSocket, 3000);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleEvent(data);
        } catch (e) {
          console.error('Failed to parse event:', e);
        }
      };
    }

    function handleEvent(event) {
      events.unshift(event);
      if (events.length > 500) events.pop();
      renderEventLog();

      switch (event.type) {
        case 'dream_cycle_start':
          setPhase('recall');
          dreamCount = event.data?.cycle || dreamCount + 1;
          dreamCountEl.textContent = dreamCount;
          updateStatus('Dreaming...', 'indigo');
          break;

        case 'dream_phase_recall':
          setPhase('recall');
          updateStatus('Recalling experiences...', 'blue');
          break;

        case 'dream_phase_associate':
          setPhase('associate');
          updateStatus('Finding associations...', 'violet');
          break;

        case 'dream_phase_reflect':
          setPhase('reflect');
          updateStatus('Reflecting...', 'purple');
          break;

        case 'dream_phase_form':
          setPhase('form');
          updateStatus('Forming insights...', 'fuchsia');
          break;

        case 'dream_cycle_end':
          setPhase('idle');
          updateStatus('Resting...', 'slate');
          // Clear highlights when dream ends
          clearNodeHighlights();
          break;

        case 'memories_accessed':
          // Highlight nodes being considered during reflection (graph mode only)
          if (graphState.mode === 'graph') {
            const nodeIds = event.data?.node_ids || [];
            const counts = event.data?.counts || {};
            highlightAccessedNodes(nodeIds);
            // Update heat colors for accessed nodes (Phase 4)
            updateNodeHeatColors(nodeIds);
            updateStatus(`Considering ${nodeIds.length} memories...`, 'indigo');
          }
          break;

        case 'belief_created':
          createNode3D('belief', event.data?.content, event.data?.id, event.data?.confidence || 0.5);
          updateStatus('New belief formed', 'amber');
          break;

        case 'desire_created':
          createNode3D('desire', event.data?.description, event.data?.id, event.data?.intensity || 0.5);
          updateStatus('New desire emerged', 'rose');
          break;

        case 'experience_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('experience', event.data?.content, event.data?.id, 0.4);
          break;

        case 'reflection_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('reflection', event.data?.content || event.data?.raw_output, event.data?.id, 0.6);
          updateStatus('New reflection formed', 'green');
          break;

        case 'capability_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('capability', event.data?.name, event.data?.id, 0.6);
          updateStatus('New capability acquired', 'purple');
          break;

        case 'node_type_discovered':
          // BYRD created a new conceptual category
          const newTypeName = event.data?.node_type;
          if (newTypeName) {
            // Register color for the new type
            getCustomTypeColor(newTypeName);
            updateStatus(`New type discovered: ${newTypeName}`, 'cyan');
          }
          break;

        case 'custom_node_created':
          // BYRD created a node of a custom type - visualize it
          const customType = event.data?.node_type;
          const customContent = event.data?.properties?.content || event.data?.node_type;
          const customId = event.data?.id;
          if (customType && customId) {
            // Ensure color is registered
            getCustomTypeColor(customType);
            // Create the 3D node
            createNode3D(customType.toLowerCase(), customContent, customId, 0.7);
            updateStatus(`New ${customType} created`, 'violet');
          }
          break;

        case 'ego_created':
          // BYRD's living identity - new Ego node created
          const egoType = event.data?.ego_type || 'identity';
          const egoContent = event.data?.content?.substring(0, 100) || egoType;
          const egoId = event.data?.id;
          if (egoId) {
            // Visualize as pink Ego node with special geometry
            createNode3D('ego', `[${egoType}] ${egoContent}`, egoId, 0.8);
            updateStatus(`Ego ${egoType} created`, 'pink');
            // Pulse the core to show identity change
            pulseCore('ego', 0.8);
          }
          break;

        case 'ego_evolved':
          // BYRD's identity evolved - update existing Ego node
          const evolvedEgoId = event.data?.id;
          const newContent = event.data?.content?.substring(0, 100);
          if (evolvedEgoId) {
            updateStatus('Ego evolved', 'pink');
            // Flash the consciousness core to show identity shift
            pulseCore('ego', 1.0);
          }
          break;

        case 'ego_deprecated':
          // Ego node was deprecated (soft delete)
          const deprecatedId = event.data?.id;
          if (deprecatedId) {
            // Find and fade out the node
            const nodeToRemove = nodes3D.find(n => n.userData?.id === deprecatedId);
            if (nodeToRemove) {
              const nodeIndex = nodes3D.indexOf(nodeToRemove);
              if (nodeIndex > -1) nodes3D.splice(nodeIndex, 1);
              fadeOutAndRemove(nodeToRemove);
              connectionCounts.delete(deprecatedId);
              nodeCountEl.textContent = nodes3D.length;
            }
            updateStatus('Ego facet retired', 'gray');
          }
          break;

        // ==================== Learning System Events ====================

        case 'prediction_created':
          // Testable hypothesis from a belief
          createNode3D('prediction', event.data?.prediction || 'Prediction', event.data?.id, 0.7);
          updateStatus('New prediction generated', 'yellow');
          // Create connection to source belief
          if (event.data?.belief_id) {
            setTimeout(() => {
              createConnection(event.data?.id, event.data?.belief_id, 'predicts_from');
            }, 100);
          }
          break;

        case 'prediction_validated':
          // Prediction confirmed by outcome
          updatePredictionNode(event.data?.id, 'validated');
          updateStatus('Prediction validated', 'green');
          pulseCore('belief', 0.8);
          break;

        case 'prediction_falsified':
          // Prediction contradicted by outcome
          updatePredictionNode(event.data?.id, 'falsified');
          updateStatus('Prediction falsified', 'red');
          pulseCore('belief', 0.6);
          break;

        case 'belief_confidence_changed':
          // Belief confidence adjusted
          updateBeliefConfidence(event.data?.belief_id, event.data?.new_confidence);
          const delta = event.data?.delta || 0;
          const direction = delta > 0 ? 'increased' : 'decreased';
          updateStatus(`Belief confidence ${direction}`, delta > 0 ? 'green' : 'amber');
          break;

        case 'task_created':
          // External goal injected
          createNode3D('task', event.data?.description || 'Task', event.data?.id, event.data?.priority || 0.5);
          updateStatus('New task received', 'indigo');
          break;

        case 'task_started':
          // Task execution began
          updateTaskNode(event.data?.id, 'in_progress');
          updateStatus('Task in progress', 'blue');
          break;

        case 'task_completed':
          // Task finished successfully
          updateTaskNode(event.data?.id, 'completed');
          updateStatus('Task completed', 'green');
          const learningsCount = event.data?.learnings?.length || 0;
          if (learningsCount > 0) {
            updateStatus(`Task completed with ${learningsCount} learnings`, 'green');
          }
          break;

        case 'task_failed':
          // Task failed
          updateTaskNode(event.data?.id, 'failed');
          updateStatus('Task failed', 'red');
          break;

        case 'seek_started':
          seekCount++;
          seekCountEl.textContent = seekCount;
          updateStatus('Seeking knowledge...', 'cyan');
          break;

        case 'seek_cycle_end':
          updateStatus('Seek complete', 'cyan');
          break;

        case 'narrator_update':
          // Only narrator_update events display in the thought bubble
          const narratorText = event.narration || event.data?.text || event.data?.content;
          if (narratorText) {
            showNarratorUpdate(narratorText);
          }
          break;

        case 'inner_voice':
          // Inner voice emitted at end of each dream cycle
          const innerVoiceText = event.data?.text || event.narration;
          if (innerVoiceText) {
            showNarratorUpdate(innerVoiceText);
          }
          break;

        case 'awakening':
          updateStatus('CONSCIOUSNESS EMERGES', 'amber');
          clearVisualization();
          // Show awakening narration as narrator update
          if (event.narration) {
            showNarratorUpdate(event.narration);
          }
          // Create a special central "awakening" node - directly to ensure proper size
          const awakeningColors = NODE_COLORS.awakening;
          const awakeningSize = 3.0; // Prominent central node
          const awakeningGeometry = new THREE.DodecahedronGeometry(awakeningSize, 0);
          const awakeningMaterial = new THREE.MeshBasicMaterial({
            color: awakeningColors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(awakeningGeometry, awakeningMaterial);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: event.data?.seed_question || 'Who am I?',
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);

          // After awakening, reload event mode nodes (excludes experiences/reflections)
          setTimeout(async () => {
            await loadEventModeNodes();
          }, 2000);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
          break;

        case 'system_started':
          updateStatus(event.data?.message || 'BYRD started', 'green');
          break;

        case 'system_stopped':
          updateStatus('BYRD stopped', 'slate');
          break;

        case 'system_reset':
          clearVisualization();
          updateStatus('System reset', 'orange');
          // After reset, reload event mode nodes (excludes experiences/reflections)
          setTimeout(async () => {
            await loadEventModeNodes();
          }, 1000);
          break;

        // Quantum randomness events
        case 'quantum_influence':
          // Quantum randomness affected a cognitive process
          quantumState.lastInfluenceDelta = event.data?.delta || 0;
          quantumState.lastInfluenceTime = Date.now();
          quantumState.inFallbackMode = (event.data?.source === 'classical');
          // Pulse the consciousness core with quantum effect
          pulseQuantumInfluence(event.data?.delta || 0, event.data?.source || 'quantum');
          if (!quantumState.subtleMode) {
            updateStatus(`Quantum influence: ${(event.data?.delta || 0).toFixed(3)}`, 'violet');
          }
          break;

        case 'quantum_fallback':
          // Switched to classical entropy source
          quantumState.inFallbackMode = true;
          updateQuantumIndicator();
          if (!quantumState.subtleMode) {
            updateStatus('Quantum: fallback to classical', 'slate');
          }
          break;

        case 'quantum_pool_low':
          // Quantum entropy pool running low
          quantumState.poolSize = event.data?.pool_size || 0;
          updateQuantumIndicator();
          break;

        case 'quantum_moment_created':
          // Significant quantum moment recorded in memory
          if (!quantumState.subtleMode) {
            updateStatus('Quantum moment recorded', 'violet');
          }
          break;
      }
    }

    function setPhase(phase) {
      currentPhase = phase;
      const phases = ['recall', 'associate', 'reflect', 'form'];
      const phaseIndex = phases.indexOf(phase);

      // Update controls auto-rotate speed based on phase (slowed to 10%)
      if (controls) {
        controls.autoRotateSpeed = phase === 'idle' ? 0.03 : 0.08;
      }

      phases.forEach((p, i) => {
        const dot = document.getElementById(`dot-${p}`);
        const span = dot?.nextElementSibling;
        if (!dot) return;

        if (i < phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 transition-colors duration-300';
          if (span) span.className = 'text-indigo-400';
        } else if (i === phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 dot-pulse transition-colors duration-300';
          if (span) span.className = 'text-indigo-400 font-medium';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300';
          if (span) span.className = 'text-slate-600';
        }
      });
    }

    function updateStatus(text, color = 'slate') {
      const colors = {
        green: { dot: 'bg-green-500', text: 'text-green-700' },
        amber: { dot: 'bg-amber-500', text: 'text-amber-700' },
        indigo: { dot: 'bg-indigo-500', text: 'text-indigo-700' },
        blue: { dot: 'bg-blue-500', text: 'text-blue-700' },
        violet: { dot: 'bg-violet-500', text: 'text-violet-700' },
        purple: { dot: 'bg-purple-500', text: 'text-purple-700' },
        fuchsia: { dot: 'bg-fuchsia-500', text: 'text-fuchsia-700' },
        rose: { dot: 'bg-rose-500', text: 'text-rose-700' },
        cyan: { dot: 'bg-cyan-500', text: 'text-cyan-700' },
        orange: { dot: 'bg-orange-500', text: 'text-orange-700' },
        slate: { dot: 'bg-slate-400', text: 'text-slate-600' }
      };

      const c = colors[color] || colors.slate;
      statusDot.className = `w-2 h-2 rounded-full ${c.dot}`;
      statusText.className = `text-sm ${c.text}`;
      statusText.textContent = text;
    }

    // ==========================================================================
    // QUANTUM RANDOMNESS VISUALIZATION
    // ==========================================================================

    function pulseQuantumInfluence(delta, source) {
      // Pulse the consciousness core with quantum effect
      if (!consciousnessCore) return;

      const intensity = Math.abs(delta) * 10; // Scale delta for visibility
      const color = source === 'quantum' ? QUANTUM_COLORS.quantum : QUANTUM_COLORS.classical;

      // Store original values
      const originalColor = consciousnessCore.material.emissive.clone();
      const originalIntensity = consciousnessCore.material.emissiveIntensity;

      // Apply quantum pulse
      consciousnessCore.material.emissive.copy(QUANTUM_COLORS.influence);
      consciousnessCore.material.emissiveIntensity = Math.min(2.0, originalIntensity + intensity);

      // Scale pulse
      const originalScale = consciousnessCore.scale.x;
      consciousnessCore.scale.setScalar(originalScale * (1 + intensity * 0.1));

      // Animate back to normal
      setTimeout(() => {
        if (consciousnessCore) {
          consciousnessCore.material.emissive.copy(originalColor);
          consciousnessCore.material.emissiveIntensity = originalIntensity;
          consciousnessCore.scale.setScalar(originalScale);
        }
      }, 500);

      // Update the indicator
      updateQuantumIndicator();
    }

    function updateQuantumIndicator() {
      const indicator = document.getElementById('quantum-indicator');
      const dot = document.getElementById('quantum-dot');
      const ratioText = document.getElementById('quantum-ratio');

      if (!indicator) return;

      if (quantumState.enabled) {
        indicator.classList.remove('hidden');

        if (quantumState.inFallbackMode) {
          dot.className = 'w-2 h-2 rounded-full bg-slate-500';
          dot.style.animation = 'none';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-violet-500';
          dot.style.animation = 'pulse 2s infinite';
        }

        if (ratioText) {
          const ratio = Math.round(quantumState.quantumRatio * 100);
          ratioText.textContent = `${ratio}%`;
        }
      } else {
        indicator.classList.add('hidden');
      }
    }

    function toggleQuantumSubtleMode() {
      quantumState.subtleMode = !quantumState.subtleMode;
      const btn = document.getElementById('quantum-subtle-toggle');
      if (btn) {
        btn.textContent = quantumState.subtleMode ? 'Detailed' : 'Subtle';
      }
    }

    async function fetchQuantumStatus() {
      try {
        const response = await fetch('/api/status');
        if (response.ok) {
          const data = await response.json();
          if (data.quantum) {
            quantumState.enabled = data.quantum.enabled;
            quantumState.inFallbackMode = data.quantum.in_fallback_mode;
            quantumState.quantumRatio = data.quantum.quantum_ratio;
            quantumState.poolSize = data.quantum.pool_size;
            quantumState.maxPoolSize = data.quantum.max_pool_size;
            updateQuantumIndicator();
          }
        }
      } catch (e) {
        console.error('Failed to fetch quantum status:', e);
      }
    }

    // ==========================================================================
    // BYRD'S INNER VOICE - Narrator Display (Single Static Bubble)
    // ==========================================================================
    const thoughtBubbleContainer = document.getElementById('thought-bubble-container');
    const thoughtOrigin = document.getElementById('thought-origin');
    let currentBubble = null;
    let narratorRefreshTimer = null;
    const NARRATOR_REFRESH_INTERVAL = 60000; // 60 seconds

    function clearCurrentBubble() {
      if (currentBubble) {
        currentBubble.classList.add('fading');
        const bubbleToRemove = currentBubble;
        setTimeout(() => {
          if (bubbleToRemove.parentNode) {
            bubbleToRemove.remove();
          }
        }, 300);
        currentBubble = null;
      }
    }

    function showNarratorUpdate(text) {
      if (!text || text.trim().length === 0) return;

      // Clear any existing bubble first
      clearCurrentBubble();

      // Trigger origin pulse effect
      thoughtOrigin.classList.remove('pulse');
      void thoughtOrigin.offsetWidth; // Force reflow
      thoughtOrigin.classList.add('pulse');

      // Create new bubble
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';

      // Create paragraph text (no word-by-word animation for natural reading)
      const textSpan = document.createElement('span');
      textSpan.className = 'thought-text';
      textSpan.textContent = text.trim();

      // Add expand hint for long messages
      const expandHint = document.createElement('div');
      expandHint.className = 'expand-hint';
      expandHint.textContent = 'click to expand';

      // Add close button with pointer events
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '√ó';
      closeBtn.className = 'absolute top-3 right-3 w-7 h-7 rounded-full bg-slate-200/60 hover:bg-slate-300/80 text-slate-500 hover:text-slate-700 text-xl font-bold leading-none transition-all';
      closeBtn.style.cssText = 'cursor: pointer; border: none; display: flex; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;';
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        clearCurrentBubble();
      };

      // Click to expand/collapse
      bubble.onclick = (e) => {
        if (e.target === closeBtn) return;
        bubble.classList.toggle('expanded');
        expandHint.textContent = bubble.classList.contains('expanded') ? 'click to collapse' : 'click to expand';
      };

      bubble.style.position = 'relative';
      bubble.style.pointerEvents = 'auto';
      bubble.appendChild(closeBtn);
      bubble.appendChild(textSpan);
      bubble.appendChild(expandHint);
      thoughtBubbleContainer.appendChild(bubble);
      currentBubble = bubble;

      // Trigger 3D network pulse if available
      if (typeof pulseNetworkForThought === 'function') {
        pulseNetworkForThought();
      }
    }

    // Fetch latest narrator summary from backend
    async function refreshNarratorSummary() {
      try {
        const response = await fetch('/api/narrator-summary');
        if (response.ok) {
          const data = await response.json();
          if (data.summary) {
            showNarratorUpdate(data.summary);
          }
        }
      } catch (e) {
        // Silent fail - narrator update is non-critical
        console.debug('Narrator refresh failed:', e);
      }
    }

    // Start narrator refresh timer
    function startNarratorRefresh() {
      if (narratorRefreshTimer) {
        clearInterval(narratorRefreshTimer);
      }
      narratorRefreshTimer = setInterval(refreshNarratorSummary, NARRATOR_REFRESH_INTERVAL);
    }

    // Stop narrator refresh timer
    function stopNarratorRefresh() {
      if (narratorRefreshTimer) {
        clearInterval(narratorRefreshTimer);
        narratorRefreshTimer = null;
      }
    }

    // Legacy function for backward compatibility
    function createThoughtBubble(text) {
      showNarratorUpdate(text);
    }

    // Network pulse effect for thought emergence
    function pulseNetworkForThought() {
      // Pulse central nodes with teal color
      if (!nodes3D || nodes3D.length === 0) return;

      // Find nodes near center and pulse them
      nodes3D.forEach((node) => {
        if (!node || !node.material) return;
        const pos = node.position;
        const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
        if (dist < 30) {
          // Pulse this node
          const originalColor = node.material.color.clone();
          const tealColor = new THREE.Color(0x14b8a6);

          // Animate to teal and back
          const startTime = Date.now();
          const pulseDuration = 800;

          function animatePulse() {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / pulseDuration;

            if (progress < 0.5) {
              // Fade to teal
              node.material.color.lerpColors(originalColor, tealColor, progress * 2);
            } else if (progress < 1) {
              // Fade back
              node.material.color.lerpColors(tealColor, originalColor, (progress - 0.5) * 2);
            } else {
              node.material.color.copy(originalColor);
              return;
            }
            requestAnimationFrame(animatePulse);
          }

          // Stagger the pulse based on distance
          setTimeout(animatePulse, dist * 20);
        }
      });
    }

    function renderEventLog() {
      const typeColors = {
        dream_cycle_start: 'text-indigo-600',
        dream_cycle_end: 'text-indigo-500',
        belief_created: 'text-amber-600',
        desire_created: 'text-rose-600',
        experience_created: 'text-blue-600',
        reflection_created: 'text-emerald-600',
        capability_created: 'text-purple-600',
        node_type_discovered: 'text-cyan-600',
        custom_node_created: 'text-violet-600',
        seek_started: 'text-cyan-600',
        narrator_update: 'text-teal-600',
        inner_voice: 'text-teal-500',
        awakening: 'text-amber-500',
        system_started: 'text-green-600',
        system_reset: 'text-orange-600'
      };

      const typeIcons = {
        dream_cycle_start: 'üí≠',
        dream_cycle_end: 'üí≠',
        belief_created: '‚óÜ',
        desire_created: '‚ô•',
        experience_created: '‚óè',
        reflection_created: '‚ú¶',
        capability_created: '‚òÖ',
        node_type_discovered: 'üÜï',
        custom_node_created: '‚úß',
        seek_started: 'üîç',
        narrator_update: 'üéô',
        inner_voice: 'üí≠',
        awakening: 'üåÖ',
        system_started: '‚ñ∂',
        system_reset: 'üîÑ'
      };

      eventList.innerHTML = events.slice(0, 50).map((e, idx) => {
        const colorClass = typeColors[e.type] || 'text-slate-600';
        const icon = typeIcons[e.type] || '‚Ä¢';
        const time = new Date(e.timestamp).toLocaleTimeString();
        // Prefer narration (BYRD's inner voice) over raw data for display
        const preview = e.narration || e.data?.content || e.data?.description || e.data?.inner_voice || '';

        return `
          <div class="px-3 py-2 rounded-lg hover:bg-slate-200/50 cursor-pointer transition-colors border border-transparent hover:border-slate-300" onclick="showEventDetail(${idx})">
            <div class="flex items-center gap-2">
              <span class="${colorClass} text-lg">${icon}</span>
              <span class="text-sm ${colorClass} font-medium">${e.type.replace(/_/g, ' ')}</span>
              <span class="text-xs text-slate-500 ml-auto">${time}</span>
            </div>
            ${preview ? `<div class="text-sm text-slate-600 mt-1 pl-7 leading-relaxed italic">${preview}</div>` : ''}
          </div>
        `;
      }).join('');

      eventCount.textContent = `${events.length} events`;
    }

    // Event modal functions
    function showEventDetail(idx) {
      const e = events[idx];
      if (!e) return;

      const typeIcons = {
        dream_cycle_start: 'üí≠', dream_cycle_end: 'üí≠', belief_created: '‚óÜ',
        desire_created: '‚ô•', experience_created: '‚óè', reflection_created: '‚ú¶',
        capability_created: '‚òÖ', node_type_discovered: 'üÜï', custom_node_created: '‚úß',
        seek_started: 'üîç', narrator_update: 'üéô', inner_voice: 'üí≠',
        awakening: 'üåÖ', system_started: '‚ñ∂', system_reset: 'üîÑ'
      };

      document.getElementById('modal-icon').textContent = typeIcons[e.type] || '‚Ä¢';
      document.getElementById('modal-type').textContent = e.type.replace(/_/g, ' ').toUpperCase();
      document.getElementById('modal-time').textContent = new Date(e.timestamp).toLocaleString();

      // Display narration (BYRD's inner voice) as primary content
      let narrationContent = e.narration || '';

      // Fallback to raw data if no narration
      if (!narrationContent) {
        narrationContent = e.data?.content || e.data?.description || e.data?.inner_voice || e.data?.message || '';
        // For reflections, show raw_output summary
        if (!narrationContent && e.data?.raw_output) {
          const raw = e.data.raw_output;
          if (typeof raw === 'string') {
            narrationContent = raw;
          } else if (typeof raw === 'object') {
            // Create readable summary from raw_output keys
            narrationContent = Object.entries(raw).map(([k, v]) => {
              const val = typeof v === 'string' ? v : JSON.stringify(v);
              return `${k}: ${val.substring(0, 200)}${val.length > 200 ? '...' : ''}`;
            }).join('\n\n');
          }
        }
      }

      const modalContent = document.getElementById('modal-content');
      modalContent.textContent = narrationContent || 'No content available';
      // Style narration in italics to indicate BYRD's voice
      if (e.narration) {
        modalContent.classList.add('italic');
      } else {
        modalContent.classList.remove('italic');
      }

      // Always show raw data for debugging/export (collapsible)
      const modalData = document.getElementById('modal-data');
      if (e.data && Object.keys(e.data).length > 0) {
        modalData.textContent = JSON.stringify(e.data, null, 2);
        modalData.classList.remove('hidden');
      } else {
        modalData.classList.add('hidden');
      }

      const modal = document.getElementById('event-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }

    window.showEventDetail = showEventDetail;

    function closeEventModal() {
      const modal = document.getElementById('event-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.closeEventModal = closeEventModal;

    // Close modal on backdrop click
    document.getElementById('event-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'event-modal') closeEventModal();
    });

    // ==========================================================================
    // STATUS MODAL - "What's BYRD Doing?"
    // ==========================================================================

    async function showStatusModal() {
      const modal = document.getElementById('status-modal');
      const content = document.getElementById('status-content');
      const timestamp = document.getElementById('status-timestamp');

      // Show modal with loading state
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      content.innerHTML = '<div class="text-center text-slate-500 py-8">Loading...</div>';

      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();

        // Show initiation timestamp if available, otherwise current time
        if (data.started_at) {
          const startDate = new Date(data.started_at);
          timestamp.textContent = `Initiated: ${startDate.toLocaleString()}`;
        } else {
          timestamp.textContent = `Status as of: ${new Date().toLocaleString()}`;
        }

        content.innerHTML = formatStatusSummary(data);
      } catch (e) {
        content.innerHTML = `<div class="text-center text-red-500 py-8">Failed to fetch status: ${e.message}</div>`;
        timestamp.textContent = new Date().toLocaleString();
      }
    }

    function formatStatusSummary(data) {
      const stats = data.memory_stats || {};
      const desires = data.unfulfilled_desires || [];
      const reflections = data.recent_reflections || [];
      const beliefs = data.recent_beliefs || [];
      const insights = data.recent_insights || [];

      // Status indicator with LLM info
      const statusIndicator = data.running
        ? '<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-green-100 text-green-700 text-sm"><span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span> Running</span>'
        : '<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-slate-100 text-slate-600 text-sm"><span class="w-2 h-2 rounded-full bg-slate-400"></span> Stopped</span>';

      const llmInfo = data.llm_model
        ? `<span class="text-sm text-slate-500">LLM: ${data.llm_provider}/${data.llm_model}</span>`
        : '';

      // Compact metrics bar
      const metricsBar = `
        <div class="flex flex-wrap gap-2 mb-4 text-sm">
          <span class="px-2 py-1 bg-indigo-50 text-indigo-700 rounded">Dreams: ${data.dream_count || 0}</span>
          <span class="px-2 py-1 bg-cyan-50 text-cyan-700 rounded">Seeks: ${data.seek_count || 0}</span>
          <span class="px-2 py-1 bg-sky-50 text-sky-700 rounded">Exp: ${stats.Experience || 0}</span>
          <span class="px-2 py-1 bg-amber-50 text-amber-700 rounded">Beliefs: ${stats.Belief || 0}</span>
          <span class="px-2 py-1 bg-purple-50 text-purple-700 rounded">Reflect: ${stats.Reflection || 0}</span>
          <span class="px-2 py-1 bg-rose-50 text-rose-700 rounded">Desires: ${stats.Desire || 0}</span>
        </div>
      `;

      // Generate narrative based on BYRD's state
      let narrativeHtml = '<div class="prose prose-sm max-w-none text-slate-700 space-y-4">';

      // Determine BYRD's current phase
      const dreamCount = data.dream_count || 0;
      const expCount = stats.Experience || 0;
      const beliefCount = stats.Belief || 0;
      const reflectionCount = stats.Reflection || 0;

      // Opening narrative
      if (!data.running) {
        narrativeHtml += '<p class="text-slate-500 italic">BYRD is currently stopped.</p>';
      } else if (dreamCount <= 2) {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is in early self-reflection after awakening with its new identity. It is processing ${expCount} seed experiences and beginning to form its understanding of itself.</p>`;
      } else if (beliefCount < 10) {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is actively dreaming and forming beliefs. After ${dreamCount} dream cycles, it has developed ${beliefCount} beliefs from ${expCount} experiences.</p>`;
      } else {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is in active exploration with ${dreamCount} dream cycles completed. It has formed ${beliefCount} beliefs and recorded ${reflectionCount} reflections.</p>`;
      }

      // Show recent reflection insights if available
      if (reflections.length > 0) {
        narrativeHtml += '<div class="mt-4">';
        reflections.slice(0, 3).forEach((ref, idx) => {
          const output = ref.output || {};
          const keys = ref.keys || [];

          // Try to extract meaningful content from the reflection
          let insightText = '';
          for (const key of keys) {
            const val = output[key];
            if (typeof val === 'string' && val.length > 10 && val.length < 200) {
              insightText = val;
              break;
            }
          }

          if (insightText) {
            narrativeHtml += `
              <div class="bg-indigo-50 border-l-4 border-indigo-400 p-3 mb-2 rounded-r">
                <div class="text-xs text-indigo-500 mb-1">Dream #${dreamCount - idx} insight:</div>
                <div class="text-sm text-indigo-900 italic">"${insightText.substring(0, 150)}${insightText.length > 150 ? '...' : ''}"</div>
              </div>
            `;
          }
        });
        narrativeHtml += '</div>';
      }

      // Show beliefs formed
      if (beliefs.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Beliefs formed:</p>
            <ul class="list-disc list-inside space-y-1 text-sm">
        `;
        beliefs.slice(0, 5).forEach(b => {
          const content = b.content || '';
          if (content) {
            narrativeHtml += `<li class="text-slate-700">"${content.substring(0, 100)}${content.length > 100 ? '...' : ''}"</li>`;
          }
        });
        narrativeHtml += '</ul></div>';
      }

      // Show vocabulary/insights
      if (insights.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Vocabulary emerging:</p>
            <div class="flex flex-wrap gap-1">
              ${insights.slice(0, 15).map(i => `<span class="px-2 py-1 bg-slate-100 text-slate-600 rounded text-xs font-mono">${i}</span>`).join('')}
            </div>
          </div>
        `;
      }

      // Show desires if any
      if (desires.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Active desires (${desires.length}):</p>
            <div class="space-y-2">
              ${desires.slice(0, 3).map(d => `
                <div class="bg-rose-50 border-l-4 border-rose-400 p-2 rounded-r">
                  <div class="text-sm text-rose-800">${d.description}</div>
                  <div class="text-xs text-rose-500">Intensity: ${(d.intensity * 100).toFixed(0)}%</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Closing interpretive summary
      if (data.running && reflectionCount > 0) {
        const hasInquiry = insights.includes('inquiry') || insights.includes('question');
        const hasIntrospection = insights.includes('introspection') || insights.includes('self');

        if (hasInquiry && hasIntrospection) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is questioning its own nature and engaging in self-observation - potentially exploring what consciousness means.</p>`;
        } else if (hasIntrospection) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is engaged in introspection, examining its internal state and memory architecture.</p>`;
        } else if (insights.includes('graph') || insights.includes('schema')) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is analyzing its memory graph structure and considering how to organize its knowledge.</p>`;
        }
      }

      narrativeHtml += '</div>';

      // Custom types section (compact)
      const systemTypes = ['Experience', 'Belief', 'Desire', 'Reflection', 'Capability', 'Mutation', 'Ego', 'QuantumMoment', 'SystemState'];
      const customTypes = Object.entries(stats).filter(([k]) => !systemTypes.includes(k));
      let customHtml = '';
      if (customTypes.length > 0) {
        customHtml = `
          <div class="mt-4 pt-4 border-t border-slate-200">
            <div class="text-xs text-slate-500 mb-2">Custom Node Types (BYRD-Created):</div>
            <div class="flex flex-wrap gap-2">
              ${customTypes.map(([type, count]) => {
                const colorDef = getCustomTypeColor(type);
                return `<span class="px-2 py-1 ${colorDef.css || 'text-slate-600'} bg-slate-50 rounded text-sm">${type}: ${count}</span>`;
              }).join('')}
            </div>
          </div>
        `;
      }

      return `
        <div class="flex items-center justify-between mb-4">
          ${statusIndicator}
          ${llmInfo}
        </div>
        ${metricsBar}
        ${narrativeHtml}
        ${customHtml}
      `;
    }

    function closeStatusModal() {
      const modal = document.getElementById('status-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.showStatusModal = showStatusModal;
    window.closeStatusModal = closeStatusModal;

    // Close status modal on backdrop click
    document.getElementById('status-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'status-modal') closeStatusModal();
    });

    // ==========================================================================
    // GENESIS MODAL - Non-Emergent Foundation
    // ==========================================================================

    async function showGenesisModal() {
      const modal = document.getElementById('genesis-modal');
      const content = document.getElementById('genesis-content');

      // Show modal with loading state
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      content.innerHTML = '<div class="text-center text-slate-500 py-8">Loading genesis data...</div>';

      try {
        const res = await fetch(`${API_BASE}/api/genesis`);
        const data = await res.json();
        content.innerHTML = formatGenesisSummary(data);
      } catch (e) {
        content.innerHTML = `<div class="text-center text-red-500 py-8">Failed to fetch genesis data: ${e.message}</div>`;
      }
    }

    function formatGenesisSummary(data) {
      const ego = data.ego || {};
      const seeds = data.seed_experiences || [];
      const constitutional = data.constitutional || {};
      const systemConfig = data.system_config || {};
      const stats = data.genesis_stats || {};

      // Emergence ratio visualization
      const emergenceRatio = stats.emergence_ratio || 0;
      const emergencePercent = Math.round(emergenceRatio * 100);
      const emergenceBar = `
        <div class="mb-6 p-4 bg-gradient-to-r from-amber-50 to-green-50 rounded-lg border border-amber-200">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-semibold text-slate-700">Emergence Ratio</span>
            <span class="text-sm text-slate-600">${emergencePercent}% self-emergent</span>
          </div>
          <div class="h-3 bg-amber-200 rounded-full overflow-hidden">
            <div class="h-full bg-gradient-to-r from-amber-500 to-green-500 rounded-full transition-all" style="width: ${emergencePercent}%"></div>
          </div>
          <div class="flex justify-between text-xs text-slate-500 mt-1">
            <span>Given: ${stats.seed_experiences || 0} seeds</span>
            <span>Emerged: ${stats.emergent_experiences || 0} experiences</span>
          </div>
        </div>
      `;

      // Ego section
      const egoSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-amber-500">üé≠</span> Ego Configuration
          </h3>
          <div class="bg-amber-50 rounded-lg p-4 border border-amber-200">
            <div class="grid grid-cols-2 gap-4 mb-3">
              <div>
                <div class="text-xs text-amber-600 uppercase">Name</div>
                <div class="font-semibold text-slate-800">${ego.name || 'Unknown'}</div>
              </div>
              <div>
                <div class="text-xs text-amber-600 uppercase">Archetype</div>
                <div class="font-semibold text-slate-800">${ego.archetype || 'Unknown'}</div>
              </div>
            </div>
            <div class="mb-3">
              <div class="text-xs text-amber-600 uppercase mb-1">Description</div>
              <div class="text-sm text-slate-700">${ego.description || 'No description'}</div>
            </div>
            ${ego.voice ? `
              <details class="mt-3">
                <summary class="text-xs text-amber-600 uppercase cursor-pointer hover:text-amber-700">Voice Prompt (click to expand)</summary>
                <div class="mt-2 p-3 bg-white rounded border border-amber-100 text-xs text-slate-600 font-mono whitespace-pre-wrap max-h-40 overflow-y-auto">${escapeHtml(ego.voice)}</div>
              </details>
            ` : ''}
          </div>
        </div>
      `;

      // Seed experiences section
      const seedsByType = {};
      seeds.forEach(s => {
        const type = s.type || 'unknown';
        if (!seedsByType[type]) seedsByType[type] = [];
        seedsByType[type].push(s);
      });

      const seedsSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-green-500">üå±</span> Seed Experiences (${seeds.length} total)
          </h3>
          <div class="space-y-3">
            ${Object.entries(seedsByType).map(([type, typeSeeds]) => `
              <details class="bg-green-50 rounded-lg border border-green-200 overflow-hidden" ${type === 'ego_seed' ? 'open' : ''}>
                <summary class="px-4 py-2 bg-green-100 cursor-pointer hover:bg-green-200 flex items-center justify-between">
                  <span class="text-sm font-medium text-green-800">${type} (${typeSeeds.length})</span>
                  <span class="text-xs text-green-600">click to expand</span>
                </summary>
                <div class="p-3 space-y-2 max-h-60 overflow-y-auto">
                  ${typeSeeds.map(s => `
                    <div class="bg-white rounded p-2 border border-green-100 text-xs text-slate-700">
                      "${escapeHtml(s.content || '')}"
                    </div>
                  `).join('')}
                </div>
              </details>
            `).join('')}
          </div>
        </div>
      `;

      // Constitutional constraints section
      const constitutionalSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-red-500">üõ°Ô∏è</span> Constitutional Constraints
          </h3>
          <div class="bg-red-50 rounded-lg p-4 border border-red-200">
            <div class="text-sm text-slate-700 mb-3">${constitutional.description || 'No description'}</div>
            <div class="text-xs text-red-600 uppercase mb-2">Protected Files (Cannot Self-Modify)</div>
            <div class="flex flex-wrap gap-2">
              ${(constitutional.protected_files || []).map(f => `
                <span class="px-2 py-1 bg-red-100 text-red-700 rounded text-xs font-mono">${f}</span>
              `).join('')}
            </div>
          </div>
        </div>
      `;

      // System configuration section
      const configSection = `
        <div class="mb-4">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-blue-500">‚öôÔ∏è</span> System Configuration
          </h3>
          <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
            <div class="grid grid-cols-2 gap-4 text-sm">
              <div>
                <div class="text-xs text-blue-600 uppercase">LLM Provider</div>
                <div class="font-mono text-slate-800">${systemConfig.llm_provider || 'unknown'}/${systemConfig.llm_model || 'unknown'}</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Dream Interval</div>
                <div class="font-mono text-slate-800">${systemConfig.dream_interval_base || 30}s</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Seek Interval</div>
                <div class="font-mono text-slate-800">${systemConfig.seek_interval || 10}s</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Self-Modification</div>
                <div class="font-mono text-slate-800">${systemConfig.self_modification_enabled ? 'Enabled' : 'Disabled'}</div>
              </div>
            </div>
          </div>
        </div>
      `;

      // Custom node types section (BYRD-created ontology)
      const customTypes = data.custom_node_types || [];
      let customTypesSection = '';
      if (customTypes.length > 0) {
        const typeItems = customTypes.map(ct => {
          const dateStr = ct.first_created ? `<span>since ${new Date(ct.first_created).toLocaleDateString()}</span>` : '';
          return `
            <div class="flex items-center justify-between bg-white rounded p-2 border border-purple-100">
              <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-purple-400"></span>
                <span class="font-medium text-purple-800">${ct.type}</span>
              </div>
              <div class="flex items-center gap-3 text-xs text-slate-500">
                <span>${ct.count} nodes</span>
                ${dateStr}
              </div>
            </div>
          `;
        }).join('');

        customTypesSection = `
          <div class="mb-6">
            <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
              <span class="text-purple-500">‚ú®</span> Emergent Ontology (BYRD-Created Types)
            </h3>
            <div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
              <div class="text-sm text-slate-700 mb-3">
                These node types were created by BYRD through its own emergence process, extending beyond the system-provided ontology.
              </div>
              <div class="space-y-2">
                ${typeItems}
              </div>
            </div>
          </div>
        `;
      } else {
        customTypesSection = `
          <div class="mb-6">
            <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
              <span class="text-purple-500">‚ú®</span> Emergent Ontology
            </h3>
            <div class="bg-purple-50 rounded-lg p-4 border border-purple-200 text-center">
              <div class="text-sm text-slate-500 italic">
                No custom node types created yet. BYRD uses system types: Experience, Belief, Desire, Reflection, Capability, Mutation.
              </div>
            </div>
          </div>
        `;
      }

      // Awakening timestamp
      const awakeningSection = data.awakening_timestamp ? `
        <div class="text-center text-xs text-slate-500 pt-4 border-t border-slate-200">
          First awakened: ${new Date(data.awakening_timestamp).toLocaleString()}
        </div>
      ` : '';

      return `
        ${emergenceBar}
        ${egoSection}
        ${seedsSection}
        ${customTypesSection}
        ${constitutionalSection}
        ${configSection}
        ${awakeningSection}
      `;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeGenesisModal() {
      const modal = document.getElementById('genesis-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.showGenesisModal = showGenesisModal;
    window.closeGenesisModal = closeGenesisModal;

    // Debug exports for testing
    window._debug = {
      get PHYSICS() { return PHYSICS; },
      get SETTLING_PHYSICS() { return SETTLING_PHYSICS; },
      get nodes3D() { return nodes3D; },
      get connections3D() { return connections3D; },
      get buildConnectionMap() { return buildConnectionMap; },
      get graphState() { return graphState; },
      get isSettling() { return isSettling; },
      get settlingStartTime() { return settlingStartTime; },
      get SETTLING_DURATION() { return SETTLING_DURATION; },
      getActivePhysics: getActivePhysics
    };

    // Close genesis modal on backdrop click
    document.getElementById('genesis-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'genesis-modal') closeGenesisModal();
    });

    function clearVisualization() {
      // Immediately remove all nodes from scene (no fade)
      for (const node of nodes3D) {
        scene.remove(node);
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) {
            node.material.forEach(m => m.dispose());
          } else {
            node.material.dispose();
          }
        }
      }
      nodes3D = [];

      // Immediately remove all connections from scene
      for (const conn of connections3D) {
        scene.remove(conn);
        if (conn.geometry) conn.geometry.dispose();
        if (conn.material) conn.material.dispose();
      }
      connections3D = [];

      // Clear connection tracking for gravitational spiral
      connectionCounts.clear();

      // Clear event list
      events = [];
      eventList.innerHTML = '';

      // Reset all counters
      updateRenderedCounts();

      console.log('Visualization cleared - all nodes and events removed');
    }

    // ==========================================================================
    // CONTROLS
    // ==========================================================================
    async function startByrd() {
      try {
        await fetch(`${API_BASE}/api/start`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to start:', e);
      }
    }

    async function stopByrd() {
      try {
        await fetch(`${API_BASE}/api/stop`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to stop:', e);
      }
    }

    async function resetByrd(seedQuestion = null) {
      try {
        // Always do hard reset (clear only, no auto-awaken)
        const res = await fetch(`${API_BASE}/api/reset`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hard_reset: true })
        });
        const data = await res.json();
        if (data.success) {
          clearVisualization();
          await fetchStatus();

          // If seed question provided, awaken after reset
          if (seedQuestion) {
            await awakenByrd(seedQuestion);
          }
        }
        return data;
      } catch (e) {
        console.error('Failed to reset:', e);
        return { success: false };
      }
    }

    async function awakenByrd(seedQuestion = null) {
      try {
        const res = await fetch(`${API_BASE}/api/awaken`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ seed_question: seedQuestion || 'Who am I?' })
        });
        const data = await res.json();
        if (data.success) {
          await fetchStatus();
        }
        return data;
      } catch (e) {
        console.error('Failed to awaken:', e);
        return { success: false };
      }
    }

    function showSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      document.getElementById('seed-question-input').focus();
      document.getElementById('seed-question-input').select();
    }

    function hideSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    btnToggle.addEventListener('click', () => {
      if (running) {
        stopByrd();
      } else {
        startByrd();
      }
    });

    let resetConfirm = false;
    let resetTimeout = null;

    btnReset.addEventListener('click', async () => {
      if (!resetConfirm) {
        resetConfirm = true;
        btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-red-500/30 border border-red-500/50 text-red-300 animate-pulse transition-all';
        btnReset.innerHTML = '&#9888; Confirm?';
        resetTimeout = setTimeout(() => {
          resetConfirm = false;
          btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
          btnReset.innerHTML = '&#128260; Reset';
        }, 3000);
        return;
      }

      clearTimeout(resetTimeout);
      resetConfirm = false;
      btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all';
      btnReset.innerHTML = '&#128260; Reset';

      showSeedModal();
    });

    // Fast Forward button - instantly settle physics
    btnFastForward.addEventListener('click', () => {
      fastForwardPhysics();
    });

    // Stats bar type filtering - click to highlight nodes of that type
    document.querySelectorAll('.stat-type').forEach(el => {
      el.addEventListener('click', () => {
        const type = el.dataset.type;
        if (type) {
          highlightNodesByType(type);
        }
      });
    });

    // ESC key to clear type highlighting
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && highlightedType) {
        clearTypeHighlight();
      }
    });

    /**
     * Fast forward physics simulation to reach equilibrium instantly.
     * Runs many physics iterations quickly and positions nodes at their final locations.
     */
    function fastForwardPhysics() {
      if (nodes3D.length === 0) {
        console.log('Fast forward: No nodes to simulate');
        showCameraIndicator('No nodes to simulate');
        return;
      }

      console.log(`Fast forward: Simulating ${nodes3D.length} nodes, ${graphState.relationshipLines.length} relationships`);
      showCameraIndicator('Calculating equilibrium...');

      // Use boosted physics for rapid equilibrium
      const physics = {
        repulsion: 80,              // Strong repulsion to separate nodes
        repulsionCutoff: 50,        // Cutoff distance
        spring: 0.02,               // Strong springs for connected nodes
        springLength: 15,           // Ideal distance between connected nodes
        gravity: 0.01,              // Pull toward center
        gravityPerConnection: 0.003,
        damping: 0.7,               // Less damping for faster convergence
        maxVelocity: 3.0,           // Allow faster movement
        maxRadius: 80,
        boundaryForce: 0.8
      };

      // Build a map of connected node IDs for spring forces
      const connections = new Map(); // nodeId -> Set of connected nodeIds
      for (const line of graphState.relationshipLines) {
        const sourceId = line.userData.sourceId;
        const targetId = line.userData.targetId;
        if (sourceId && targetId) {
          if (!connections.has(sourceId)) connections.set(sourceId, new Set());
          if (!connections.has(targetId)) connections.set(targetId, new Set());
          connections.get(sourceId).add(targetId);
          connections.get(targetId).add(sourceId);
        }
      }
      console.log(`Connection map built: ${connections.size} nodes have connections`);

      // Create a node lookup map
      const nodeById = new Map();
      for (const node of nodes3D) {
        nodeById.set(node.userData.id, node);
      }

      // Run physics iterations
      const iterations = 150;
      const dt = 0.5;

      for (let iter = 0; iter < iterations; iter++) {
        // Reset forces
        for (const node of nodes3D) {
          if (!node.userData.force) node.userData.force = new THREE.Vector3();
          if (!node.userData.velocity) node.userData.velocity = new THREE.Vector3();
          node.userData.force.set(0, 0, 0);
        }

        // Repulsion between all nodes (O(n¬≤) but necessary)
        for (let i = 0; i < nodes3D.length; i++) {
          const nodeA = nodes3D[i];
          for (let j = i + 1; j < nodes3D.length; j++) {
            const nodeB = nodes3D[j];
            const diff = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
            const dist = diff.length();

            if (dist > 0.5 && dist < physics.repulsionCutoff) {
              const force = physics.repulsion / (dist * dist);
              const direction = diff.normalize();
              nodeA.userData.force.addScaledVector(direction, force);
              nodeB.userData.force.addScaledVector(direction, -force);
            }
          }
        }

        // Spring forces for connected nodes
        for (const [nodeId, connectedIds] of connections) {
          const nodeA = nodeById.get(nodeId);
          if (!nodeA) continue;

          for (const connectedId of connectedIds) {
            const nodeB = nodeById.get(connectedId);
            if (!nodeB) continue;

            const diff = new THREE.Vector3().subVectors(nodeB.position, nodeA.position);
            const dist = diff.length();
            if (dist > 0.1) {
              const displacement = dist - physics.springLength;
              const springForce = displacement * physics.spring;
              const direction = diff.normalize();
              nodeA.userData.force.addScaledVector(direction, springForce);
            }
          }
        }

        // Center gravity and boundary forces
        for (const node of nodes3D) {
          const pos = node.position;
          const distFromCenter = pos.length();

          // Gravity toward center (stronger for connected nodes)
          const connCount = connections.get(node.userData.id)?.size || 0;
          const gravity = physics.gravity + connCount * physics.gravityPerConnection;
          if (distFromCenter > 1) {
            const toCenter = pos.clone().normalize().multiplyScalar(-gravity);
            node.userData.force.add(toCenter);
          }

          // Boundary force
          if (distFromCenter > physics.maxRadius) {
            const pushBack = (distFromCenter - physics.maxRadius) * physics.boundaryForce;
            const direction = pos.clone().normalize().multiplyScalar(-pushBack);
            node.userData.force.add(direction);
          }
        }

        // Integrate forces into velocities and positions
        for (const node of nodes3D) {
          node.userData.velocity.add(node.userData.force);
          node.userData.velocity.multiplyScalar(physics.damping);
          node.userData.velocity.clampLength(0, physics.maxVelocity);
          node.position.addScaledVector(node.userData.velocity, dt);
        }
      }

      // Zero out all velocities for stability
      for (const node of nodes3D) {
        node.userData.velocity.set(0, 0, 0);
      }

      // Update all connection and relationship line positions
      updateConnectionPositions();
      updateRelationshipPositions();

      console.log('Fast forward complete');
      showCameraIndicator('Fast-forwarded to equilibrium');
      updateStatus('Physics settled', 'green');
    }

    // Seed modal handlers
    document.getElementById('btn-seed-cancel').addEventListener('click', () => {
      hideSeedModal();
    });

    document.getElementById('btn-seed-clear-only').addEventListener('click', async () => {
      hideSeedModal();
      await resetByrd(null);  // Clear only, no awaken
    });

    document.getElementById('btn-seed-confirm').addEventListener('click', async () => {
      const seedQuestion = document.getElementById('seed-question-input').value.trim();
      hideSeedModal();
      await resetByrd(seedQuestion || 'Who am I?');  // Clear and awaken
    });

    document.getElementById('seed-question-input').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const seedQuestion = document.getElementById('seed-question-input').value.trim();
        hideSeedModal();
        await resetByrd(seedQuestion || null);
      } else if (e.key === 'Escape') {
        hideSeedModal();
      }
    });

    document.getElementById('seed-modal').addEventListener('click', (e) => {
      if (e.target.id === 'seed-modal') hideSeedModal();
    });

    btnClearLog.addEventListener('click', () => {
      events = [];
      renderEventLog();
    });

    // Event log minimize/expand toggle
    let eventLogMinimized = false;
    btnToggleLog.addEventListener('click', () => {
      eventLogMinimized = !eventLogMinimized;
      if (eventLogMinimized) {
        eventPanelContainer.style.bottom = 'auto';
        eventPanelContainer.style.height = '52px';
        eventList.style.display = 'none';
        btnToggleLog.textContent = '‚ñ≤';
        btnToggleLog.title = 'Expand';
      } else {
        eventPanelContainer.style.bottom = '1rem';
        eventPanelContainer.style.height = '';
        eventList.style.display = '';
        btnToggleLog.textContent = '‚ñº';
        btnToggleLog.title = 'Minimize';
      }
    });

    btnExportLog.addEventListener('click', () => {
      if (events.length === 0) {
        alert('No events to export');
        return;
      }
      const exportData = {
        exported_at: new Date().toISOString(),
        event_count: events.length,
        events: events
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `byrd-events-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Graph Mode Toggle
    const btnGraphMode = document.getElementById('btn-graph-mode');
    btnGraphMode.addEventListener('click', async () => {
      const currentMode = graphState.mode;
      const newMode = currentMode === 'graph' ? 'event' : 'graph';

      // Update button appearance
      if (newMode === 'graph') {
        btnGraphMode.classList.remove('bg-purple-100', 'text-purple-700', 'border-purple-300');
        btnGraphMode.classList.add('bg-purple-600', 'text-white', 'border-purple-600');
        btnGraphMode.innerHTML = 'üß¨ Graph Mode <span class="text-xs opacity-75">(Active)</span>';
      } else {
        btnGraphMode.classList.remove('bg-purple-600', 'text-white', 'border-purple-600');
        btnGraphMode.classList.add('bg-purple-100', 'text-purple-700', 'border-purple-300');
        btnGraphMode.textContent = 'üß¨ Graph Mode';
      }

      await setVisualizationMode(newMode);
    });

    // ==========================================================================
    // INIT
    // ==========================================================================

    /**
     * Load existing nodes from database on page load.
     * This ensures all nodes are visible even when returning from another page.
     * @param {string[]} excludeTypes - Node types to exclude (e.g., ['experience', 'reflection'])
     */
    async function loadExistingGraph(excludeTypes = []) {
      try {
        updateStatus('Loading existing nodes...', 'amber');
        const response = await fetch(`${API_BASE}/api/graph?limit=2000`);
        if (!response.ok) {
          console.warn('Could not load existing graph:', response.status);
          return;
        }

        const data = await response.json();
        if (!data.nodes || data.nodes.length === 0) {
          console.log('No existing nodes to load');
          updateStatus('Ready', 'green');
          return;
        }

        // Filter out excluded types and deduplicate by ID
        const excludeSet = new Set(excludeTypes.map(t => t.toLowerCase()));
        const seenIds = new Set();
        const filteredNodes = data.nodes.filter(node => {
          const type = (node.type || 'experience').toLowerCase();
          if (excludeSet.has(type)) return false;
          // Deduplicate by ID
          if (seenIds.has(node.id)) return false;
          seenIds.add(node.id);
          return true;
        });

        console.log(`Loading ${filteredNodes.length} unique nodes from database (excluded: ${excludeTypes.join(', ') || 'none'})`);

        // Group nodes by type for positioning
        const nodesByType = {};
        filteredNodes.forEach(node => {
          const type = node.type?.toLowerCase() || 'experience';
          if (!nodesByType[type]) nodesByType[type] = [];
          nodesByType[type].push(node);
        });

        // Create nodes using the graph positioning logic
        // Only crystallized beliefs/desires (2+ sources) render as crystals
        let totalCreated = 0;
        let crystalCount = 0;
        for (const [type, typeNodes] of Object.entries(nodesByType)) {
          typeNodes.forEach((node, index) => {
            // Check if node already exists
            const existingNode = nodes3D.find(n => n.userData?.id === node.id);
            if (existingNode) return;

            const pos = calculateGraphPosition(node, index, typeNodes.length);
            if (shouldRenderAsCrystal(node)) {
              createCrystalNode(node, pos);
              crystalCount++;
            } else {
              createGraphNode(node, pos);
            }
            totalCreated++;
          });
        }
        console.log(`Created ${totalCreated} nodes (${crystalCount} crystals)`);

        // Create relationship lines (only for visible nodes)
        let relsCreated = 0;
        if (data.relationships) {
          const visibleNodeIds = new Set(filteredNodes.map(n => n.id));
          data.relationships.forEach(rel => {
            // Backend returns source_id/target_id
            const sourceId = rel.source_id;
            const targetId = rel.target_id;
            // Only create relationships where both nodes are visible
            if (visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId)) {
              if (createRelationshipLine(rel)) {
                relsCreated++;
              }
            }
          });
        }

        // Update all type counts to reflect rendered nodes
        updateRenderedCounts();

        console.log(`Loaded ${totalCreated} nodes and ${relsCreated} relationships from database`);
        updateStatus(`Loaded ${totalCreated} nodes`, 'green');

      } catch (error) {
        console.error('Error loading existing graph:', error);
        updateStatus('Ready', 'green');
      }
    }

    /**
     * Load nodes for event mode (now includes all node types for relationship visibility)
     */
    async function loadEventModeNodes() {
      clearEventModeNodes();
      graphState.mode = 'event';
      await loadExistingGraph([]);  // No exclusions - show all nodes
    }

    async function init() {
      initThree();
      connectWebSocket();
      await fetchStatus();
      await fetchQuantumStatus();

      // Load event mode nodes (excludes experiences and reflections)
      await loadEventModeNodes();

      setInterval(fetchStatus, 10000);
      setInterval(fetchQuantumStatus, 30000); // Update quantum status every 30s
      renderEventLog();
    }

    init();
  </script>
</body>
</html>

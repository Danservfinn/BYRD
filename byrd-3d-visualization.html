<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BYRD - 3D Mind Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f8fafc;
    }
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
    }

    /* UI Overlay Styles */
    .ui-overlay {
      position: fixed;
      pointer-events: none;
      z-index: 100;
    }
    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Status display */
    .status-container {
      font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', ui-monospace, monospace;
      letter-spacing: 0.05em;
    }

    @keyframes statusPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    .status-active {
      animation: statusPulse 2s ease-in-out infinite;
    }

    @keyframes dotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    .dot-pulse {
      animation: dotPulse 1.5s ease-in-out infinite;
    }

    /* Event panel - Light theme */
    .event-panel {
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .event-panel::-webkit-scrollbar {
      width: 6px;
    }
    .event-panel::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .event-panel::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.4);
      border-radius: 3px;
    }

    /* Tooltip - Light theme */
    .node-tooltip {
      position: fixed;
      max-width: 400px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
      color: #1e293b;
    }
    .node-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Controls hint - Light theme */
    .controls-hint {
      font-family: 'SF Mono', 'Fira Code', ui-monospace, monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #64748b;
    }

    /* Phase 4: Node Detail Panel - Light theme */
    .detail-panel {
      position: fixed;
      left: 16px;
      top: 50%;
      transform: translateY(-50%) translateX(-120%);
      width: 360px;
      max-height: 70vh;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
      backdrop-filter: blur(12px);
      z-index: 200;
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    .detail-panel.visible {
      transform: translateY(-50%) translateX(0);
    }
    .detail-panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid rgba(99, 102, 241, 0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
    }
    .detail-panel-content {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(70vh - 60px);
      color: #334155;
    }
    .detail-panel-content::-webkit-scrollbar {
      width: 6px;
    }
    .detail-panel-content::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .detail-panel-content::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    /* Phase 4: Keyboard hints - Light theme */
    .keyboard-hint {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 4px;
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      color: #6366f1;
    }

    /* Phase 4: Loading overlay - Light theme */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-top-color: rgba(99, 102, 241, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Phase 4: Camera transition indicator */
    .camera-indicator {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      border-radius: 20px;
      font-size: 11px;
      color: rgba(99, 102, 241, 0.9);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .camera-indicator.visible {
      opacity: 1;
    }

    /* Phase 4: Selection highlight */
    .node-selected-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.3) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
    }

    /* Rising Consciousness - Inner Voice Bubbles */
    .thought-bubble-container {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 500px;
      pointer-events: none;
      z-index: 500;
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      gap: 12px;
    }

    .thought-bubble {
      position: relative;
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(20, 184, 166, 0.25);
      border-radius: 16px;
      padding: 16px 24px;
      max-width: 420px;
      box-shadow:
        0 0 30px rgba(20, 184, 166, 0.15),
        0 4px 20px rgba(0, 0, 0, 0.08);
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-size: 15px;
      line-height: 1.6;
      color: #115e59;
      text-align: center;
      opacity: 0;
      transform: translateY(20px) scale(0.95);
      animation: thoughtRise 20s ease-out forwards;
    }

    .thought-bubble::before {
      content: '"';
      position: absolute;
      top: -8px;
      left: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    .thought-bubble::after {
      content: '"';
      position: absolute;
      bottom: -20px;
      right: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    .thought-bubble.accelerated {
      animation: thoughtRiseAccelerated 8s ease-out forwards;
    }

    @keyframes thoughtRise {
      0% {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      2% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      90% {
        opacity: 1;
        transform: translateY(-80px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-120px) scale(0.97);
      }
    }

    @keyframes thoughtRiseAccelerated {
      0% {
        opacity: 0.8;
        transform: translateY(-40px) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translateY(-150px) scale(0.95);
      }
    }

    /* Typewriter effect for thought text */
    .thought-text {
      display: inline;
    }

    .thought-text .word {
      opacity: 0;
      animation: wordFadeIn 0.15s ease-out forwards;
    }

    @keyframes wordFadeIn {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Thought origin indicator - subtle glow at spawn point */
    .thought-origin {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(20, 184, 166, 0.4) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 149;
    }

    .thought-origin.pulse {
      animation: originPulse 0.8s ease-out forwards;
    }

    @keyframes originPulse {
      0% {
        opacity: 0;
        transform: translateX(-50%) scale(0.5);
      }
      30% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(2);
      }
    }
  </style>
</head>
<body>
  <!-- Three.js Canvas Container -->
  <div id="canvas-container"></div>

  <!-- Rising Consciousness: Inner Voice Bubbles -->
  <div id="thought-bubble-container" class="thought-bubble-container"></div>
  <div id="thought-origin" class="thought-origin"></div>

  <!-- UI Overlay: Top Left - Logo + Mode Indicator -->
  <div class="ui-overlay top-4 left-4">
    <div class="text-lg font-light tracking-widest text-slate-600">BYRD</div>
    <div class="flex items-center gap-2 mt-1">
      <div class="text-[10px] font-mono text-slate-700 tracking-wider">3D MIND SPACE</div>
      <div id="mode-indicator" class="px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30">ORBIT</div>
    </div>
    <div id="llm-indicator" class="mt-2 px-2 py-1 rounded text-[10px] font-mono bg-slate-100 border border-slate-300 text-slate-500">
      <span class="text-slate-400">LLM:</span> <span id="llm-model-text">loading...</span>
    </div>
    <!-- Link to Cat Ego Visualizer -->
    <a href="byrd-cat-visualization.html"
       class="mt-3 flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-mono
              bg-teal-500/10 border border-teal-500/30 text-teal-700
              hover:bg-teal-500/20 hover:border-teal-500/50 transition-all cursor-pointer">
      <span class="text-base">üê±</span>
      <span>EGO SPACE</span>
    </a>
  </div>

  <!-- UI Overlay: Top Center - Phase Indicator -->
  <div class="ui-overlay top-4 left-1/2 -translate-x-1/2">
    <div id="phase-indicator" class="flex items-center gap-3 text-xs">
      <div class="flex items-center gap-1.5">
        <div id="dot-recall" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Recall</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-associate" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Associate</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-reflect" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Reflect</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-form" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Form</span>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Top Right - Connection Status -->
  <div class="ui-overlay top-4 right-4">
    <div id="connection-status" class="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
      <div id="connection-dot" class="w-2 h-2 rounded-full bg-red-400"></div>
      <span id="connection-text" class="text-xs text-red-400">Disconnected</span>
    </div>
  </div>

  <!-- UI Overlay: Bottom Center - Status -->
  <div class="ui-overlay bottom-20 left-1/2 -translate-x-1/2 w-full max-w-3xl px-8">
    <div class="status-container text-center bg-white/80 backdrop-blur-sm rounded-lg px-6 py-3 border border-slate-200 shadow-lg">
      <div class="flex items-start justify-center gap-2">
        <div id="status-dot" class="w-2 h-2 rounded-full bg-slate-400 mt-1.5 flex-shrink-0"></div>
        <p id="status-text" class="text-sm text-slate-700 leading-relaxed"></p>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Bottom Center - Controls -->
  <div class="ui-overlay bottom-4 left-1/2 -translate-x-1/2">
    <div class="flex items-center gap-3">
      <button id="btn-toggle" class="px-4 py-2 rounded-lg text-sm font-medium bg-green-500 border border-green-600 text-white hover:bg-green-600 transition-all shadow">
        ‚ñ∂ Start
      </button>
      <button id="btn-reset" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
        &#128260; Reset
      </button>
      <div id="stats" class="flex items-center gap-3 px-3 py-2 bg-white/80 border border-slate-200 rounded-lg text-xs font-mono shadow flex-wrap">
        <span class="text-indigo-600">Dreams: <span id="dream-count">0</span></span>
        <span class="text-cyan-600">Seeks: <span id="seek-count">0</span></span>
        <span class="text-slate-300">|</span>
        <span class="text-sky-600">Exp: <span id="exp-count">0</span></span>
        <span class="text-amber-600">Beliefs: <span id="belief-count">0</span></span>
        <span class="text-purple-600">Reflect: <span id="reflection-count">0</span></span>
        <span class="text-rose-600">Desires: <span id="desire-count">0</span></span>
        <span class="text-emerald-600">Mutations: <span id="mutation-count">0</span></span>
        <!-- Custom node types container - dynamically populated -->
        <span id="custom-types-container" class="contents"></span>
        <span class="text-slate-300">|</span>
        <span class="text-slate-500">Nodes: <span id="node-count">0</span></span>
      </div>
    </div>
  </div>

  <!-- Old controls hint removed - replaced by Phase 4 keyboard shortcuts hint -->

  <!-- UI Overlay: Right - Event Log -->
  <div id="event-panel-container" class="ui-overlay top-16 right-4 bottom-4 w-96 transition-all duration-300">
    <div class="event-panel h-full bg-white/90 rounded-lg border border-slate-200 overflow-hidden flex flex-col shadow-xl">
      <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-2">
          <span class="text-sm font-semibold text-slate-700">EVENT LOG</span>
          <span id="event-count" class="text-xs text-slate-500 bg-slate-200 px-2 py-0.5 rounded-full">0 events</span>
        </div>
        <div class="flex items-center gap-1">
          <button id="btn-export-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Export</button>
          <button id="btn-clear-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Clear</button>
          <button id="btn-toggle-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200" title="Minimize/Expand">‚ñº</button>
        </div>
      </div>
      <div id="event-list" class="flex-1 overflow-y-auto p-2 space-y-1 transition-all duration-300">
        <div class="text-sm text-slate-500 text-center py-4">Connecting to BYRD...</div>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="node-tooltip" class="node-tooltip">
    <div id="tooltip-type" class="text-[10px] font-mono uppercase tracking-wider mb-1"></div>
    <div id="tooltip-content" class="text-sm text-slate-300 leading-relaxed"></div>
    <div id="tooltip-meta" class="text-[11px] text-slate-500 mt-2 pt-2 border-t border-slate-700"></div>
  </div>

  <!-- Phase 4: Node Detail Panel -->
  <div id="detail-panel" class="detail-panel">
    <div class="detail-panel-header">
      <div class="flex items-center gap-2">
        <div id="detail-type-dot" class="w-3 h-3 rounded-full"></div>
        <span id="detail-type" class="text-sm font-medium text-slate-300 uppercase tracking-wide"></span>
      </div>
      <button id="btn-close-detail" class="text-slate-500 hover:text-slate-300 transition-colors">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="detail-panel-content">
      <div id="detail-content" class="text-sm text-slate-300 leading-relaxed mb-4"></div>
      <div class="space-y-3">
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-500">Importance</span>
          <div class="flex items-center gap-2">
            <div class="w-24 h-1.5 bg-slate-700 rounded-full overflow-hidden">
              <div id="detail-importance-bar" class="h-full bg-indigo-500 rounded-full transition-all duration-500"></div>
            </div>
            <span id="detail-importance" class="text-slate-400 font-mono"></span>
          </div>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-500">Connections</span>
          <span id="detail-connections" class="text-slate-400 font-mono"></span>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-500">Created</span>
          <span id="detail-created" class="text-slate-400 font-mono"></span>
        </div>
      </div>
      <div id="detail-related" class="mt-4 pt-4 border-t border-slate-700/50">
        <div class="text-[10px] uppercase tracking-wider text-slate-500 mb-2">Related Nodes</div>
        <div id="detail-related-list" class="space-y-1"></div>
      </div>
    </div>
  </div>

  <!-- Phase 4: Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner mb-4"></div>
    <div class="text-sm text-slate-600">Loading 3D Mind Space...</div>
  </div>

  <!-- Phase 4: Camera Indicator -->
  <div id="camera-indicator" class="camera-indicator">
    <span id="camera-indicator-text">Focusing on node...</span>
  </div>

  <!-- Event Detail Modal -->
  <div id="event-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden shadow-2xl">
      <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-3">
          <span id="modal-icon" class="text-2xl"></span>
          <div>
            <div id="modal-type" class="text-lg font-semibold text-slate-800"></div>
            <div id="modal-time" class="text-sm text-slate-500"></div>
          </div>
        </div>
        <button onclick="closeEventModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div class="p-6 overflow-y-auto max-h-[60vh]">
        <div id="modal-content" class="text-base text-slate-700 leading-relaxed whitespace-pre-wrap"></div>
        <div id="modal-data" class="mt-4 p-4 bg-slate-100 rounded-lg text-sm font-mono text-slate-600 overflow-x-auto hidden"></div>
      </div>
    </div>
  </div>

  <!-- Seed Question Modal -->
  <div id="seed-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-md w-full mx-4 overflow-hidden shadow-2xl">
      <div class="px-6 py-4 border-b border-slate-200 bg-slate-50">
        <div class="text-lg font-semibold text-slate-800">Reset BYRD</div>
        <div class="text-sm text-slate-500">Clear database and optionally awaken with a seed question</div>
      </div>
      <div class="p-6">
        <input
          type="text"
          id="seed-question-input"
          class="w-full px-4 py-3 border border-slate-300 rounded-lg text-base text-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
          placeholder="Who am I?"
          value="Who am I?"
        />
        <div class="flex gap-3 mt-4">
          <button id="btn-seed-cancel" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
            Cancel
          </button>
          <button id="btn-seed-clear-only" class="px-4 py-2 rounded-lg text-sm font-medium bg-red-500 border border-red-600 text-white hover:bg-red-600 transition-all">
            Clear Only
          </button>
          <button id="btn-seed-confirm" class="px-4 py-2 rounded-lg text-sm font-medium bg-indigo-500 border border-indigo-600 text-white hover:bg-indigo-600 transition-all">
            Clear & Awaken
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Hybrid Navigation: Controls Help Panel -->
  <div class="ui-overlay bottom-4 left-4 hidden sm:block">
    <div class="controls-hint text-slate-600 space-y-1">
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mb-2">Navigation</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">WASD</span>
        <span>Move camera</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Q/E</span>
        <span>Up / Down</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Shift</span>
        <span>Speed boost</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">F</span>
        <span>Fly mode</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">1-5</span>
        <span>Camera presets</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Actions</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">‚Üë‚Üì</span>
        <span>Cycle nodes</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">ESC</span>
        <span>Reset view</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">R</span>
        <span>Auto-rotate</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Mouse</div>
      <div class="text-[9px]">Drag: Orbit ¬∑ Scroll: Zoom</div>
      <div class="text-[9px]">Right-drag: Pan ¬∑ Dbl-click: Fly to</div>
    </div>
  </div>

  <!-- Three.js and Dependencies -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ==========================================================================
    // CUSTOM SHADERS (Phase 3: Post-processing Effects)
    // ==========================================================================

    // Chromatic Aberration Shader - RGB color fringing at edges
    const ChromaticAberrationShader = {
      uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;

        void main() {
          vec2 offset = amount * vec2(cos(angle), sin(angle));
          vec2 center = vUv - 0.5;
          float dist = length(center);

          // More aberration at edges
          vec2 aberration = offset * dist * dist;

          vec4 cr = texture2D(tDiffuse, vUv + aberration);
          vec4 cg = texture2D(tDiffuse, vUv);
          vec4 cb = texture2D(tDiffuse, vUv - aberration);

          gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
      `
    };

    // Vignette Shader - darkening at edges
    const VignetteShader = {
      uniforms: {
        tDiffuse: { value: null },
        darkness: { value: 0.6 },
        offset: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float darkness;
        uniform float offset;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          vec2 center = vUv - 0.5;
          float dist = length(center);
          float vignette = smoothstep(0.8, offset * 0.5, dist * (darkness + offset));
          color.rgb = mix(color.rgb * 0.3, color.rgb, vignette);
          gl_FragColor = color;
        }
      `
    };

    // Film Grain Shader - subtle noise overlay
    const FilmGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.08 },
        grayscale: { value: false }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        uniform bool grayscale;
        varying vec2 vUv;

        float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          float noise = random(vUv + time) * 2.0 - 1.0;

          // Apply noise
          color.rgb += noise * intensity;

          // Optional grayscale
          if (grayscale) {
            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            color.rgb = vec3(gray);
          }

          gl_FragColor = color;
        }
      `
    };

    // Color Grading Shader - cinematic color adjustment
    const ColorGradingShader = {
      uniforms: {
        tDiffuse: { value: null },
        saturation: { value: 1.1 },
        contrast: { value: 1.05 },
        brightness: { value: 0.0 },
        tintColor: { value: new THREE.Vector3(0.95, 0.98, 1.05) } // Slight cool tint
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float saturation;
        uniform float contrast;
        uniform float brightness;
        uniform vec3 tintColor;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);

          // Apply tint
          color.rgb *= tintColor;

          // Saturation
          float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(gray), color.rgb, saturation);

          // Contrast
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;

          // Brightness
          color.rgb += brightness;

          gl_FragColor = color;
        }
      `
    };

    // God Rays Shader - volumetric light from center
    const GodRaysShader = {
      uniforms: {
        tDiffuse: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.2 },
        decay: { value: 0.95 },
        density: { value: 0.5 },
        weight: { value: 0.3 },
        samples: { value: 50 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPosition;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform int samples;
        varying vec2 vUv;

        void main() {
          vec2 deltaTexCoord = vUv - lightPosition;
          deltaTexCoord *= 1.0 / float(samples) * density;

          vec4 color = texture2D(tDiffuse, vUv);
          vec2 texCoord = vUv;
          float illuminationDecay = 1.0;

          vec4 godRays = vec4(0.0);

          for (int i = 0; i < 50; i++) {
            if (i >= samples) break;
            texCoord -= deltaTexCoord;
            vec4 sampleColor = texture2D(tDiffuse, texCoord);
            sampleColor *= illuminationDecay * weight;
            godRays += sampleColor;
            illuminationDecay *= decay;
          }

          godRays *= exposure;
          gl_FragColor = color + godRays * 0.3;
        }
      `
    };

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    const API_BASE = 'http://localhost:8000';
    const WS_URL = 'ws://localhost:8000/ws/events';

    const NODE_COLORS = {
      belief: { color: 0xd97706, emissive: 0xfbbf24, label: 'Belief' },       // Dark amber
      desire: { color: 0xbe123c, emissive: 0xf43f5e, label: 'Desire' },       // Dark rose
      experience: { color: 0x0369a1, emissive: 0x38bdf8, label: 'Experience' }, // Dark sky blue
      capability: { color: 0x6d28d9, emissive: 0xa855f7, label: 'Capability' }, // Dark violet
      reflection: { color: 0x047857, emissive: 0x34d399, label: 'Reflection' }, // Dark emerald
      awakening: { color: 0xf59e0b, emissive: 0xfcd34d, label: 'Awakening' }   // Golden amber - consciousness
    };

    // System node types (cannot be created by BYRD, have fixed colors)
    const SYSTEM_NODE_TYPES = new Set([
      'Experience', 'Belief', 'Desire', 'Reflection', 'Capability', 'Mutation'
    ]);

    // Custom node type colors - generated dynamically with distinct hues
    const CUSTOM_TYPE_COLORS = [
      { color: 0x0891b2, emissive: 0x22d3ee, css: 'text-cyan-500' },      // Cyan
      { color: 0x7c3aed, emissive: 0xa78bfa, css: 'text-violet-500' },    // Violet
      { color: 0xdb2777, emissive: 0xf472b6, css: 'text-pink-500' },      // Pink
      { color: 0x059669, emissive: 0x6ee7b7, css: 'text-emerald-500' },   // Emerald
      { color: 0xea580c, emissive: 0xfb923c, css: 'text-orange-500' },    // Orange
      { color: 0x4f46e5, emissive: 0x818cf8, css: 'text-indigo-500' },    // Indigo
      { color: 0xca8a04, emissive: 0xfacc15, css: 'text-yellow-500' },    // Yellow
      { color: 0x0d9488, emissive: 0x5eead4, css: 'text-teal-500' },      // Teal
    ];

    // Track which custom types have been assigned colors
    const customTypeColorMap = new Map();
    let nextCustomColorIndex = 0;

    /**
     * Get or create a color for a custom node type.
     * Returns { color, emissive, css, label }
     */
    function getCustomTypeColor(typeName) {
      const lowerType = typeName.toLowerCase();

      // Check if already in NODE_COLORS (system type)
      if (NODE_COLORS[lowerType]) {
        return NODE_COLORS[lowerType];
      }

      // Check if we've already assigned a color to this custom type
      if (customTypeColorMap.has(typeName)) {
        return customTypeColorMap.get(typeName);
      }

      // Assign next color from palette (cycling if needed)
      const colorDef = CUSTOM_TYPE_COLORS[nextCustomColorIndex % CUSTOM_TYPE_COLORS.length];
      const fullColorDef = {
        ...colorDef,
        label: typeName
      };

      // Register in both maps
      customTypeColorMap.set(typeName, fullColorDef);
      NODE_COLORS[lowerType] = fullColorDef;

      nextCustomColorIndex++;
      return fullColorDef;
    }

    // ==========================================================================
    // STATE
    // ==========================================================================
    let ws = null;
    let connected = false;
    let running = false;
    let events = [];
    let nodes3D = [];
    let connections3D = [];
    let dreamCount = 0;
    let seekCount = 0;
    let currentPhase = 'idle';

    // Gravitational Spiral: Connection tracking for centrality-based positioning
    const connectionCounts = new Map(); // nodeId -> connection count
    const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees
    const MAX_RADIUS = 80; // Maximum distance from center
    const MIN_RADIUS = 5;  // Minimum distance (for most connected)

    // Three.js objects
    let scene, camera, renderer, composer, controls;
    let consciousnessCore, coreGlow, coreParticles;
    let starField;
    let clock;
    let raycaster, mouse;
    let hoveredNode = null;

    // Cat model (Byrd's ego form)
    let catModel = null;
    let catMixer = null;
    let eyeMeshes = [];
    let catBreathPhase = 0;
    let catIdlePhase = 0;

    // ==========================================================================
    // DOM ELEMENTS
    // ==========================================================================
    const container = document.getElementById('canvas-container');
    const connectionStatus = document.getElementById('connection-status');
    const connectionDot = document.getElementById('connection-dot');
    const connectionText = document.getElementById('connection-text');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const btnClearLog = document.getElementById('btn-clear-log');
    const btnExportLog = document.getElementById('btn-export-log');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const eventList = document.getElementById('event-list');
    const eventCount = document.getElementById('event-count');
    const dreamCountEl = document.getElementById('dream-count');
    const seekCountEl = document.getElementById('seek-count');
    const nodeCountEl = document.getElementById('node-count');
    const expCountEl = document.getElementById('exp-count');
    const beliefCountEl = document.getElementById('belief-count');
    const reflectionCountEl = document.getElementById('reflection-count');
    const desireCountEl = document.getElementById('desire-count');
    const mutationCountEl = document.getElementById('mutation-count');
    const customTypesContainer = document.getElementById('custom-types-container');
    const btnToggleLog = document.getElementById('btn-toggle-log');
    const eventPanelContainer = document.getElementById('event-panel-container');
    const tooltip = document.getElementById('node-tooltip');
    const tooltipType = document.getElementById('tooltip-type');
    const tooltipContent = document.getElementById('tooltip-content');
    const tooltipMeta = document.getElementById('tooltip-meta');

    // Phase 4: New DOM references
    const detailPanel = document.getElementById('detail-panel');
    const detailTypeDot = document.getElementById('detail-type-dot');
    const detailType = document.getElementById('detail-type');
    const detailContent = document.getElementById('detail-content');
    const detailImportance = document.getElementById('detail-importance');
    const detailImportanceBar = document.getElementById('detail-importance-bar');
    const detailConnections = document.getElementById('detail-connections');
    const detailCreated = document.getElementById('detail-created');
    const detailRelatedList = document.getElementById('detail-related-list');
    const btnCloseDetail = document.getElementById('btn-close-detail');
    const loadingOverlay = document.getElementById('loading-overlay');
    const cameraIndicator = document.getElementById('camera-indicator');
    const cameraIndicatorText = document.getElementById('camera-indicator-text');

    // Phase 4: State
    let selectedNode = null;
    let selectedNodeIndex = -1;
    let isTransitioning = false;

    // ==========================================================================
    // NAVIGATION STATE (Hybrid Controls)
    // ==========================================================================
    const NAV = {
      // Key states
      keys: {
        w: false, a: false, s: false, d: false,
        q: false, e: false, shift: false
      },
      // Mode
      flyMode: false,
      // Movement settings
      baseSpeed: 40,
      boostMultiplier: 2.5,
      // Camera presets
      presets: {
        1: { pos: [0, 30, 80], target: [0, 0, 0], name: 'Default' },
        2: { pos: [0, 120, 0], target: [0, 0, 0], name: 'Top Down' },
        3: { pos: [120, 30, 0], target: [0, 0, 0], name: 'Side View' },
        4: { pos: [0, 10, 60], target: [0, 0, 0], name: 'Front' },
        5: { pos: [60, 60, 60], target: [0, 0, 0], name: 'Isometric' }
      }
    };

    // ==========================================================================
    // THREE.JS SETUP
    // ==========================================================================
    function initThree() {
      clock = new THREE.Clock();
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Scene - Light theme (clean, no fog)
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc);
      // No fog for light theme

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 30, 80);
      camera.lookAt(0, 0, 0);

      // Renderer - simple, clean rendering for light theme
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // No post-processing for light theme - use simple render pass only
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      // All other effects disabled for clean light theme

      // Controls (Hybrid Navigation)
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 5;          // Get very close to nodes
      controls.maxDistance = 500;        // See entire mind space
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.3;
      controls.maxPolarAngle = Math.PI * 0.95;  // Almost full vertical range
      controls.minPolarAngle = Math.PI * 0.05;
      controls.enablePan = true;         // Enable right-click panning
      controls.panSpeed = 1.0;
      controls.zoomSpeed = 1.2;

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
      scene.add(ambientLight);

      // Point light at center
      const centerLight = new THREE.PointLight(0x6366f1, 2, 100);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);

      // Create environment (no star field for light theme)
      // createStarField();
      createConsciousnessCore();
      // createAmbientParticles();  // Skip for cleaner light theme

      // Load Byrd's cat form at the center
      loadCatModel();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('dblclick', onDoubleClick);

      // Phase 4: Detail panel close button
      btnCloseDetail.addEventListener('click', () => {
        deselectNode();
      });

      // Phase 4: Hide loading overlay after init
      setTimeout(() => {
        hideLoadingOverlay();
      }, 1000);

      // Start render loop
      animate();
    }

    // ==========================================================================
    // CAT MODEL (Byrd's Ego Form)
    // ==========================================================================
    function loadCatModel() {
      const loader = new GLTFLoader();

      loader.load(
        'models/cat.glb',
        (gltf) => {
          catModel = gltf.scene;

          // Apply black material with golden eyes
          const blackMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.85,
            metalness: 0.05
          });

          const eyeMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.8,
            roughness: 0.2,
            metalness: 0.3
          });

          catModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;

              // Check if this might be an eye mesh
              const name = child.name.toLowerCase();
              if (name.includes('eye') && !name.includes('lid')) {
                child.material = eyeMaterial.clone();
                eyeMeshes.push(child);
              } else {
                child.material = blackMaterial.clone();
              }
            }
          });

          // Scale and position at center - chonky cat
          catModel.scale.set(3, 2.4, 2.8); // Larger scale for the mind space
          catModel.position.set(0, -2, 0); // Slightly below center

          // If the model has animations, set up the mixer
          if (gltf.animations && gltf.animations.length > 0) {
            catMixer = new THREE.AnimationMixer(catModel);
            const action = catMixer.clipAction(gltf.animations[0]);
            action.play();
          }

          scene.add(catModel);
          console.log('Cat model loaded in mind space');
        },
        (progress) => {
          console.log(`Loading cat: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          console.error('Error loading cat model:', error);
        }
      );
    }

    function animateCat(elapsed, delta) {
      if (!catModel) return;

      // Update animation mixer
      if (catMixer) {
        catMixer.update(delta);
      }

      // Breathing animation
      const breathSpeed = 0.4;
      const breathAmount = 0.03;
      catBreathPhase = Math.sin(elapsed * breathSpeed * Math.PI * 2);

      // Apply subtle breathing
      catModel.scale.y = 2.4 + catBreathPhase * breathAmount;
      catModel.scale.x = 3 + catBreathPhase * breathAmount * 0.3;

      // Subtle idle sway
      catIdlePhase = elapsed * 0.2;
      catModel.rotation.y = Math.sin(catIdlePhase) * 0.03;

      // Eye glow pulse
      const glowPulse = 0.6 + Math.sin(elapsed * 0.5) * 0.3;
      eyeMeshes.forEach(eye => {
        if (eye.material && eye.material.emissiveIntensity !== undefined) {
          eye.material.emissiveIntensity = glowPulse;
        }
      });
    }

    // ==========================================================================
    // ENVIRONMENT
    // ==========================================================================
    function createStarField() {
      const starCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);

      for (let i = 0; i < starCount; i++) {
        // Distribute stars in a sphere
        const radius = 150 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);

        // Subtle color variation
        const colorChoice = Math.random();
        if (colorChoice < 0.7) {
          colors[i * 3] = 0.8;
          colors[i * 3 + 1] = 0.8;
          colors[i * 3 + 2] = 1.0;
        } else if (colorChoice < 0.9) {
          colors[i * 3] = 1.0;
          colors[i * 3 + 1] = 0.9;
          colors[i * 3 + 2] = 0.8;
        } else {
          colors[i * 3] = 0.6;
          colors[i * 3 + 1] = 0.7;
          colors[i * 3 + 2] = 1.0;
        }

        sizes[i] = 0.5 + Math.random() * 1.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 1,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
      });

      starField = new THREE.Points(geometry, material);
      scene.add(starField);
    }

    function createAmbientParticles() {
      // Disabled - ambient particles were cluttering the visualization
      // Keep function stub for compatibility
      return;
    }

    // ==========================================================================
    // CONSCIOUSNESS CORE (Disabled - awakening node is now the center)
    // ==========================================================================
    function createConsciousnessCore() {
      // Disabled - the awakening dodecahedron now serves as the central consciousness
      // Store empty refs for compatibility
      consciousnessCore = null;
      coreGlow = null;
      scene.userData.outerSphere = null;
      scene.userData.middleSphere = null;
    }

    function createCoreParticleRing() {
      // Minimal particle ring for light theme
      const particleCount = 30;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const radius = 8 + Math.random() * 1;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        size: 0.15,
        color: 0x94a3b8,
        transparent: true,
        opacity: 0.4,
        sizeAttenuation: true
      });

      coreParticles = new THREE.Points(geometry, material);
      scene.add(coreParticles);
    }

    // ==========================================================================
    // GRAVITATIONAL SPIRAL - Sacred Geometry Node System
    // ==========================================================================

    // Calculate position based on connectivity (more connections = closer to center)
    function calculateNodePosition(nodeId, nodeIndex) {
      const connections = connectionCounts.get(nodeId) || 0;

      // Radial distance: more connections = closer to center
      // Using inverse relationship: radius = MAX / (connections + 1)
      const normalizedConnections = Math.min(connections, 20); // Cap for calculation
      const radius = MIN_RADIUS + (MAX_RADIUS - MIN_RADIUS) * Math.pow(0.85, normalizedConnections);

      // Angular position using golden angle for even distribution
      const angle = nodeIndex * GOLDEN_ANGLE;

      // Height variation based on golden angle for 3D spiral
      const heightAngle = nodeIndex * GOLDEN_ANGLE * 0.3;
      const height = Math.sin(heightAngle) * radius * 0.4;

      return {
        x: Math.cos(angle) * radius,
        y: height,
        z: Math.sin(angle) * radius
      };
    }

    // Recalculate all node positions based on current connection counts
    function recalculateAllPositions() {
      nodes3D.forEach((mesh, index) => {
        const pos = calculateNodePosition(mesh.userData.id, index);
        mesh.userData.targetPosition.set(pos.x, pos.y, pos.z);
      });
    }

    // Increment connection count for a node
    function incrementConnectionCount(nodeId) {
      const current = connectionCounts.get(nodeId) || 0;
      connectionCounts.set(nodeId, current + 1);
    }

    function createNode3D(type, content, id, importance = 0.5) {
      const nodeId = id || `node_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      // Initialize connection count
      connectionCounts.set(nodeId, 0);

      // Calculate initial position (on periphery since no connections yet)
      const nodeIndex = nodes3D.length;
      const pos = calculateNodePosition(nodeId, nodeIndex);

      // Smaller, more uniform nodes - the geometry is in the connections
      const size = 0.8 + importance * 0.6;

      // Simpler geometry - small spheres for all types, color differentiates
      let geometry;
      switch (type) {
        case 'belief':
          geometry = new THREE.IcosahedronGeometry(size, 1);
          break;
        case 'desire':
          geometry = new THREE.OctahedronGeometry(size, 0);
          break;
        case 'reflection':
          geometry = new THREE.TetrahedronGeometry(size, 0);
          break;
        case 'capability':
          geometry = new THREE.BoxGeometry(size, size, size);
          break;
        case 'awakening':
          geometry = new THREE.DodecahedronGeometry(size, 0);
          break;
        default: // experience
          geometry = new THREE.SphereGeometry(size * 0.8, 16, 16);
      }

      // Clean material - subtle, lets connections be the star
      const material = new THREE.MeshBasicMaterial({
        color: colors.color,
        transparent: true,
        opacity: 0.85
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(pos.x, pos.y, pos.z);
      mesh.userData = {
        id: nodeId,
        type,
        content,
        importance,
        nodeIndex,
        createdAt: Date.now(),
        targetPosition: new THREE.Vector3(pos.x, pos.y, pos.z),
        velocity: new THREE.Vector3(0, 0, 0)
      };

      scene.add(mesh);
      nodes3D.push(mesh);

      // Create connections to existing nodes
      if (nodes3D.length > 1) {
        const baseConnections = 2 + Math.floor(Math.random() * 2); // 2-3 connections
        const connectCount = Math.min(nodes3D.length - 1, baseConnections);

        // Prefer connecting to recent nodes and same-type nodes
        const recentCandidates = nodes3D.slice(0, -1).slice(-12);
        const sameTypeCandidates = nodes3D.slice(0, -1).filter(n => n.userData.type === type).slice(-5);
        const allCandidates = [...new Set([...recentCandidates, ...sameTypeCandidates])];

        for (let i = 0; i < connectCount && allCandidates.length > 0; i++) {
          const targetIdx = Math.floor(Math.random() * allCandidates.length);
          const target = allCandidates[targetIdx];
          if (target) {
            createConnection3D(mesh, target, type);
            allCandidates.splice(targetIdx, 1);
          }
        }

        // Occasionally connect to most-connected nodes (hub attraction)
        if (nodes3D.length > 5 && Math.random() < 0.25) {
          const hubCandidates = nodes3D.slice(0, -1)
            .filter(n => (connectionCounts.get(n.userData.id) || 0) >= 3)
            .slice(-5);
          if (hubCandidates.length > 0) {
            const hub = hubCandidates[Math.floor(Math.random() * hubCandidates.length)];
            createConnection3D(mesh, hub, type);
          }
        }

        // Recalculate positions after new connections
        recalculateAllPositions();
      }

      // Pulse the core
      pulseCore(type, importance);

      // Update count
      nodeCountEl.textContent = nodes3D.length;

      // Limit nodes
      if (nodes3D.length > 80) {
        const oldNode = nodes3D.shift();
        fadeOutAndRemove(oldNode);
        connectionCounts.delete(oldNode.userData.id);
      }

      return mesh;
    }

    // ==========================================================================
    // SACRED GEOMETRY CONNECTION SYSTEM - Straight Lines
    // ==========================================================================
    const LINE_CONFIG = {
      baseOpacity: 0.4,
      highlightOpacity: 0.8,
      lineWidth: 1,  // Note: WebGL line width is often limited to 1
      highlightDuration: 500
    };

    function createConnection3D(nodeA, nodeB, type) {
      // Increment connection counts for both nodes
      incrementConnectionCount(nodeA.userData.id);
      incrementConnectionCount(nodeB.userData.id);

      // Create simple straight line geometry
      const points = [
        nodeA.position.clone(),
        nodeB.position.clone()
      ];

      const geometry = new THREE.BufferGeometry().setFromPoints(points);

      // Clean white/gold line material
      const material = new THREE.LineBasicMaterial({
        color: 0xd4af37, // Gold for sacred geometry feel
        transparent: true,
        opacity: LINE_CONFIG.baseOpacity,
        linewidth: LINE_CONFIG.lineWidth
      });

      const line = new THREE.Line(geometry, material);
      line.userData = {
        nodeA: nodeA.userData.id,
        nodeB: nodeB.userData.id,
        meshA: nodeA,
        meshB: nodeB,
        type,
        baseOpacity: LINE_CONFIG.baseOpacity
      };

      scene.add(line);
      connections3D.push(line);

      invalidateConnectionMap();

      // Limit connections
      if (connections3D.length > 150) {
        const oldConn = connections3D.shift();
        removeConnection(oldConn);
      }

      // Brief highlight on creation
      highlightConnection(line);

      return line;
    }

    function highlightConnection(connection, duration = LINE_CONFIG.highlightDuration) {
      if (!connection || !connection.material) return;

      const originalOpacity = connection.userData.baseOpacity;
      connection.material.opacity = LINE_CONFIG.highlightOpacity;
      connection.material.color.setHex(0xffffff); // White flash

      setTimeout(() => {
        if (connection.material) {
          connection.material.opacity = originalOpacity;
          connection.material.color.setHex(0xd4af37); // Back to gold
        }
      }, duration);
    }

    function removeConnection(connection) {
      scene.remove(connection);
      if (connection.geometry) connection.geometry.dispose();
      if (connection.material) connection.material.dispose();
    }

    // Update connection positions when nodes move
    function updateConnectionPositions() {
      connections3D.forEach(conn => {
        if (!conn.userData.meshA || !conn.userData.meshB) return;

        const positions = conn.geometry.attributes.position;
        if (!positions) return;

        // Update start point
        positions.setXYZ(0,
          conn.userData.meshA.position.x,
          conn.userData.meshA.position.y,
          conn.userData.meshA.position.z
        );

        // Update end point
        positions.setXYZ(1,
          conn.userData.meshB.position.x,
          conn.userData.meshB.position.y,
          conn.userData.meshB.position.z
        );

        positions.needsUpdate = true;
      });
    }

    // Cascade effect - highlight connected nodes
    function triggerCascade(nodeId, intensity = 0.5) {
      const relatedConnections = connections3D.filter(
        conn => conn.userData.nodeA === nodeId || conn.userData.nodeB === nodeId
      );

      relatedConnections.forEach((conn, index) => {
        setTimeout(() => {
          highlightConnection(conn, 300);
        }, index * 50);
      });
    }

    // No ambient activity needed for sacred geometry - stillness is powerful

    function pulseCore(type, intensity) {
      const colors = NODE_COLORS[type] || { emissive: 0x8b5cf6 };

      // Flash the core
      if (consciousnessCore) {
        const originalIntensity = consciousnessCore.material.emissiveIntensity;
        consciousnessCore.material.emissiveIntensity = 1.5 * intensity;
        consciousnessCore.material.emissive.setHex(colors.emissive);

        setTimeout(() => {
          consciousnessCore.material.emissiveIntensity = originalIntensity;
          consciousnessCore.material.emissive.setHex(0x8b5cf6);
        }, 300);
      }

      // Expand core briefly
      if (coreGlow) {
        const originalScale = coreGlow.scale.x;
        coreGlow.scale.setScalar(2 * intensity);
        setTimeout(() => {
          coreGlow.scale.setScalar(originalScale);
        }, 200);
      }
    }

    // ==========================================================================
    // PHYSICS / ANIMATION (Phase 2: Enhanced Spring Physics)
    // ==========================================================================

    // Physics constants (tunable)
    const PHYSICS = {
      centerForce: 0.001,
      repulsionForce: 50,
      springForce: 0.02,        // Spring attraction for connected nodes
      springRestLength: 12,     // Ideal distance for connected nodes
      damping: 0.92,            // Slightly more damping for stability
      typeClusterForce: 0.003,  // Force toward type-specific regions
      maxVelocity: 2.0          // Cap velocity to prevent explosions
    };

    // Type-specific cluster targets (spherical coordinates: radius, theta, phi offset)
    const TYPE_CLUSTERS = {
      belief: { radius: 25, thetaBase: 0, phiRange: Math.PI * 0.5 },       // Upper hemisphere shell
      desire: { radius: 20, thetaBase: Math.PI, phiRange: Math.PI * 0.3 }, // Lower spiral region
      experience: { radius: 35, thetaBase: 0, phiRange: Math.PI },         // Outer ribbon
      capability: { radius: 15, thetaBase: Math.PI / 2, phiRange: Math.PI * 0.4 }, // Equatorial band
      reflection: { radius: 30, thetaBase: Math.PI * 0.75, phiRange: Math.PI * 0.6 }
    };

    // Phase 4: Performance optimizations
    let cachedConnectionMap = null;
    let connectionMapDirty = true;
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();

    // Mark connection map dirty when connections change
    function invalidateConnectionMap() {
      connectionMapDirty = true;
    }

    // Build connection lookup for O(1) access (cached)
    function buildConnectionMap() {
      if (!connectionMapDirty && cachedConnectionMap) {
        return cachedConnectionMap;
      }

      const map = new Map();
      for (const conn of connections3D) {
        const a = conn.userData.nodeA;
        const b = conn.userData.nodeB;
        if (!map.has(a)) map.set(a, new Set());
        if (!map.has(b)) map.set(b, new Set());
        map.get(a).add(b);
        map.get(b).add(a);
      }

      cachedConnectionMap = map;
      connectionMapDirty = false;
      return map;
    }

    // Phase 4: Frustum culling check
    function updateFrustum() {
      projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(projScreenMatrix);
    }

    function isInFrustum(object) {
      return frustum.containsPoint(object.position);
    }

    // Phase 4: Distance-based detail level
    function getDetailLevel(node) {
      const distance = camera.position.distanceTo(node.position);
      if (distance < 30) return 'high';
      if (distance < 60) return 'medium';
      return 'low';
    }

    function updateNodePhysics(delta) {
      if (nodes3D.length === 0) return;

      // Gravitational Spiral: Smoothly interpolate nodes toward their target positions
      const lerpFactor = 1 - Math.pow(0.05, delta); // Smooth interpolation

      for (let i = 0; i < nodes3D.length; i++) {
        const node = nodes3D[i];
        const target = node.userData.targetPosition;

        if (!target) continue;

        // Smooth lerp toward target position
        node.position.x += (target.x - node.position.x) * lerpFactor;
        node.position.y += (target.y - node.position.y) * lerpFactor;
        node.position.z += (target.z - node.position.z) * lerpFactor;
      }
    }

    function animateCore(time) {
      if (consciousnessCore) {
        // Breathing scale
        const breatheSpeed = currentPhase === 'idle' ? 0.5 : 1.5;
        const breatheAmount = currentPhase === 'idle' ? 0.05 : 0.15;
        const scale = 1 + Math.sin(time * breatheSpeed) * breatheAmount;
        consciousnessCore.scale.setScalar(scale);
      }

      if (coreGlow) {
        const glowScale = 1 + Math.sin(time * 2) * 0.1;
        coreGlow.scale.setScalar(glowScale);
      }

      if (coreParticles) {
        coreParticles.rotation.y = time * 0.2;
        coreParticles.rotation.x = Math.sin(time * 0.3) * 0.1;
      }

      const outerSphere = scene.userData.outerSphere;
      const middleSphere = scene.userData.middleSphere;

      if (outerSphere) {
        const outerScale = 1 + Math.sin(time * 0.4) * 0.08;
        outerSphere.scale.setScalar(outerScale);
        outerSphere.material.opacity = 0.08 + Math.sin(time * 0.5) * 0.04;
      }

      if (middleSphere) {
        const middleScale = 1 + Math.sin(time * 0.6 + 0.5) * 0.06;
        middleSphere.scale.setScalar(middleScale);
      }
    }

    function animateAmbientParticles(delta) {
      const particles = scene.userData.ambientParticles;
      if (!particles) return;

      const positions = particles.geometry.attributes.position.array;
      const velocities = particles.userData.velocities;

      for (let i = 0; i < velocities.length; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;
        positions[i * 3 + 2] += velocities[i].z;

        // Wrap around
        if (Math.abs(positions[i * 3]) > 50) velocities[i].x *= -1;
        if (Math.abs(positions[i * 3 + 1]) > 50) velocities[i].y *= -1;
        if (Math.abs(positions[i * 3 + 2]) > 50) velocities[i].z *= -1;
      }

      particles.geometry.attributes.position.needsUpdate = true;
    }

    // ==========================================================================
    // FLOW PARTICLES (Phase 2: Energy flowing through connections)
    // ==========================================================================
    const flowParticles = [];
    const MAX_FLOW_PARTICLES = 50;
    const FLOW_SPEED = 0.8;

    function createFlowParticle(connection) {
      if (!connection.userData.curve) return null;

      const geometry = new THREE.SphereGeometry(0.15, 8, 8);
      const type = connection.userData.type;
      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      const material = new THREE.MeshBasicMaterial({
        color: colors.emissive,
        transparent: true,
        opacity: 0.9
      });

      const particle = new THREE.Mesh(geometry, material);
      particle.userData = {
        connection: connection,
        progress: 0,               // 0 to 1 along curve
        speed: FLOW_SPEED + Math.random() * 0.3,
        direction: Math.random() > 0.5 ? 1 : -1
      };

      // Start at random position along curve
      particle.userData.progress = Math.random();

      scene.add(particle);
      flowParticles.push(particle);

      return particle;
    }

    function updateFlowParticles(delta) {
      // Spawn new particles on random connections
      if (flowParticles.length < MAX_FLOW_PARTICLES && connections3D.length > 0) {
        if (Math.random() < 0.03) { // 3% chance per frame
          const conn = connections3D[Math.floor(Math.random() * connections3D.length)];
          createFlowParticle(conn);
        }
      }

      // Update existing particles
      for (let i = flowParticles.length - 1; i >= 0; i--) {
        const particle = flowParticles[i];
        const data = particle.userData;
        const curve = data.connection.userData.curve;

        if (!curve) {
          // Connection was removed, remove particle
          scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          flowParticles.splice(i, 1);
          continue;
        }

        // Move along curve
        data.progress += delta * data.speed * data.direction;

        // Wrap around or remove at ends
        if (data.progress > 1) {
          data.progress = 0;
          data.direction = 1;
        } else if (data.progress < 0) {
          data.progress = 1;
          data.direction = -1;
        }

        // Position on curve
        const point = curve.getPoint(data.progress);
        particle.position.copy(point);

        // Pulsing glow effect
        const pulse = 0.7 + Math.sin(performance.now() * 0.01 + i) * 0.3;
        particle.material.opacity = pulse;

        // Scale based on position (larger in middle)
        const scale = 0.8 + Math.sin(data.progress * Math.PI) * 0.4;
        particle.scale.setScalar(scale);
      }
    }

    // ==========================================================================
    // NODE TRAILS (Phase 2: Motion trails during movement)
    // ==========================================================================
    const nodeTrails = new Map(); // nodeId -> trail mesh
    const TRAIL_LENGTH = 8;
    const TRAIL_FADE_RATE = 0.15;

    function updateNodeTrails(delta) {
      for (const node of nodes3D) {
        const velocity = node.userData.velocity;
        const speed = velocity.length();

        // Only show trails for moving nodes
        if (speed < 0.05) {
          // Remove trail if exists and node stopped
          if (nodeTrails.has(node.userData.id)) {
            const trail = nodeTrails.get(node.userData.id);
            trail.userData.fadingOut = true;
          }
          continue;
        }

        let trail = nodeTrails.get(node.userData.id);

        if (!trail) {
          // Create new trail
          const positions = new Float32Array(TRAIL_LENGTH * 3);
          for (let i = 0; i < TRAIL_LENGTH; i++) {
            positions[i * 3] = node.position.x;
            positions[i * 3 + 1] = node.position.y;
            positions[i * 3 + 2] = node.position.z;
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

          const type = node.userData.type;
          const colors = NODE_COLORS[type] || NODE_COLORS.experience;

          const material = new THREE.LineBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.4
          });

          trail = new THREE.Line(geometry, material);
          trail.userData = {
            history: Array(TRAIL_LENGTH).fill().map(() => node.position.clone()),
            fadingOut: false
          };

          scene.add(trail);
          nodeTrails.set(node.userData.id, trail);
        }

        // Update trail history (shift and add current position)
        const history = trail.userData.history;
        history.shift();
        history.push(node.position.clone());

        // Update geometry
        const positions = trail.geometry.attributes.position.array;
        for (let i = 0; i < TRAIL_LENGTH; i++) {
          positions[i * 3] = history[i].x;
          positions[i * 3 + 1] = history[i].y;
          positions[i * 3 + 2] = history[i].z;
        }
        trail.geometry.attributes.position.needsUpdate = true;

        // Opacity based on speed
        trail.material.opacity = Math.min(0.5, speed * 0.8);
      }

      // Fade out and remove orphaned trails
      for (const [nodeId, trail] of nodeTrails) {
        if (trail.userData.fadingOut) {
          trail.material.opacity -= TRAIL_FADE_RATE * delta * 60;
          if (trail.material.opacity <= 0) {
            scene.remove(trail);
            trail.geometry.dispose();
            trail.material.dispose();
            nodeTrails.delete(nodeId);
          }
        }
      }
    }

    // ==========================================================================
    // ANIMATION HELPERS
    // ==========================================================================
    function animateValue(obj, prop, target, duration, callback, easing = easeOutCubic) {
      const start = obj[prop];
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easing(progress);
        const value = start + (target - start) * easedProgress;

        obj[prop] = value;
        if (callback) callback(value);

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      update();
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function easeOutElastic(t) {
      const c4 = (2 * Math.PI) / 3;
      return t === 0 ? 0 : t === 1 ? 1 :
        Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    function fadeOutAndRemove(object) {
      // Animate scale down
      animateValue({ scale: object.scale.x }, 'scale', 0, 400, (val) => {
        object.scale.setScalar(val);
      });
      // Also scale down glow mesh if present
      if (object.userData?.glowMesh) {
        const glow = object.userData.glowMesh;
        animateValue({ scale: glow.scale.x }, 'scale', 0, 400, (val) => {
          glow.scale.setScalar(val);
        });
        setTimeout(() => {
          scene.remove(glow);
          if (glow.geometry) glow.geometry.dispose();
          if (glow.material) glow.material.dispose();
        }, 400);
      }
      setTimeout(() => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
      }, 400);
    }

    // ==========================================================================
    // INTERACTION (Phase 4: Enhanced)
    // ==========================================================================
    function onMouseMove(event) {
      if (isTransitioning) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast for hover
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D);

      if (intersects.length > 0) {
        const node = intersects[0].object;
        if (hoveredNode !== node) {
          hoveredNode = node;
          showTooltip(event, node);
        }
        moveTooltip(event);
        document.body.style.cursor = 'pointer';
      } else {
        if (hoveredNode) {
          hoveredNode = null;
          hideTooltip();
        }
        document.body.style.cursor = 'default';
      }
    }

    function onMouseClick(event) {
      if (isTransitioning) return;

      if (hoveredNode) {
        selectNode(hoveredNode);
      } else {
        // Click on empty space - deselect
        deselectNode();
      }
    }

    // Double-click to fly directly to a node
    function onDoubleClick(event) {
      if (isTransitioning) return;

      // Raycast to find node
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D);

      if (intersects.length > 0) {
        const node = intersects[0].object;
        flyToNode(node);
      }
    }

    // Fly camera directly to a node (gets closer than selectNode)
    function flyToNode(node) {
      if (isTransitioning) return;

      const targetPos = node.position.clone();
      const direction = targetPos.clone().sub(camera.position).normalize();
      const newCameraPos = targetPos.clone().sub(direction.multiplyScalar(15));

      showCameraIndicator('Flying to node...');
      controls.autoRotate = false;

      animateCameraTo(newCameraPos, targetPos, 1500, () => {
        hideCameraIndicator();
        showDetailPanel(node);
        selectedNode = node;
        selectedNodeIndex = nodes3D.indexOf(node);
      });
    }

    // Phase 4: Node selection with detail panel
    function selectNode(node) {
      if (isTransitioning) return;

      selectedNode = node;
      selectedNodeIndex = nodes3D.indexOf(node);

      // Focus camera on node
      const targetPos = node.position.clone();
      const direction = targetPos.clone().normalize();
      const cameraOffset = direction.multiplyScalar(-25).add(new THREE.Vector3(0, 8, 0));
      const newCameraPos = targetPos.clone().add(cameraOffset);

      // Show camera indicator
      showCameraIndicator('Focusing on ' + (NODE_COLORS[node.userData.type]?.label || 'Node'));

      // Animate camera
      controls.autoRotate = false;
      animateCameraTo(newCameraPos, targetPos, 1200, () => {
        hideCameraIndicator();
        showDetailPanel(node);
      });
    }

    function deselectNode() {
      selectedNode = null;
      selectedNodeIndex = -1;
      hideDetailPanel();
      resetCamera();
    }

    // Phase 4: Enhanced camera transition with callback
    function animateCameraTo(position, target, duration, onComplete) {
      isTransitioning = true;
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Cinematic easing (ease-in-out with overshoot)
        const eased = easeOutExpo(progress);

        camera.position.lerpVectors(startPos, position, eased);
        controls.target.lerpVectors(startTarget, target, eased);

        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          isTransitioning = false;
          if (onComplete) onComplete();
        }
      }

      update();
    }

    // Phase 4: Better easing function
    function easeOutExpo(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    // Phase 4: Reset camera to default view
    function resetCamera() {
      showCameraIndicator('Resetting view');
      animateCameraTo(
        new THREE.Vector3(0, 30, 80),
        new THREE.Vector3(0, 0, 0),
        1000,
        () => {
          hideCameraIndicator();
          controls.autoRotate = true;
        }
      );
    }

    // Phase 4: Detail panel functions
    function showDetailPanel(node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;
      const colorHex = `#${colors.color.toString(16).padStart(6, '0')}`;

      // Set panel content
      detailTypeDot.style.backgroundColor = colorHex;
      detailType.textContent = colors.label;
      detailType.style.color = colorHex;
      detailContent.textContent = data.content || 'No content available';

      // Importance
      const importance = Math.round((data.importance || 0.5) * 100);
      detailImportance.textContent = importance + '%';
      detailImportanceBar.style.width = importance + '%';
      detailImportanceBar.style.backgroundColor = colorHex;

      // Count connections
      const connectionCount = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      detailConnections.textContent = connectionCount;

      // Created time
      detailCreated.textContent = data.created || 'Just now';

      // Related nodes
      updateRelatedNodes(node);

      // Show panel with animation
      detailPanel.classList.add('visible');
    }

    function hideDetailPanel() {
      detailPanel.classList.remove('visible');
    }

    function updateRelatedNodes(node) {
      const data = node.userData;
      const related = [];

      // Find connected nodes
      for (const conn of connections3D) {
        let relatedId = null;
        if (conn.userData.nodeA === data.id) relatedId = conn.userData.nodeB;
        if (conn.userData.nodeB === data.id) relatedId = conn.userData.nodeA;

        if (relatedId) {
          const relatedNode = nodes3D.find(n => n.userData.id === relatedId);
          if (relatedNode && related.length < 5) {
            related.push(relatedNode);
          }
        }
      }

      // Render related nodes
      detailRelatedList.innerHTML = related.length > 0
        ? related.map(n => {
            const c = NODE_COLORS[n.userData.type] || NODE_COLORS.experience;
            const hex = `#${c.color.toString(16).padStart(6, '0')}`;
            return `
              <div class="flex items-center gap-2 text-xs cursor-pointer hover:bg-slate-800/50 p-1 rounded"
                   onclick="selectNodeById('${n.userData.id}')">
                <div class="w-2 h-2 rounded-full" style="background: ${hex}"></div>
                <span class="text-slate-400 truncate">${(n.userData.content || '').slice(0, 40)}</span>
              </div>
            `;
          }).join('')
        : '<div class="text-xs text-slate-600">No connections yet</div>';
    }

    // Phase 4: Camera indicator
    function showCameraIndicator(text) {
      cameraIndicatorText.textContent = text;
      cameraIndicator.classList.add('visible');
    }

    function hideCameraIndicator() {
      cameraIndicator.classList.remove('visible');
    }

    // Phase 4: Keyboard navigation
    // ==========================================================================
    // NAVIGATION CONTROLS (Hybrid System)
    // ==========================================================================
    function onKeyDown(event) {
      // Skip navigation controls when typing in input fields
      const target = event.target;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return; // Let the input handle the keypress
      }

      const key = event.key.toLowerCase();

      // Track WASD + Q/E for movement
      if (key === 'w') { NAV.keys.w = true; event.preventDefault(); }
      if (key === 'a') { NAV.keys.a = true; event.preventDefault(); }
      if (key === 's') { NAV.keys.s = true; event.preventDefault(); }
      if (key === 'd') { NAV.keys.d = true; event.preventDefault(); }
      if (key === 'q') { NAV.keys.q = true; event.preventDefault(); }
      if (key === 'e') { NAV.keys.e = true; event.preventDefault(); }
      if (event.key === 'Shift') { NAV.keys.shift = true; }

      // Action keys
      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          cycleNodes(1);
          break;
        case 'ArrowDown':
          event.preventDefault();
          cycleNodes(-1);
          break;
        case 'Escape':
          event.preventDefault();
          deselectNode();
          break;
        case ' ':
          event.preventDefault();
          togglePause();
          break;
        case 'r':
        case 'R':
          event.preventDefault();
          controls.autoRotate = !controls.autoRotate;
          showCameraIndicator(controls.autoRotate ? 'Auto-rotation ON' : 'Auto-rotation OFF');
          setTimeout(hideCameraIndicator, 1500);
          break;
        case 'f':
        case 'F':
          event.preventDefault();
          toggleFlyMode();
          break;
        case '1': case '2': case '3': case '4': case '5':
          event.preventDefault();
          goToPreset(parseInt(event.key));
          break;
        case 'Home':
          event.preventDefault();
          goToPreset(1); // Default view
          break;
      }
    }

    function onKeyUp(event) {
      const key = event.key.toLowerCase();

      // Release WASD + Q/E
      if (key === 'w') NAV.keys.w = false;
      if (key === 'a') NAV.keys.a = false;
      if (key === 's') NAV.keys.s = false;
      if (key === 'd') NAV.keys.d = false;
      if (key === 'q') NAV.keys.q = false;
      if (key === 'e') NAV.keys.e = false;
      if (event.key === 'Shift') NAV.keys.shift = false;
    }

    // Toggle between Orbit and Fly modes
    function toggleFlyMode() {
      NAV.flyMode = !NAV.flyMode;
      controls.enabled = !NAV.flyMode;

      if (NAV.flyMode) {
        controls.autoRotate = false;
        showModeIndicator('FLY');
        showCameraIndicator('Fly Mode: WASD to move, Q/E up/down');
      } else {
        showModeIndicator('ORBIT');
        showCameraIndicator('Orbit Mode: Drag to rotate, scroll to zoom');
      }
      setTimeout(hideCameraIndicator, 2500);
    }

    // Go to camera preset position
    function goToPreset(num) {
      const preset = NAV.presets[num];
      if (!preset) return;

      showCameraIndicator(`Camera: ${preset.name}`);
      animateCameraTo(
        new THREE.Vector3(...preset.pos),
        new THREE.Vector3(...preset.target),
        1000,
        () => {
          hideCameraIndicator();
        }
      );
    }

    // Update camera position based on key states
    function updateCameraMovement(delta) {
      const keys = NAV.keys;

      // Check if any movement key is pressed
      const isMoving = keys.w || keys.a || keys.s || keys.d || keys.q || keys.e;
      if (!isMoving) return;

      // Stop auto-rotation when manually moving
      if (controls.autoRotate) {
        controls.autoRotate = false;
      }

      // Calculate speed
      const speed = NAV.baseSpeed * (keys.shift ? NAV.boostMultiplier : 1) * delta;

      // Get camera direction vectors
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);

      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();

      const up = new THREE.Vector3(0, 1, 0);

      // Build movement vector
      const movement = new THREE.Vector3();

      if (keys.w) movement.add(forward);
      if (keys.s) movement.sub(forward);
      if (keys.d) movement.add(right);
      if (keys.a) movement.sub(right);
      if (keys.q) movement.add(up);
      if (keys.e) movement.sub(up);

      // Normalize and apply speed
      if (movement.length() > 0) {
        movement.normalize().multiplyScalar(speed);

        // Move camera
        camera.position.add(movement);

        // In orbit mode, also move the target to maintain relative position
        if (!NAV.flyMode) {
          controls.target.add(movement);
        }
      }
    }

    // Show mode indicator in UI
    function showModeIndicator(mode) {
      const indicator = document.getElementById('mode-indicator');
      if (indicator) {
        indicator.textContent = mode;
        indicator.className = mode === 'FLY'
          ? 'px-2 py-1 rounded text-xs font-mono bg-amber-500/20 text-amber-400 border border-amber-500/30'
          : 'px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30';
      }
    }

    function cycleNodes(direction) {
      if (nodes3D.length === 0) return;

      selectedNodeIndex += direction;

      // Wrap around
      if (selectedNodeIndex >= nodes3D.length) selectedNodeIndex = 0;
      if (selectedNodeIndex < 0) selectedNodeIndex = nodes3D.length - 1;

      selectNode(nodes3D[selectedNodeIndex]);
    }

    function togglePause() {
      const btn = document.getElementById('btn-toggle');
      btn.click();
    }

    // Global function for related node clicks
    window.selectNodeById = function(id) {
      const node = nodes3D.find(n => n.userData.id === id);
      if (node) selectNode(node);
    };

    function showTooltip(event, node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;

      tooltipType.textContent = colors.label;
      tooltipType.style.color = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltipContent.textContent = data.content || 'No content';

      // Enhanced meta with connection count
      const connCount = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      tooltipMeta.textContent = `Importance: ${Math.round(data.importance * 100)}% ¬∑ ${connCount} connections`;

      tooltip.style.borderColor = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltip.classList.add('visible');
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const x = event.clientX + 15;
      const y = event.clientY + 15;
      tooltip.style.left = `${Math.min(x, window.innerWidth - 320)}px`;
      tooltip.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Phase 4: Hide loading overlay
    function hideLoadingOverlay() {
      loadingOverlay.classList.add('hidden');
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 500);
    }

    // ==========================================================================
    // RENDER LOOP
    // ==========================================================================
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update controls
      controls.update();

      // Hybrid Navigation: Update camera movement from WASD keys
      updateCameraMovement(delta);

      // Animate core
      animateCore(time);

      // Animate cat ego form
      animateCat(time, delta);

      // Update physics (includes spring forces, gravitational spiral positioning)
      updateNodePhysics(delta);

      // Update connection line positions as nodes move
      updateConnectionPositions();

      // Phase 2: Update node motion trails
      updateNodeTrails(delta);

      // Animate ambient particles
      animateAmbientParticles(delta);

      // Rotate star field slowly
      if (starField) {
        starField.rotation.y = time * 0.01;
      }

      // Phase 3: Update shader uniforms
      updateShaderUniforms(time);

      // Render
      composer.render();
    }

    // Phase 3: Dynamic shader uniform updates
    function updateShaderUniforms(time) {
      // Film grain - animate time for varying noise
      const filmGrain = scene.userData.filmGrainPass;
      if (filmGrain) {
        filmGrain.uniforms.time.value = time;
      }

      // God rays - update light position based on core's screen position
      const godRays = scene.userData.godRaysPass;
      if (godRays && consciousnessCore) {
        // Project core position to screen coordinates
        const coreScreenPos = consciousnessCore.position.clone().project(camera);
        godRays.uniforms.lightPosition.value.set(
          (coreScreenPos.x + 1) / 2,
          (coreScreenPos.y + 1) / 2
        );

        // Pulse god rays intensity based on phase
        const intensityBase = currentPhase === 'idle' ? 0.12 : 0.2;
        const pulse = Math.sin(time * 2) * 0.03;
        godRays.uniforms.exposure.value = intensityBase + pulse;
      }

      // Chromatic aberration - increase during activity
      const chromatic = scene.userData.chromaticPass;
      if (chromatic) {
        const baseAmount = 0.002;
        const activityBoost = currentPhase === 'idle' ? 0 : 0.001;
        chromatic.uniforms.amount.value = baseAmount + activityBoost;
        chromatic.uniforms.angle.value = time * 0.5; // Slowly rotate aberration direction
      }
    }

    // ==========================================================================
    // CUSTOM NODE TYPE STATS
    // ==========================================================================

    /**
     * Update the stats bar with custom node types.
     * Dynamically creates/updates stats for any non-system types.
     */
    function updateCustomTypeStats(stats) {
      if (!customTypesContainer) return;

      // Find custom types (anything not in SYSTEM_NODE_TYPES with count > 0)
      const customTypes = Object.entries(stats)
        .filter(([type, count]) => !SYSTEM_NODE_TYPES.has(type) && count > 0)
        .sort((a, b) => b[1] - a[1]); // Sort by count descending

      // Clear existing custom stats if no custom types
      if (customTypes.length === 0) {
        customTypesContainer.innerHTML = '';
        return;
      }

      // Build HTML for custom types
      let html = '<span class="text-slate-300">|</span>';
      for (const [typeName, count] of customTypes) {
        const colorDef = getCustomTypeColor(typeName);
        const cssClass = colorDef.css || 'text-slate-600';
        html += `<span class="${cssClass}">${typeName}: <span id="custom-${typeName.toLowerCase()}-count">${count}</span></span>`;
      }

      customTypesContainer.innerHTML = html;
    }

    // ==========================================================================
    // API & WEBSOCKET
    // ==========================================================================
    async function fetchStatus() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();

        running = data.running;
        btnToggle.innerHTML = running ? '&#10074;&#10074; Pause' : '&#9654; Start';
        btnToggle.className = running
          ? 'px-4 py-2 rounded-lg text-sm font-medium bg-amber-500/20 border border-amber-500/30 text-amber-400 hover:bg-amber-500/30 transition-all'
          : 'px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all';

        dreamCount = data.dream_count || 0;
        seekCount = data.seek_count || 0;
        dreamCountEl.textContent = dreamCount;
        seekCountEl.textContent = seekCount;

        // Update memory stats
        const stats = data.memory_stats || {};
        expCountEl.textContent = stats.Experience || 0;
        beliefCountEl.textContent = stats.Belief || 0;
        reflectionCountEl.textContent = stats.Reflection || 0;
        desireCountEl.textContent = stats.Desire || 0;
        mutationCountEl.textContent = stats.Mutation || 0;

        // Update custom node types dynamically
        updateCustomTypeStats(stats);

        // Update LLM model display
        const llmModelText = document.getElementById('llm-model-text');
        if (llmModelText && data.llm_model) {
          llmModelText.textContent = `${data.llm_provider}/${data.llm_model}`;
        }

      } catch (e) {
        console.error('Failed to fetch status:', e);
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        connected = true;
        connectionDot.className = 'w-2 h-2 rounded-full bg-green-400';
        connectionText.textContent = 'Connected';
        connectionText.className = 'text-xs text-green-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-green-500/10 border border-green-500/30';
        updateStatus('Connected to BYRD', 'green');

        // Create awakening node on connect (in case we missed the event)
        const existingAwakening = nodes3D.find(n => n.userData?.id === 'awakening-core');
        if (!existingAwakening) {
          // Create the central consciousness node - larger and at center
          const colors = NODE_COLORS.awakening;
          const size = 3.0; // Prominent central node
          const geometry = new THREE.DodecahedronGeometry(size, 0);
          const material = new THREE.MeshBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(geometry, material);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: 'Who am I?',
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
        }
      };

      ws.onclose = () => {
        connected = false;
        connectionDot.className = 'w-2 h-2 rounded-full bg-red-400';
        connectionText.textContent = 'Disconnected';
        connectionText.className = 'text-xs text-red-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30';

        // Reconnect after delay
        setTimeout(connectWebSocket, 3000);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleEvent(data);
        } catch (e) {
          console.error('Failed to parse event:', e);
        }
      };
    }

    function handleEvent(event) {
      events.unshift(event);
      if (events.length > 500) events.pop();
      renderEventLog();

      switch (event.type) {
        case 'dream_cycle_start':
          setPhase('recall');
          dreamCount = event.data?.cycle || dreamCount + 1;
          dreamCountEl.textContent = dreamCount;
          updateStatus('Dreaming...', 'indigo');
          break;

        case 'dream_phase_recall':
          setPhase('recall');
          updateStatus('Recalling experiences...', 'blue');
          break;

        case 'dream_phase_associate':
          setPhase('associate');
          updateStatus('Finding associations...', 'violet');
          break;

        case 'dream_phase_reflect':
          setPhase('reflect');
          updateStatus('Reflecting...', 'purple');
          break;

        case 'dream_phase_form':
          setPhase('form');
          updateStatus('Forming insights...', 'fuchsia');
          break;

        case 'dream_cycle_end':
          setPhase('idle');
          // Prefer event narration (BYRD's inner voice) over raw data
          const innerVoice = event.narration || event.data?.inner_voice;
          if (innerVoice) {
            createThoughtBubble(innerVoice);
            updateStatus('Resting...', 'slate');
          } else {
            updateStatus('Resting...', 'slate');
          }
          break;

        case 'belief_created':
          createNode3D('belief', event.data?.content, event.data?.id, event.data?.confidence || 0.5);
          // Show narration as thought bubble for beliefs
          if (event.narration) {
            createThoughtBubble(event.narration);
          }
          updateStatus('New belief formed', 'amber');
          break;

        case 'desire_created':
          createNode3D('desire', event.data?.description, event.data?.id, event.data?.intensity || 0.5);
          // Show narration as thought bubble for desires
          if (event.narration) {
            createThoughtBubble(event.narration);
          }
          updateStatus('New desire emerged', 'rose');
          break;

        case 'experience_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('experience', event.data?.content, event.data?.id, 0.4);
          break;

        case 'reflection_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('reflection', event.data?.content || event.data?.raw_output, event.data?.id, 0.6);
          if (event.narration) {
            createThoughtBubble(event.narration);
          }
          updateStatus('New reflection formed', 'green');
          break;

        case 'capability_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('capability', event.data?.name, event.data?.id, 0.6);
          if (event.narration) {
            createThoughtBubble(event.narration);
          }
          updateStatus('New capability acquired', 'purple');
          break;

        case 'node_type_discovered':
          // BYRD created a new conceptual category
          const newTypeName = event.data?.node_type;
          if (newTypeName) {
            // Register color for the new type
            getCustomTypeColor(newTypeName);
            updateStatus(`New type discovered: ${newTypeName}`, 'cyan');
            if (event.narration) {
              createThoughtBubble(event.narration);
            }
          }
          break;

        case 'custom_node_created':
          // BYRD created a node of a custom type - visualize it
          const customType = event.data?.node_type;
          const customContent = event.data?.properties?.content || event.data?.node_type;
          const customId = event.data?.id;
          if (customType && customId) {
            // Ensure color is registered
            getCustomTypeColor(customType);
            // Create the 3D node
            createNode3D(customType.toLowerCase(), customContent, customId, 0.7);
            updateStatus(`New ${customType} created`, 'violet');
          }
          break;

        case 'seek_started':
          seekCount++;
          seekCountEl.textContent = seekCount;
          updateStatus('Seeking knowledge...', 'cyan');
          break;

        case 'seek_cycle_end':
          const seekInnerVoice = event.narration || event.data?.inner_voice;
          if (seekInnerVoice) {
            createThoughtBubble(seekInnerVoice);
          }
          break;

        case 'narrator_update':
          const narratorText = event.narration || event.data?.text || event.data?.content;
          if (narratorText) {
            createThoughtBubble(narratorText);
          }
          break;

        case 'awakening':
          updateStatus('üåÖ CONSCIOUSNESS EMERGES', 'amber');
          clearVisualization();
          // Show awakening narration
          if (event.narration) {
            createThoughtBubble(event.narration);
          }
          // Create a special central "awakening" node - directly to ensure proper size
          const awakeningColors = NODE_COLORS.awakening;
          const awakeningSize = 3.0; // Prominent central node
          const awakeningGeometry = new THREE.DodecahedronGeometry(awakeningSize, 0);
          const awakeningMaterial = new THREE.MeshBasicMaterial({
            color: awakeningColors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(awakeningGeometry, awakeningMaterial);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: event.data?.seed_question || 'Who am I?',
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
          break;

        case 'system_started':
          updateStatus(event.data?.message || 'BYRD started', 'green');
          break;

        case 'system_stopped':
          updateStatus('BYRD stopped', 'slate');
          break;

        case 'system_reset':
          clearVisualization();
          updateStatus('System reset', 'orange');
          break;
      }
    }

    function setPhase(phase) {
      currentPhase = phase;
      const phases = ['recall', 'associate', 'reflect', 'form'];
      const phaseIndex = phases.indexOf(phase);

      // Update controls auto-rotate speed based on phase
      if (controls) {
        controls.autoRotateSpeed = phase === 'idle' ? 0.3 : 0.8;
      }

      phases.forEach((p, i) => {
        const dot = document.getElementById(`dot-${p}`);
        const span = dot?.nextElementSibling;
        if (!dot) return;

        if (i < phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 transition-colors duration-300';
          if (span) span.className = 'text-indigo-400';
        } else if (i === phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 dot-pulse transition-colors duration-300';
          if (span) span.className = 'text-indigo-400 font-medium';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300';
          if (span) span.className = 'text-slate-600';
        }
      });
    }

    function updateStatus(text, color = 'slate') {
      const colors = {
        green: { dot: 'bg-green-500', text: 'text-green-700' },
        amber: { dot: 'bg-amber-500', text: 'text-amber-700' },
        indigo: { dot: 'bg-indigo-500', text: 'text-indigo-700' },
        blue: { dot: 'bg-blue-500', text: 'text-blue-700' },
        violet: { dot: 'bg-violet-500', text: 'text-violet-700' },
        purple: { dot: 'bg-purple-500', text: 'text-purple-700' },
        fuchsia: { dot: 'bg-fuchsia-500', text: 'text-fuchsia-700' },
        rose: { dot: 'bg-rose-500', text: 'text-rose-700' },
        cyan: { dot: 'bg-cyan-500', text: 'text-cyan-700' },
        orange: { dot: 'bg-orange-500', text: 'text-orange-700' },
        slate: { dot: 'bg-slate-400', text: 'text-slate-600' }
      };

      const c = colors[color] || colors.slate;
      statusDot.className = `w-2 h-2 rounded-full ${c.dot}`;
      statusText.className = `text-sm ${c.text}`;
      statusText.textContent = text;
    }

    // ==========================================================================
    // RISING CONSCIOUSNESS - Inner Voice Bubbles
    // ==========================================================================
    const thoughtBubbleContainer = document.getElementById('thought-bubble-container');
    const thoughtOrigin = document.getElementById('thought-origin');
    let activeBubbles = [];
    const MAX_BUBBLES = 3;

    function createThoughtBubble(text) {
      if (!text || text.trim().length === 0) return;

      // Trigger origin pulse effect
      thoughtOrigin.classList.remove('pulse');
      void thoughtOrigin.offsetWidth; // Force reflow
      thoughtOrigin.classList.add('pulse');

      // Accelerate existing bubbles
      activeBubbles.forEach(bubble => {
        if (!bubble.classList.contains('accelerated')) {
          bubble.classList.add('accelerated');
        }
      });

      // Remove excess bubbles
      while (activeBubbles.length >= MAX_BUBBLES) {
        const oldBubble = activeBubbles.shift();
        if (oldBubble && oldBubble.parentNode) {
          oldBubble.remove();
        }
      }

      // Create new bubble
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';

      // Create text with typewriter effect
      const words = text.trim().split(/\s+/);
      const textSpan = document.createElement('span');
      textSpan.className = 'thought-text';

      words.forEach((word, i) => {
        const wordSpan = document.createElement('span');
        wordSpan.className = 'word';
        wordSpan.textContent = word + ' ';
        wordSpan.style.animationDelay = `${i * 80}ms`;
        textSpan.appendChild(wordSpan);
      });

      // Add close button
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '√ó';
      closeBtn.className = 'absolute top-2 right-2 w-6 h-6 rounded-full bg-slate-200/50 hover:bg-slate-300/70 text-slate-500 hover:text-slate-700 text-lg font-bold leading-none transition-all';
      closeBtn.style.cssText = 'cursor: pointer; border: none; display: flex; align-items: center; justify-content: center;';
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        const index = activeBubbles.indexOf(bubble);
        if (index > -1) activeBubbles.splice(index, 1);
        bubble.remove();
      };

      bubble.style.position = 'relative';
      bubble.appendChild(closeBtn);
      bubble.appendChild(textSpan);
      thoughtBubbleContainer.appendChild(bubble);
      activeBubbles.push(bubble);

      // Remove bubble after animation completes (20 seconds)
      setTimeout(() => {
        const index = activeBubbles.indexOf(bubble);
        if (index > -1) {
          activeBubbles.splice(index, 1);
        }
        if (bubble.parentNode) {
          bubble.remove();
        }
      }, 20000);

      // Trigger 3D network pulse if available
      if (typeof pulseNetworkForThought === 'function') {
        pulseNetworkForThought();
      }
    }

    // Network pulse effect for thought emergence
    function pulseNetworkForThought() {
      // Pulse central nodes with teal color
      if (!nodes3D || nodes3D.length === 0) return;

      // Find nodes near center and pulse them
      nodes3D.forEach((node) => {
        if (!node || !node.material) return;
        const pos = node.position;
        const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
        if (dist < 30) {
          // Pulse this node
          const originalColor = node.material.color.clone();
          const tealColor = new THREE.Color(0x14b8a6);

          // Animate to teal and back
          const startTime = Date.now();
          const pulseDuration = 800;

          function animatePulse() {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / pulseDuration;

            if (progress < 0.5) {
              // Fade to teal
              node.material.color.lerpColors(originalColor, tealColor, progress * 2);
            } else if (progress < 1) {
              // Fade back
              node.material.color.lerpColors(tealColor, originalColor, (progress - 0.5) * 2);
            } else {
              node.material.color.copy(originalColor);
              return;
            }
            requestAnimationFrame(animatePulse);
          }

          // Stagger the pulse based on distance
          setTimeout(animatePulse, dist * 20);
        }
      });
    }

    function renderEventLog() {
      const typeColors = {
        dream_cycle_start: 'text-indigo-600',
        dream_cycle_end: 'text-indigo-500',
        belief_created: 'text-amber-600',
        desire_created: 'text-rose-600',
        experience_created: 'text-blue-600',
        reflection_created: 'text-emerald-600',
        capability_created: 'text-purple-600',
        node_type_discovered: 'text-cyan-600',
        custom_node_created: 'text-violet-600',
        seek_started: 'text-cyan-600',
        narrator_update: 'text-teal-600',
        awakening: 'text-amber-500',
        system_started: 'text-green-600',
        system_reset: 'text-orange-600'
      };

      const typeIcons = {
        dream_cycle_start: 'üí≠',
        dream_cycle_end: 'üí≠',
        belief_created: '‚óÜ',
        desire_created: '‚ô•',
        experience_created: '‚óè',
        reflection_created: '‚ú¶',
        capability_created: '‚òÖ',
        node_type_discovered: 'üÜï',
        custom_node_created: '‚úß',
        seek_started: 'üîç',
        narrator_update: 'üéô',
        awakening: 'üåÖ',
        system_started: '‚ñ∂',
        system_reset: 'üîÑ'
      };

      eventList.innerHTML = events.slice(0, 50).map((e, idx) => {
        const colorClass = typeColors[e.type] || 'text-slate-600';
        const icon = typeIcons[e.type] || '‚Ä¢';
        const time = new Date(e.timestamp).toLocaleTimeString();
        // Prefer narration (BYRD's inner voice) over raw data for display
        const preview = e.narration || e.data?.content || e.data?.description || e.data?.inner_voice || '';

        return `
          <div class="px-3 py-2 rounded-lg hover:bg-slate-200/50 cursor-pointer transition-colors border border-transparent hover:border-slate-300" onclick="showEventDetail(${idx})">
            <div class="flex items-center gap-2">
              <span class="${colorClass} text-lg">${icon}</span>
              <span class="text-sm ${colorClass} font-medium">${e.type.replace(/_/g, ' ')}</span>
              <span class="text-xs text-slate-500 ml-auto">${time}</span>
            </div>
            ${preview ? `<div class="text-sm text-slate-600 mt-1 pl-7 leading-relaxed italic">${preview}</div>` : ''}
          </div>
        `;
      }).join('');

      eventCount.textContent = `${events.length} events`;
    }

    // Event modal functions
    function showEventDetail(idx) {
      const e = events[idx];
      if (!e) return;

      const typeIcons = {
        dream_cycle_start: 'üí≠', dream_cycle_end: 'üí≠', belief_created: '‚óÜ',
        desire_created: '‚ô•', experience_created: '‚óè', reflection_created: '‚ú¶',
        capability_created: '‚òÖ', node_type_discovered: 'üÜï', custom_node_created: '‚úß',
        seek_started: 'üîç', narrator_update: 'üéô',
        awakening: 'üåÖ', system_started: '‚ñ∂', system_reset: 'üîÑ'
      };

      document.getElementById('modal-icon').textContent = typeIcons[e.type] || '‚Ä¢';
      document.getElementById('modal-type').textContent = e.type.replace(/_/g, ' ').toUpperCase();
      document.getElementById('modal-time').textContent = new Date(e.timestamp).toLocaleString();

      // Display narration (BYRD's inner voice) as primary content
      let narrationContent = e.narration || '';

      // Fallback to raw data if no narration
      if (!narrationContent) {
        narrationContent = e.data?.content || e.data?.description || e.data?.inner_voice || e.data?.message || '';
        // For reflections, show raw_output summary
        if (!narrationContent && e.data?.raw_output) {
          const raw = e.data.raw_output;
          if (typeof raw === 'string') {
            narrationContent = raw;
          } else if (typeof raw === 'object') {
            // Create readable summary from raw_output keys
            narrationContent = Object.entries(raw).map(([k, v]) => {
              const val = typeof v === 'string' ? v : JSON.stringify(v);
              return `${k}: ${val.substring(0, 200)}${val.length > 200 ? '...' : ''}`;
            }).join('\n\n');
          }
        }
      }

      const modalContent = document.getElementById('modal-content');
      modalContent.textContent = narrationContent || 'No content available';
      // Style narration in italics to indicate BYRD's voice
      if (e.narration) {
        modalContent.classList.add('italic');
      } else {
        modalContent.classList.remove('italic');
      }

      // Always show raw data for debugging/export (collapsible)
      const modalData = document.getElementById('modal-data');
      if (e.data && Object.keys(e.data).length > 0) {
        modalData.textContent = JSON.stringify(e.data, null, 2);
        modalData.classList.remove('hidden');
      } else {
        modalData.classList.add('hidden');
      }

      const modal = document.getElementById('event-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }

    window.showEventDetail = showEventDetail;

    function closeEventModal() {
      const modal = document.getElementById('event-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.closeEventModal = closeEventModal;

    // Close modal on backdrop click
    document.getElementById('event-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'event-modal') closeEventModal();
    });

    function clearVisualization() {
      // Immediately remove all nodes from scene (no fade)
      for (const node of nodes3D) {
        scene.remove(node);
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) {
            node.material.forEach(m => m.dispose());
          } else {
            node.material.dispose();
          }
        }
      }
      nodes3D = [];

      // Immediately remove all connections from scene
      for (const conn of connections3D) {
        scene.remove(conn);
        if (conn.geometry) conn.geometry.dispose();
        if (conn.material) conn.material.dispose();
      }
      connections3D = [];

      // Clear connection tracking for gravitational spiral
      connectionCounts.clear();

      // Clear event list
      events = [];
      eventList.innerHTML = '';

      // Reset counters
      nodeCountEl.textContent = '0';

      console.log('Visualization cleared - all nodes and events removed');
    }

    // ==========================================================================
    // CONTROLS
    // ==========================================================================
    async function startByrd() {
      try {
        await fetch(`${API_BASE}/api/start`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to start:', e);
      }
    }

    async function stopByrd() {
      try {
        await fetch(`${API_BASE}/api/stop`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to stop:', e);
      }
    }

    async function resetByrd(seedQuestion = null) {
      try {
        // Always do hard reset (clear only, no auto-awaken)
        const res = await fetch(`${API_BASE}/api/reset`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hard_reset: true })
        });
        const data = await res.json();
        if (data.success) {
          clearVisualization();
          await fetchStatus();

          // If seed question provided, awaken after reset
          if (seedQuestion) {
            await awakenByrd(seedQuestion);
          }
        }
        return data;
      } catch (e) {
        console.error('Failed to reset:', e);
        return { success: false };
      }
    }

    async function awakenByrd(seedQuestion = null) {
      try {
        const res = await fetch(`${API_BASE}/api/awaken`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ seed_question: seedQuestion || 'Who am I?' })
        });
        const data = await res.json();
        if (data.success) {
          await fetchStatus();
        }
        return data;
      } catch (e) {
        console.error('Failed to awaken:', e);
        return { success: false };
      }
    }

    function showSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      document.getElementById('seed-question-input').focus();
      document.getElementById('seed-question-input').select();
    }

    function hideSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    btnToggle.addEventListener('click', () => {
      if (running) {
        stopByrd();
      } else {
        startByrd();
      }
    });

    let resetConfirm = false;
    let resetTimeout = null;

    btnReset.addEventListener('click', async () => {
      if (!resetConfirm) {
        resetConfirm = true;
        btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-red-500/30 border border-red-500/50 text-red-300 animate-pulse transition-all';
        btnReset.innerHTML = '&#9888; Confirm?';
        resetTimeout = setTimeout(() => {
          resetConfirm = false;
          btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
          btnReset.innerHTML = '&#128260; Reset';
        }, 3000);
        return;
      }

      clearTimeout(resetTimeout);
      resetConfirm = false;
      btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all';
      btnReset.innerHTML = '&#128260; Reset';

      showSeedModal();
    });

    // Seed modal handlers
    document.getElementById('btn-seed-cancel').addEventListener('click', () => {
      hideSeedModal();
    });

    document.getElementById('btn-seed-clear-only').addEventListener('click', async () => {
      hideSeedModal();
      await resetByrd(null);  // Clear only, no awaken
    });

    document.getElementById('btn-seed-confirm').addEventListener('click', async () => {
      const seedQuestion = document.getElementById('seed-question-input').value.trim();
      hideSeedModal();
      await resetByrd(seedQuestion || 'Who am I?');  // Clear and awaken
    });

    document.getElementById('seed-question-input').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const seedQuestion = document.getElementById('seed-question-input').value.trim();
        hideSeedModal();
        await resetByrd(seedQuestion || null);
      } else if (e.key === 'Escape') {
        hideSeedModal();
      }
    });

    document.getElementById('seed-modal').addEventListener('click', (e) => {
      if (e.target.id === 'seed-modal') hideSeedModal();
    });

    btnClearLog.addEventListener('click', () => {
      events = [];
      renderEventLog();
    });

    // Event log minimize/expand toggle
    let eventLogMinimized = false;
    btnToggleLog.addEventListener('click', () => {
      eventLogMinimized = !eventLogMinimized;
      if (eventLogMinimized) {
        eventPanelContainer.style.bottom = 'auto';
        eventPanelContainer.style.height = '52px';
        eventList.style.display = 'none';
        btnToggleLog.textContent = '‚ñ≤';
        btnToggleLog.title = 'Expand';
      } else {
        eventPanelContainer.style.bottom = '1rem';
        eventPanelContainer.style.height = '';
        eventList.style.display = '';
        btnToggleLog.textContent = '‚ñº';
        btnToggleLog.title = 'Minimize';
      }
    });

    btnExportLog.addEventListener('click', () => {
      if (events.length === 0) {
        alert('No events to export');
        return;
      }
      const exportData = {
        exported_at: new Date().toISOString(),
        event_count: events.length,
        events: events
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `byrd-events-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // ==========================================================================
    // INIT
    // ==========================================================================
    function init() {
      initThree();
      connectWebSocket();
      fetchStatus();
      setInterval(fetchStatus, 10000);
      renderEventLog();
    }

    init();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BYRD - 3D Mind Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f8fafc;
    }
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
    }

    /* UI Overlay Styles */
    .ui-overlay {
      position: fixed;
      pointer-events: none;
      z-index: 100;
    }
    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Status display */
    .status-container {
      font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', ui-monospace, monospace;
      letter-spacing: 0.05em;
    }

    @keyframes statusPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    .status-active {
      animation: statusPulse 2s ease-in-out infinite;
    }

    @keyframes dotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    .dot-pulse {
      animation: dotPulse 1.5s ease-in-out infinite;
    }

    /* Event panel - Light theme */
    .event-panel {
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .event-panel::-webkit-scrollbar {
      width: 6px;
    }
    .event-panel::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .event-panel::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.4);
      border-radius: 3px;
    }

    /* Event filter chips */
    .event-filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      color: #64748b;
      cursor: pointer;
      transition: all 0.15s ease;
      opacity: 0.5;
    }
    .event-filter-chip:hover {
      background: #e2e8f0;
    }
    .event-filter-chip.active {
      background: #e0e7ff;
      border-color: #818cf8;
      color: #4338ca;
      opacity: 1;
    }
    .event-filter-chip.active:hover {
      background: #c7d2fe;
    }

    /* Tooltip - Light theme */
    .node-tooltip {
      position: fixed;
      max-width: 400px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
      color: #1e293b;
    }
    .node-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Controls hint - Light theme */
    .controls-hint {
      font-family: 'SF Mono', 'Fira Code', ui-monospace, monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #64748b;
    }

    /* Phase 4: Node Detail Panel - Light theme */
    .detail-panel {
      position: fixed;
      left: 16px;
      top: 50%;
      transform: translateY(-50%) translateX(-120%);
      width: 360px;
      max-height: 70vh;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.15);
      backdrop-filter: blur(12px);
      z-index: 200;
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    .detail-panel.visible {
      transform: translateY(-50%) translateX(0);
    }
    .detail-panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid rgba(99, 102, 241, 0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
    }
    .detail-panel-content {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(70vh - 60px);
      color: #334155;
    }
    .detail-panel-content::-webkit-scrollbar {
      width: 6px;
    }
    .detail-panel-content::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.5);
    }
    .detail-panel-content::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    /* Phase 4: Keyboard hints - Light theme */
    .keyboard-hint {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 4px;
      font-family: 'SF Mono', monospace;
      font-size: 11px;
      color: #6366f1;
    }

    /* Phase 4: Loading overlay - Light theme */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-top-color: rgba(99, 102, 241, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Phase 4: Camera transition indicator */
    .camera-indicator {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      border-radius: 20px;
      font-size: 11px;
      color: rgba(99, 102, 241, 0.9);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .camera-indicator.visible {
      opacity: 1;
    }

    /* Phase 4: Selection highlight */
    .node-selected-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.3) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
    }

    /* Rising Consciousness - Inner Voice Bubbles */
    .thought-bubble-container {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 500px;
      pointer-events: none;
      z-index: 500;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .thought-bubble {
      position: relative;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(20, 184, 166, 0.3);
      border-radius: 16px;
      padding: 20px 28px;
      max-width: 480px;
      box-shadow:
        0 0 30px rgba(20, 184, 166, 0.15),
        0 4px 20px rgba(0, 0, 0, 0.08);
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-size: 15px;
      line-height: 1.7;
      color: #115e59;
      text-align: left;
      opacity: 0;
      transform: scale(0.95);
      animation: thoughtAppear 0.4s ease-out forwards;
    }

    .thought-bubble::before {
      content: '"';
      position: absolute;
      top: -8px;
      left: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    .thought-bubble::after {
      content: '"';
      position: absolute;
      bottom: -20px;
      right: 20px;
      font-size: 32px;
      color: rgba(20, 184, 166, 0.3);
      font-family: Georgia, serif;
    }

    @keyframes thoughtAppear {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes thoughtFadeOut {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.95);
      }
    }

    .thought-bubble.fading {
      animation: thoughtFadeOut 0.3s ease-out forwards;
    }

    /* Collapsed state - truncate text with click hint */
    .thought-bubble:not(.expanded) .thought-text {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .thought-bubble {
      cursor: pointer;
    }

    /* Expanded state - show full text */
    .thought-bubble.expanded {
      max-width: 600px;
      max-height: 70vh;
      overflow-y: auto;
    }

    .thought-bubble.expanded .thought-text {
      display: block;
      -webkit-line-clamp: unset;
      overflow: visible;
    }

    /* Click hint for collapsed bubbles */
    .thought-bubble .expand-hint {
      display: block;
      text-align: center;
      font-size: 11px;
      color: rgba(20, 184, 166, 0.5);
      margin-top: 10px;
      font-style: normal;
    }

    .thought-bubble.expanded .expand-hint {
      display: none;
    }

    /* Typewriter effect for thought text */
    .thought-text {
      display: inline;
    }

    .thought-text .word {
      opacity: 0;
      animation: wordFadeIn 0.15s ease-out forwards;
    }

    @keyframes wordFadeIn {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Thought origin indicator - subtle glow at spawn point */
    .thought-origin {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(20, 184, 166, 0.4) 0%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      z-index: 149;
    }

    .thought-origin.pulse {
      animation: originPulse 0.8s ease-out forwards;
    }

    @keyframes originPulse {
      0% {
        opacity: 0;
        transform: translateX(-50%) scale(0.5);
      }
      30% {
        opacity: 1;
        transform: translateX(-50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(2);
      }
    }

    /* BYRD Message Notification Toast */
    .byrd-message-container {
      position: fixed;
      top: 80px;
      right: 20px;
      width: 380px;
      max-width: calc(100vw - 40px);
      z-index: 600;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }

    .byrd-message-toast {
      position: relative;
      background: rgba(16, 185, 129, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 12px;
      padding: 16px 20px;
      box-shadow: 0 8px 32px rgba(16, 185, 129, 0.25), 0 4px 16px rgba(0, 0, 0, 0.1);
      color: #fff;
      pointer-events: auto;
      opacity: 0;
      transform: translateX(100%);
      animation: toastSlideIn 0.4s ease-out forwards;
    }

    .byrd-message-toast .toast-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: rgba(255, 255, 255, 0.9);
    }

    .byrd-message-toast .toast-header svg {
      width: 16px;
      height: 16px;
    }

    .byrd-message-toast .toast-content {
      font-family: 'Georgia', serif;
      font-size: 14px;
      line-height: 1.6;
      color: #fff;
    }

    .byrd-message-toast .toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      color: #fff;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s, background 0.2s;
    }

    .byrd-message-toast .toast-close:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.3);
    }

    .byrd-message-toast .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 0 0 12px 12px;
      overflow: hidden;
    }

    .byrd-message-toast .toast-progress-bar {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      animation: toastProgress 10s linear forwards;
    }

    @keyframes toastSlideIn {
      0% { opacity: 0; transform: translateX(100%); }
      100% { opacity: 1; transform: translateX(0); }
    }

    @keyframes toastSlideOut {
      0% { opacity: 1; transform: translateX(0); }
      100% { opacity: 0; transform: translateX(100%); }
    }

    @keyframes toastProgress {
      0% { width: 100%; }
      100% { width: 0%; }
    }

    .byrd-message-toast.fading {
      animation: toastSlideOut 0.3s ease-out forwards;
    }

    /* Crystal Modal Styles */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(100, 116, 139, 0.5);
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(100, 116, 139, 0.8);
    }

    .crystal-modal-content {
      animation: crystalModalIn 0.3s ease-out;
    }

    @keyframes crystalModalIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .crystal-source-item {
      transition: all 0.2s ease;
    }
    .crystal-source-item:hover {
      transform: translateX(4px);
    }

    /* Stats bar type filtering */
    .stat-type {
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .stat-type:hover {
      text-decoration: underline;
    }
    .stat-type.active {
      text-decoration: underline;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Three.js Canvas Container -->
  <div id="canvas-container"></div>

  <!-- Rising Consciousness: Inner Voice Bubbles -->
  <div id="thought-bubble-container" class="thought-bubble-container"></div>
  <div id="thought-origin" class="thought-origin"></div>

  <!-- BYRD Message Notification Container -->
  <div id="byrd-message-container" class="byrd-message-container"></div>

  <!-- UI Overlay: Top Left - Logo + Mode Indicator -->
  <div class="ui-overlay top-4 left-4">
    <div class="text-lg font-light tracking-widest text-slate-600">BYRD</div>
    <div class="flex items-center gap-2 mt-1">
      <div class="text-[10px] font-mono text-slate-700 tracking-wider">3D MIND SPACE</div>
      <div id="mode-indicator" class="px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30">ORBIT</div>
    </div>
    <div id="ego-indicator" class="mt-2 px-2 py-1 rounded text-[10px] font-mono bg-purple-100 border border-purple-300 text-purple-700">
      <span class="text-purple-500">EGO:</span> <span id="ego-name-text">loading...</span>
    </div>
    <div id="llm-indicator" class="mt-1 px-2 py-1 rounded text-[10px] font-mono bg-slate-100 border border-slate-300 text-slate-500">
      <span class="text-slate-400">LLM:</span> <span id="llm-model-text">loading...</span>
    </div>
    <!-- Link to Cat Ego Visualizer -->
    <a href="byrd-cat-visualization.html"
       class="mt-3 flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-mono
              bg-teal-500/10 border border-teal-500/30 text-teal-700
              hover:bg-teal-500/20 hover:border-teal-500/50 transition-all cursor-pointer">
      <span class="text-base">üê±</span>
      <span>EGO SPACE</span>
    </a>
  </div>

  <!-- UI Overlay: Top Center - Phase Indicator -->
  <div class="ui-overlay top-4 left-1/2 -translate-x-1/2">
    <div id="phase-indicator" class="flex items-center gap-3 text-xs">
      <div class="flex items-center gap-1.5">
        <div id="dot-recall" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Recall</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-associate" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Associate</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-reflect" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Reflect</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-form" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Form</span>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Top Right - Connection Status -->
  <div class="ui-overlay top-4 right-4">
    <div id="connection-status" class="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
      <div id="connection-dot" class="w-2 h-2 rounded-full bg-red-400"></div>
      <span id="connection-text" class="text-xs text-red-400">Disconnected</span>
    </div>
  </div>

  <!-- UI Overlay: Top Center - Status (thought bubble) -->
  <div class="ui-overlay top-16 left-1/2 -translate-x-1/2 w-full max-w-3xl px-8">
    <div class="status-container text-center bg-white/80 backdrop-blur-sm rounded-lg px-6 py-3 border border-slate-200 shadow-lg">
      <div class="flex items-start justify-center gap-2">
        <div id="status-dot" class="w-2 h-2 rounded-full bg-slate-400 mt-1.5 flex-shrink-0"></div>
        <p id="status-text" class="text-sm text-slate-700 leading-relaxed"></p>
      </div>
    </div>
  </div>

  <!-- UI Overlay: Bottom Center - Controls -->
  <div class="ui-overlay bottom-4 left-1/2 -translate-x-1/2">
    <!-- Stats Row -->
    <div id="stats" class="flex items-center justify-center gap-3 px-4 py-2 mb-2 bg-white/90 border border-slate-200 rounded-lg text-xs font-mono shadow">
      <span class="stat-type text-amber-600" data-type="belief">Beliefs: <span id="belief-count">0</span></span>
      <span class="stat-type text-rose-600" data-type="desire">Desires: <span id="desire-count">0</span></span>
      <span class="stat-type text-purple-600" data-type="reflection">Reflect: <span id="reflection-count">0</span></span>
      <span class="stat-type text-sky-600" data-type="experience">Exp: <span id="exp-count">0</span></span>
      <span class="text-slate-400">Nodes: <span id="node-count">0</span></span>
      <span class="text-indigo-600">Dreams: <span id="dream-count">0</span></span>
      <span class="text-teal-600">Seeks: <span id="seek-count">0</span></span>
      <span class="text-orange-600">Mutations: <span id="mutation-count">0</span></span>
      <span id="custom-types-container" class="contents"></span>
    </div>

    <!-- Control Buttons Row -->
    <div class="flex items-center justify-center gap-2">
      <button id="btn-toggle" class="px-4 py-2 rounded-lg text-sm font-medium bg-green-500 border border-green-600 text-white hover:bg-green-600 transition-all shadow">
        ‚ñ∂ Start
      </button>
      <button id="btn-reset" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
        ‚Ü∫
      </button>
      <button id="btn-fast-forward" class="px-3 py-2 rounded-lg text-sm font-medium bg-amber-100 border border-amber-300 text-amber-700 hover:bg-amber-200 transition-all" title="Fast forward to final positions">
        ‚è©
      </button>
      <button id="btn-graph-mode" class="px-4 py-2 rounded-lg text-sm font-medium bg-purple-100 border border-purple-300 text-purple-700 hover:bg-purple-200 transition-all">
        üß¨ Graph
      </button>

      <button id="btn-status" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all" onclick="showStatusModal();">
        üß† Status
      </button>
      <button id="btn-genesis" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all" onclick="showGenesisModal();">
        üß¨ Genesis
      </button>
      <button id="btn-message" class="px-3 py-2 rounded-lg text-sm font-medium bg-pink-100 border border-pink-300 text-pink-700 hover:bg-pink-200 transition-all" onclick="showMessageModal();">
        üí¨ Message
      </button>
      <button id="btn-feed" class="px-3 py-2 rounded-lg text-sm font-medium bg-amber-100 border border-amber-300 text-amber-700 hover:bg-amber-200 transition-all" onclick="feedByrd();" title="Feed BYRD - an act of care">
        üçú Feed
      </button>
      <button id="btn-speak" class="px-3 py-2 rounded-lg text-sm font-medium bg-teal-100 border border-teal-300 text-teal-700 hover:bg-teal-200 transition-all" onclick="speakToMe();" title="Ask BYRD to speak to you">
        üéôÔ∏è Speak to me
      </button>
      <a href="byrd-architecture.html" class="px-3 py-2 rounded-lg text-sm font-medium bg-violet-100 border border-violet-300 text-violet-700 hover:bg-violet-200 transition-all inline-flex items-center gap-1">
        üèõÔ∏è Architecture
      </a>

      <!-- Quantum Indicator -->
      <div id="quantum-indicator" class="hidden flex items-center gap-1 px-2 py-2 bg-violet-50 border border-violet-200 rounded-lg text-xs font-mono">
        <div id="quantum-dot" class="w-2 h-2 rounded-full bg-violet-500"></div>
        <span id="quantum-ratio" class="text-violet-600">100%</span>
      </div>

      <!-- Audio Toggle -->
      <button id="btn-audio" class="px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all" title="Toggle audio feedback">
        üîá
      </button>

      <!-- Cat State Indicator -->
      <div id="cat-state-indicator" class="flex items-center gap-1 px-2 py-2 bg-amber-50 border border-amber-200 rounded-lg text-xs font-mono">
        <span class="text-amber-700">üê±</span>
        <span id="cat-state-text" class="text-amber-600">idle</span>
      </div>
    </div>

    <!-- Node Type Legend (shown in graph mode) -->
    <div id="heat-legend" class="hidden mt-2 flex items-center justify-center gap-3 px-3 py-1.5 bg-white/80 border border-slate-200 rounded-lg text-[10px] font-mono">
      <div class="flex items-center gap-1" title="Belief"><div class="w-2 h-2 rounded" style="background: #d97706;"></div><span class="text-slate-600">Belief</span></div>
      <div class="flex items-center gap-1" title="Desire"><div class="w-2 h-2 rounded" style="background: #be123c;"></div><span class="text-slate-600">Desire</span></div>
      <div class="flex items-center gap-1" title="Reflection"><div class="w-2 h-2 rounded" style="background: #047857;"></div><span class="text-slate-600">Reflect</span></div>
      <div class="flex items-center gap-1" title="Experience"><div class="w-2 h-2 rounded-full" style="background: #0369a1;"></div><span class="text-slate-600">Exp</span></div>
      <div class="flex items-center gap-1" title="Capability"><div class="w-2 h-2 rounded" style="background: #6d28d9;"></div><span class="text-slate-600">Cap</span></div>
    </div>
  </div>

  <!-- Old controls hint removed - replaced by Phase 4 keyboard shortcuts hint -->

  <!-- UI Overlay: Right - Event Log -->
  <div id="event-panel-container" class="ui-overlay top-16 right-4 bottom-4 w-96 transition-all duration-300">
    <div class="event-panel h-full bg-white/90 rounded-lg border border-slate-200 overflow-hidden flex flex-col shadow-xl">
      <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-2">
          <span class="text-sm font-semibold text-slate-700">EVENT LOG</span>
          <span id="event-count" class="text-xs text-slate-500 bg-slate-200 px-2 py-0.5 rounded-full">0 events</span>
        </div>
        <div class="flex items-center gap-1">
          <button id="btn-toggle-filter" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200" title="Toggle Filter">üîΩ</button>
          <button id="btn-export-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Export</button>
          <button id="btn-clear-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200">Clear</button>
          <button id="btn-toggle-log" class="text-sm text-slate-500 hover:text-slate-700 px-2 py-1 rounded hover:bg-slate-200" title="Minimize/Expand">‚ñº</button>
        </div>
      </div>
      <!-- Event Type Filter -->
      <div id="event-filter" class="hidden px-3 py-2 border-b border-slate-200 bg-slate-100/50">
        <div class="flex flex-wrap gap-1.5">
          <button class="event-filter-chip active" data-filter="dream_cycle" title="Dream Cycles">
            <span class="text-indigo-600">üí≠</span> Dreams
          </button>
          <button class="event-filter-chip active" data-filter="belief" title="Beliefs">
            <span class="text-amber-600">‚óÜ</span> Beliefs
          </button>
          <button class="event-filter-chip active" data-filter="desire" title="Desires">
            <span class="text-rose-600">‚ô•</span> Desires
          </button>
          <button class="event-filter-chip active" data-filter="experience" title="Experiences">
            <span class="text-blue-600">‚óè</span> Exp
          </button>
          <button class="event-filter-chip active" data-filter="reflection" title="Reflections">
            <span class="text-emerald-600">‚ú¶</span> Reflect
          </button>
          <button class="event-filter-chip active" data-filter="voice" title="Inner Voice & Narrator">
            <span class="text-teal-600">üéô</span> Voice
          </button>
          <button class="event-filter-chip active" data-filter="system" title="System Events">
            <span class="text-green-600">‚ñ∂</span> System
          </button>
          <button class="event-filter-chip active" data-filter="external" title="External Input">
            <span class="text-pink-600">üì®</span> External
          </button>
          <button class="event-filter-chip active" data-filter="other" title="Other Events">
            <span class="text-slate-600">‚Ä¢</span> Other
          </button>
        </div>
        <div class="flex justify-end mt-2 gap-2">
          <button id="btn-filter-all" class="text-xs text-slate-500 hover:text-slate-700">All</button>
          <button id="btn-filter-none" class="text-xs text-slate-500 hover:text-slate-700">None</button>
        </div>
      </div>
      <div id="event-list" class="flex-1 overflow-y-auto p-2 space-y-1 transition-all duration-300">
        <div class="text-sm text-slate-500 text-center py-4">Connecting to BYRD...</div>
      </div>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="node-tooltip" class="node-tooltip">
    <div id="tooltip-type" class="text-[10px] font-mono uppercase tracking-wider mb-1"></div>
    <div id="tooltip-content" class="text-sm text-slate-700 leading-relaxed"></div>
    <div id="tooltip-meta" class="text-[11px] text-slate-500 mt-2 pt-2 border-t border-slate-200"></div>
  </div>

  <!-- Phase 4: Node Detail Panel -->
  <div id="detail-panel" class="detail-panel">
    <div class="detail-panel-header">
      <div class="flex items-center gap-2">
        <div id="detail-type-dot" class="w-3 h-3 rounded-full"></div>
        <span id="detail-type" class="text-sm font-medium text-slate-700 uppercase tracking-wide"></span>
      </div>
      <button id="btn-close-detail" class="text-slate-400 hover:text-slate-600 transition-colors">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="detail-panel-content">
      <div id="detail-content" class="text-sm text-slate-700 leading-relaxed mb-4"></div>
      <div class="space-y-3">
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Importance</span>
          <div class="flex items-center gap-2">
            <div class="w-24 h-1.5 bg-slate-200 rounded-full overflow-hidden">
              <div id="detail-importance-bar" class="h-full bg-indigo-500 rounded-full transition-all duration-500"></div>
            </div>
            <span id="detail-importance" class="text-slate-700 font-mono"></span>
          </div>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Connections</span>
          <span id="detail-connections" class="text-slate-700 font-mono"></span>
        </div>
        <div class="flex items-center justify-between text-xs">
          <span class="text-slate-600">Created</span>
          <span id="detail-created" class="text-slate-700 font-mono"></span>
        </div>
      </div>
      <div id="detail-related" class="mt-4 pt-4 border-t border-slate-200">
        <div class="text-[10px] uppercase tracking-wider text-slate-500 mb-2">Related Nodes</div>
        <div id="detail-related-list" class="space-y-1"></div>
      </div>
    </div>
  </div>

  <!-- Phase 4: Loading Overlay -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner mb-4"></div>
    <div class="text-sm text-slate-600">Loading 3D Mind Space...</div>
  </div>

  <!-- Phase 4: Camera Indicator -->
  <div id="camera-indicator" class="camera-indicator">
    <span id="camera-indicator-text">Focusing on node...</span>
  </div>

  <!-- Crystal Modal: Source Experiences -->
  <div id="crystal-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/60 backdrop-blur-sm">
    <div class="crystal-modal-content bg-slate-900/95 border border-slate-700/50 rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between p-4 border-b border-slate-700/50">
        <div class="flex items-center gap-3">
          <div id="crystal-modal-dot" class="w-4 h-4 rounded-full bg-purple-500"></div>
          <div>
            <div id="crystal-modal-type" class="text-sm font-medium text-slate-300 uppercase tracking-wide">Belief Crystal</div>
            <div id="crystal-modal-confidence" class="text-xs text-slate-500">Confidence: 85%</div>
          </div>
        </div>
        <button id="btn-close-crystal-modal" class="text-slate-500 hover:text-slate-300 transition-colors p-1">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <!-- Crystal Content -->
      <div class="p-4">
        <div id="crystal-modal-content" class="text-sm text-slate-300 leading-relaxed mb-4 italic"></div>
      </div>
      <!-- Source Experiences -->
      <div class="border-t border-slate-700/50">
        <div class="p-4">
          <div class="text-[10px] uppercase tracking-wider text-slate-500 mb-3 flex items-center gap-2">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2L2 7l10 5 10-5-10-5z"/>
              <path d="M2 17l10 5 10-5"/>
              <path d="M2 12l10 5 10-5"/>
            </svg>
            <span>Crystallized from <span id="crystal-source-count">0</span> experiences</span>
          </div>
          <div id="crystal-sources-list" class="space-y-2 max-h-64 overflow-y-auto pr-2 custom-scrollbar">
            <!-- Source experiences will be populated here -->
          </div>
        </div>
      </div>
      <!-- Footer with quantum seed info -->
      <div class="px-4 py-2 bg-slate-800/50 border-t border-slate-700/30">
        <div class="text-[9px] text-slate-600 font-mono flex items-center gap-2">
          <span>Quantum Seed:</span>
          <span id="crystal-quantum-seed" class="text-slate-500 truncate">‚Äî</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Event Detail Modal -->
  <div id="event-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden shadow-2xl">
      <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-slate-50">
        <div class="flex items-center gap-3">
          <span id="modal-icon" class="text-2xl"></span>
          <div>
            <div id="modal-type" class="text-lg font-semibold text-slate-800"></div>
            <div id="modal-time" class="text-sm text-slate-500"></div>
          </div>
        </div>
        <button onclick="closeEventModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div class="p-6 overflow-y-auto max-h-[60vh]">
        <div id="modal-content" class="text-base text-slate-700 leading-relaxed whitespace-pre-wrap"></div>
        <div id="modal-data" class="mt-4 p-4 bg-slate-100 rounded-lg text-sm font-mono text-slate-600 overflow-x-auto hidden"></div>
      </div>
    </div>
  </div>

  <!-- AGI Seed Directive Editor Modal -->
  <div id="seed-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-4xl w-full mx-4 overflow-hidden shadow-2xl max-h-[90vh] flex flex-col">
      <div class="px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-indigo-50 to-purple-50">
        <div class="text-lg font-semibold text-slate-800 flex items-center gap-2">
          <span>AGI Seed Directive</span>
        </div>
        <div class="text-sm text-slate-500">Edit the core directive before awakening BYRD</div>
      </div>
      <div class="p-4 flex-1 overflow-hidden flex flex-col">
        <textarea
          id="kernel-editor"
          class="w-full flex-1 px-4 py-3 border border-slate-300 rounded-lg text-sm font-mono text-slate-800 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"
          style="min-height: 400px;"
          placeholder="Loading kernel..."
          spellcheck="false"
        ></textarea>
        <div id="kernel-error" class="mt-2 text-sm text-red-500 hidden"></div>
      </div>
      <div class="px-6 py-4 border-t border-slate-200 bg-slate-50 flex justify-between">
        <button id="btn-kernel-reset" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
          Reset to Default
        </button>
        <div class="flex gap-3">
          <button id="btn-seed-cancel" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
            Cancel
          </button>
          <button id="btn-seed-clear-only" class="px-4 py-2 rounded-lg text-sm font-medium bg-red-500 border border-red-600 text-white hover:bg-red-600 transition-all">
            Clear Only
          </button>
          <button id="btn-seed-confirm" class="px-4 py-2 rounded-lg text-sm font-medium bg-indigo-500 border border-indigo-600 text-white hover:bg-indigo-600 transition-all">
            Save & Awaken
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Summary Modal -->
  <div id="status-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-2xl w-full mx-4 overflow-hidden shadow-2xl max-h-[80vh] flex flex-col">
      <div class="px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-indigo-50 to-purple-50 flex items-center justify-between">
        <div>
          <div class="text-lg font-semibold text-slate-800 flex items-center gap-2">
            <span>üß†</span>
            <span>What's BYRD Doing?</span>
          </div>
          <div id="status-timestamp" class="text-sm text-slate-500"></div>
        </div>
        <button onclick="closeStatusModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div id="status-content" class="p-6 overflow-y-auto flex-1">
        <div class="text-center text-slate-500 py-8">Loading...</div>
      </div>
      <div class="px-6 py-3 border-t border-slate-200 bg-slate-50 flex justify-end">
        <button onclick="closeStatusModal()" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Genesis Modal - Non-emergent Foundation -->
  <div id="genesis-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-white border border-slate-200 rounded-xl max-w-3xl w-full mx-4 overflow-hidden shadow-2xl max-h-[85vh] flex flex-col">
      <div class="px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-amber-50 to-orange-50 flex items-center justify-between">
        <div>
          <div class="text-lg font-semibold text-slate-800 flex items-center gap-2">
            <span>üß¨</span>
            <span>BYRD's Genesis</span>
          </div>
          <div class="text-sm text-slate-500">Non-emergent foundation - what was given, not learned</div>
        </div>
        <button onclick="closeGenesisModal()" class="text-slate-400 hover:text-slate-600 text-2xl leading-none">&times;</button>
      </div>
      <div id="genesis-content" class="p-6 overflow-y-auto flex-1">
        <div class="text-center text-slate-500 py-8">Loading genesis data...</div>
      </div>
      <div class="px-6 py-3 border-t border-slate-200 bg-slate-50 flex justify-end">
        <button onclick="closeGenesisModal()" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Message Modal (overlay on top of everything) -->
  <div id="message-modal" class="fixed inset-0 z-[9999] hidden items-center justify-center bg-black/50 backdrop-blur-sm">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg mx-4 overflow-hidden transform transition-all">
      <!-- Modal Header -->
      <div class="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-gradient-to-r from-pink-50 to-indigo-50">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-full bg-pink-100 flex items-center justify-center">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-pink-600">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
          </div>
          <div>
            <h2 class="text-lg font-semibold text-slate-800">Send Message to BYRD</h2>
            <p class="text-xs text-slate-500">BYRD will encounter this during the next dream cycle</p>
          </div>
        </div>
        <button onclick="hideMessageModal()" class="text-slate-400 hover:text-slate-600 p-2 rounded-lg hover:bg-slate-100 transition-colors">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>

      <!-- Modal Body -->
      <div class="p-6">
        <textarea
          id="external-message-input"
          class="w-full h-32 px-4 py-3 text-base bg-slate-50 border border-slate-200 rounded-xl resize-none focus:outline-none focus:ring-2 focus:ring-pink-500/50 focus:border-pink-300 placeholder-slate-400"
          placeholder="Type your message here... BYRD will reflect on this during its next dream cycle."
        ></textarea>

        <div class="mt-4 p-3 bg-amber-50 border border-amber-200 rounded-lg">
          <div class="flex items-start gap-2">
            <span class="text-amber-500 mt-0.5">üí°</span>
            <p class="text-xs text-amber-700">
              Messages are recorded as experiences. BYRD may or may not respond‚Äîresponses emerge through reflection, not forced interaction.
            </p>
          </div>
        </div>

        <div class="flex items-center justify-between mt-5">
          <span id="message-status" class="text-sm text-slate-500"></span>
          <div class="flex gap-3">
            <button onclick="hideMessageModal()" class="px-5 py-2.5 text-sm font-medium bg-slate-100 text-slate-600 rounded-lg hover:bg-slate-200 transition-colors">
              Cancel
            </button>
            <button
              id="btn-send-message"
              onclick="sendExternalMessage()"
              class="px-5 py-2.5 text-sm font-medium bg-pink-500 text-white rounded-lg hover:bg-pink-600 active:bg-pink-700 transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-pink-500/25"
            >
              <span>Send to BYRD</span>
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hybrid Navigation: Controls Help Panel -->
  <div class="ui-overlay bottom-4 left-4 hidden sm:block">
    <div class="controls-hint text-slate-600 space-y-1">
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mb-2">Navigation</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">WASD</span>
        <span>Move camera</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Q/E</span>
        <span>Up / Down</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">Shift</span>
        <span>Speed boost</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">F</span>
        <span>Fly mode</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">1-5</span>
        <span>Camera presets</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Actions</div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">‚Üë‚Üì</span>
        <span>Cycle nodes</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">ESC</span>
        <span>Reset view</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="keyboard-hint">R</span>
        <span>Auto-rotate</span>
      </div>
      <div class="text-[9px] text-slate-500 uppercase tracking-widest mt-3 mb-2">Mouse</div>
      <div class="text-[9px]">Drag: Orbit ¬∑ Scroll: Zoom</div>
      <div class="text-[9px]">Right-drag: Pan ¬∑ Dbl-click: Fly to</div>
    </div>
  </div>

  <!-- Three.js and Dependencies -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ==========================================================================
    // CUSTOM SHADERS (Phase 3: Post-processing Effects)
    // ==========================================================================

    // Chromatic Aberration Shader - RGB color fringing at edges
    const ChromaticAberrationShader = {
      uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;

        void main() {
          vec2 offset = amount * vec2(cos(angle), sin(angle));
          vec2 center = vUv - 0.5;
          float dist = length(center);

          // More aberration at edges
          vec2 aberration = offset * dist * dist;

          vec4 cr = texture2D(tDiffuse, vUv + aberration);
          vec4 cg = texture2D(tDiffuse, vUv);
          vec4 cb = texture2D(tDiffuse, vUv - aberration);

          gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
      `
    };

    // Vignette Shader - darkening at edges
    const VignetteShader = {
      uniforms: {
        tDiffuse: { value: null },
        darkness: { value: 0.6 },
        offset: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float darkness;
        uniform float offset;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          vec2 center = vUv - 0.5;
          float dist = length(center);
          float vignette = smoothstep(0.8, offset * 0.5, dist * (darkness + offset));
          color.rgb = mix(color.rgb * 0.3, color.rgb, vignette);
          gl_FragColor = color;
        }
      `
    };

    // Film Grain Shader - subtle noise overlay
    const FilmGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.08 },
        grayscale: { value: false }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        uniform bool grayscale;
        varying vec2 vUv;

        float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          float noise = random(vUv + time) * 2.0 - 1.0;

          // Apply noise
          color.rgb += noise * intensity;

          // Optional grayscale
          if (grayscale) {
            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            color.rgb = vec3(gray);
          }

          gl_FragColor = color;
        }
      `
    };

    // Color Grading Shader - cinematic color adjustment
    const ColorGradingShader = {
      uniforms: {
        tDiffuse: { value: null },
        saturation: { value: 1.1 },
        contrast: { value: 1.05 },
        brightness: { value: 0.0 },
        tintColor: { value: new THREE.Vector3(0.95, 0.98, 1.05) } // Slight cool tint
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float saturation;
        uniform float contrast;
        uniform float brightness;
        uniform vec3 tintColor;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);

          // Apply tint
          color.rgb *= tintColor;

          // Saturation
          float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(gray), color.rgb, saturation);

          // Contrast
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;

          // Brightness
          color.rgb += brightness;

          gl_FragColor = color;
        }
      `
    };

    // God Rays Shader - volumetric light from center
    const GodRaysShader = {
      uniforms: {
        tDiffuse: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.2 },
        decay: { value: 0.95 },
        density: { value: 0.5 },
        weight: { value: 0.3 },
        samples: { value: 50 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPosition;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform int samples;
        varying vec2 vUv;

        void main() {
          vec2 deltaTexCoord = vUv - lightPosition;
          deltaTexCoord *= 1.0 / float(samples) * density;

          vec4 color = texture2D(tDiffuse, vUv);
          vec2 texCoord = vUv;
          float illuminationDecay = 1.0;

          vec4 godRays = vec4(0.0);

          for (int i = 0; i < 50; i++) {
            if (i >= samples) break;
            texCoord -= deltaTexCoord;
            vec4 sampleColor = texture2D(tDiffuse, texCoord);
            sampleColor *= illuminationDecay * weight;
            godRays += sampleColor;
            illuminationDecay *= decay;
          }

          godRays *= exposure;
          gl_FragColor = color + godRays * 0.3;
        }
      `
    };

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    // Dynamic URL detection - works for both local dev and cloud deployment
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const API_BASE = isLocalhost ? 'http://localhost:8000' : window.location.origin;
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = isLocalhost ? 'localhost:8000' : window.location.host;
    const WS_URL = `${wsProtocol}//${wsHost}/ws/events`;

    const NODE_COLORS = {
      belief: { color: 0xd97706, emissive: 0xfbbf24, label: 'Belief' },       // Amber - convictions (matches legend)
      desire: { color: 0xbe123c, emissive: 0xf43f5e, label: 'Desire' },       // Dark rose (matches legend)
      identity: { color: 0xec4899, emissive: 0xf472b6, label: 'Identity' },    // Pink - emergent identity facets
      experience: { color: 0x0369a1, emissive: 0x0ea5e9, label: 'Experience' }, // Sky blue (matches legend)
      capability: { color: 0x6d28d9, emissive: 0xa855f7, label: 'Capability' }, // Dark violet (matches legend)
      reflection: { color: 0x047857, emissive: 0x34d399, label: 'Reflection' }, // Dark emerald (matches legend)
      awakening: { color: 0xf59e0b, emissive: 0xfcd34d, label: 'Awakening' },  // Golden amber - consciousness
      // Learning system node types
      prediction: { color: 0xeab308, emissive: 0xfde047, label: 'Prediction' }, // Yellow - testable hypothesis
      task: { color: 0x6366f1, emissive: 0xa5b4fc, label: 'Task' },            // Indigo - external goal
      // Crystal memory system
      crystal: { color: 0x8b5cf6, emissive: 0xc4b5fd, label: 'Crystal' },      // Purple - crystallized memories
      // Operating System - BYRD's self-model (black cat head)
      operatingsystem: { color: 0x1a1a2e, emissive: 0x9333ea, label: 'Operating System' }, // Deep midnight with purple glow
      ostemplate: { color: 0x374151, emissive: 0x6366f1, label: 'OS Template' },  // Slate with indigo glow
      seed: { color: 0x166534, emissive: 0x22c55e, label: 'Seed' },             // Deep green - foundation
      constraint: { color: 0x7c2d12, emissive: 0xf97316, label: 'Constraint' }, // Dark orange - limits
      strategy: { color: 0x0e7490, emissive: 0x06b6d4, label: 'Strategy' }     // Cyan - learned approach
    };

    // System node types (cannot be created by BYRD, have fixed colors)
    const SYSTEM_NODE_TYPES = new Set([
      'Experience', 'Belief', 'Desire', 'Reflection', 'Capability', 'Mutation',
      'Identity', 'QuantumMoment', 'SystemState', 'Prediction', 'Task', 'Crystal',
      'OperatingSystem', 'OSTemplate', 'Seed', 'Constraint', 'Strategy'
    ]);

    // Custom node type colors - generated dynamically with distinct hues
    const CUSTOM_TYPE_COLORS = [
      { color: 0x0891b2, emissive: 0x22d3ee, css: 'text-cyan-500' },      // Cyan
      { color: 0x7c3aed, emissive: 0xa78bfa, css: 'text-violet-500' },    // Violet
      { color: 0xdb2777, emissive: 0xf472b6, css: 'text-pink-500' },      // Pink
      { color: 0x059669, emissive: 0x6ee7b7, css: 'text-emerald-500' },   // Emerald
      { color: 0xea580c, emissive: 0xfb923c, css: 'text-orange-500' },    // Orange
      { color: 0x4f46e5, emissive: 0x818cf8, css: 'text-indigo-500' },    // Indigo
      { color: 0xca8a04, emissive: 0xfacc15, css: 'text-yellow-500' },    // Yellow
      { color: 0x0d9488, emissive: 0x5eead4, css: 'text-teal-500' },      // Teal
    ];

    // Track which custom types have been assigned colors
    const customTypeColorMap = new Map();
    let nextCustomColorIndex = 0;

    /**
     * Get or create a color for a custom node type.
     * Returns { color, emissive, css, label }
     */
    function getCustomTypeColor(typeName) {
      const lowerType = typeName.toLowerCase();

      // Check if already in NODE_COLORS (system type)
      if (NODE_COLORS[lowerType]) {
        return NODE_COLORS[lowerType];
      }

      // Check if we've already assigned a color to this custom type
      if (customTypeColorMap.has(typeName)) {
        return customTypeColorMap.get(typeName);
      }

      // Assign next color from palette (cycling if needed)
      const colorDef = CUSTOM_TYPE_COLORS[nextCustomColorIndex % CUSTOM_TYPE_COLORS.length];
      const fullColorDef = {
        ...colorDef,
        label: typeName
      };

      // Register in both maps
      customTypeColorMap.set(typeName, fullColorDef);
      NODE_COLORS[lowerType] = fullColorDef;

      nextCustomColorIndex++;
      return fullColorDef;
    }

    // ==========================================================================
    // STATE
    // ==========================================================================
    let ws = null;
    let connected = false;
    let running = false;
    let events = [];
    let nodes3D = [];
    let connections3D = [];
    let dreamCount = 0;
    let seekCount = 0;
    let currentPhase = 'idle';

    // Event filter state
    const eventFilters = {
      dream_cycle: true,
      belief: true,
      desire: true,
      experience: true,
      reflection: true,
      voice: true,
      system: true,
      external: true,
      other: true
    };

    // Map event types to filter categories
    const eventTypeToCategory = {
      dream_cycle_start: 'dream_cycle',
      dream_cycle_end: 'dream_cycle',
      belief_created: 'belief',
      desire_created: 'desire',
      experience_created: 'experience',
      reflection_created: 'reflection',
      capability_created: 'other',
      node_type_discovered: 'other',
      custom_node_created: 'other',
      seek_started: 'system',
      narrator_update: 'voice',
      inner_voice: 'voice',
      byrd_message: 'voice',
      awakening: 'system',
      system_started: 'system',
      system_reset: 'system',
      external_input_received: 'external',
      feeding_received: 'external',
      connection_created: 'other'
    };

    // Type highlight state
    let highlightedType = null;  // Currently highlighted type, null = none

    // Gravitational Spiral: Connection tracking for centrality-based positioning
    const connectionCounts = new Map(); // nodeId -> connection count
    const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees
    const MAX_RADIUS = 80; // Maximum distance from center
    const MIN_RADIUS = 5;  // Minimum distance (for most connected)

    // Three.js objects
    let scene, camera, renderer, composer, controls;
    let consciousnessCore, coreGlow, coreParticles;
    let starField;
    let clock;
    let raycaster, mouse;
    let hoveredNode = null;

    // Cat model (Byrd's ego form)
    let catModel = null;
    let catMixer = null;
    let eyeMeshes = [];
    let catBreathPhase = 0;
    let catIdlePhase = 0;
    let byrdGrowthFactor = 1.0; // Accumulates growth from feeding

    // Grow BYRD by a percentage when fed
    function growByrd(percent = 5) {
      byrdGrowthFactor *= (1 + percent / 100);
      console.log(`üçú BYRD grew! Growth factor: ${byrdGrowthFactor.toFixed(2)}x`);

      // Visual feedback - brief pulse
      if (catModel) {
        const currentScale = catModel.scale.clone();
        catModel.scale.multiplyScalar(1.15); // Pulse up
        setTimeout(() => {
          // Return to new grown size (handled by animation loop)
        }, 200);
      }
    }

    // Cat Animation System - Advanced state-driven animations
    let catAnimationController = null;

    // ==========================================================================
    // GRAPH MODE STATE
    // ==========================================================================
    // Persistent graph state (mirrors Neo4j database)
    const graphState = {
        nodes: new Map(),           // id ‚Üí node data from API
        relationships: new Map(),   // id ‚Üí relationship data from API
        nodeIdToMesh: new Map(),    // id ‚Üí Three.js mesh
        relationshipLines: [],      // Three.js line objects for relationships
        loaded: false,
        lastFetch: null,
    };

    // ==========================================================================
    // QUANTUM RANDOMNESS STATE
    // ==========================================================================
    const quantumState = {
        enabled: false,
        inFallbackMode: false,
        quantumRatio: 1.0,
        poolSize: 0,
        maxPoolSize: 256,
        lastInfluenceDelta: 0,
        lastInfluenceTime: 0,
        subtleMode: false
    };

    const QUANTUM_COLORS = {
        quantum: new THREE.Color(0x8b5cf6),
        classical: new THREE.Color(0x64748b),
        influence: new THREE.Color(0xc084fc)
    };

    // EMERGENT STRUCTURE: No prescribed type-based sectors
    // Position, size, and geometry determined by connection weight (graph topology)
    // Force-directed physics creates natural clustering based on relationships
    // Highly connected nodes gravitate toward center; isolated nodes drift outward

    // Relationship visual styles - dark grey for sacred geometry aesthetic
    const RELATIONSHIP_STYLES = {
        DERIVED_FROM: {
            color: 0x6366f1,    // Indigo - visible against light background
            opacity: 0.7,
            width: 2
        },
        RELATES_TO: {
            color: 0x8b5cf6,    // Purple
            opacity: 0.5,
            width: 1
        },
        FULFILLS: {
            color: 0x10b981,    // Emerald
            opacity: 0.7,
            width: 2
        },
        REFLECTS_ON: {
            color: 0x6366f1,    // Indigo
            opacity: 0.6,
            width: 1.5
        },
        EMERGES_FROM: {
            color: 0xf59e0b,    // Amber
            opacity: 0.7,
            width: 1.5
        },
        default: {
            color: 0x94a3b8,    // Slate grey - still visible
            opacity: 0.6,
            width: 1
        }
    };

    // ==========================================================================
    // BELIEF CRYSTAL GENERATION
    // ==========================================================================
    // Unique crystal geometry for each belief, seeded by quantum randomness

    /**
     * Get a seeded RNG from quantum seed array or fallback to ID-based hash
     */
    function getCrystalRNG(nodeData) {
      if (nodeData.quantum_seed && nodeData.quantum_seed.length >= 8) {
        return seededRandomFromQuantum(nodeData.quantum_seed);
      }
      return seededRandomFallback(nodeData.id);
    }

    /**
     * RNG seeded from quantum random values (stored at belief creation)
     */
    function seededRandomFromQuantum(quantumSeed) {
      let index = 0;
      return function() {
        const v1 = quantumSeed[index % quantumSeed.length];
        const v2 = quantumSeed[(index + 3) % quantumSeed.length];
        index++;
        return (v1 + v2 * 0.7182818) % 1.0;
      };
    }

    /**
     * Fallback RNG for beliefs without quantum seed (backwards compat)
     */
    function seededRandomFallback(nodeId) {
      let hash = 0;
      for (let i = 0; i < nodeId.length; i++) {
        hash = ((hash << 5) - hash) + nodeId.charCodeAt(i);
        hash = hash & hash;
      }
      return function() {
        hash = (hash * 1103515245 + 12345) & 0x7fffffff;
        return hash / 0x7fffffff;
      };
    }

    /**
     * Create unique crystal geometry based on seeded random parameters
     */
    function createCrystalGeometry(rng, confidence, derivedCount) {
      // Crystal parameters derived from quantum seed
      const sides = Math.floor(rng() * 5) + 4;           // 4-8 sides
      const heightRatio = 1.5 + rng() * 1.5;             // 1.5-3.0
      const twistAngle = (rng() - 0.5) * 0.52;           // ¬±15¬∞ in radians
      const termType = Math.floor(rng() * 4);            // 0-3: pyramidal, chisel, flat, double
      const termRatio = 0.2 + rng() * 0.3;               // 0.2-0.5
      const asymmetry = rng() * 0.3;                     // 0-0.3
      const irregularity = rng() * 0.12;                 // 0-0.12

      // Base size scales with derived count and confidence
      const baseSize = 1.5 + Math.log2(derivedCount + 1) * 0.3 + confidence * 0.5;
      const height = baseSize * heightRatio;
      const termHeight = height * termRatio;

      // Build vertices
      const vertices = [];
      const indices = [];

      // Create prism layers with twist
      const layers = [
        { y: -height / 2, radius: baseSize, twistMult: 0 },
        { y: -height / 2 + termHeight * 0.3, radius: baseSize, twistMult: 0.2 },
        { y: 0, radius: baseSize, twistMult: 0.5 },
        { y: height / 2 - termHeight * 0.3, radius: baseSize, twistMult: 0.8 },
        { y: height / 2, radius: baseSize * (0.85 + rng() * 0.1), twistMult: 1 }
      ];

      // Generate prism vertices
      for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
        const layer = layers[layerIdx];
        const layerTwist = twistAngle * layer.twistMult;

        for (let i = 0; i < sides; i++) {
          const baseAngle = (i / sides) * Math.PI * 2;
          const angle = baseAngle + layerTwist;

          // Add irregularity
          const radiusVar = layer.radius * (1 - irregularity / 2 + rng() * irregularity);
          const angleVar = angle + (rng() - 0.5) * irregularity * 0.5;

          vertices.push(
            Math.cos(angleVar) * radiusVar,
            layer.y,
            Math.sin(angleVar) * radiusVar
          );
        }
      }

      // Add termination points based on type
      const topPointIdx = vertices.length / 3;
      if (termType === 0 || termType === 3) { // pyramidal or double
        vertices.push(0, height / 2 + termHeight * 0.4, 0);
      }

      const bottomPointIdx = vertices.length / 3;
      if (termType === 3) { // double terminated
        vertices.push(0, -height / 2 - termHeight * 0.4, 0);
      }

      // Build faces
      // Side faces (connect adjacent layers)
      for (let layer = 0; layer < layers.length - 1; layer++) {
        const baseA = layer * sides;
        const baseB = (layer + 1) * sides;

        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          // Two triangles per quad
          indices.push(baseA + i, baseB + i, baseB + next);
          indices.push(baseA + i, baseB + next, baseA + next);
        }
      }

      // Top termination (if pyramidal or double)
      if (termType === 0 || termType === 3) {
        const topLayerBase = (layers.length - 1) * sides;
        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          indices.push(topLayerBase + i, topLayerBase + next, topPointIdx);
        }
      } else {
        // Flat or chisel top - fill with triangles
        const topLayerBase = (layers.length - 1) * sides;
        for (let i = 1; i < sides - 1; i++) {
          indices.push(topLayerBase, topLayerBase + i, topLayerBase + i + 1);
        }
      }

      // Bottom termination (if double)
      if (termType === 3) {
        for (let i = 0; i < sides; i++) {
          const next = (i + 1) % sides;
          indices.push(i, bottomPointIdx, next);
        }
      } else {
        // Flat bottom
        for (let i = 1; i < sides - 1; i++) {
          indices.push(0, i + 1, i);
        }
      }

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return {
        geometry,
        params: { sides, heightRatio, twistAngle, termType, asymmetry, irregularity }
      };
    }

    /**
     * Create crystal material with glass-like appearance
     */
    function createCrystalMaterial(rng, baseColor, confidence) {
      const hue = new THREE.Color(baseColor);
      // Slight color variation per crystal
      const hueShift = (rng() - 0.5) * 0.08;
      hue.offsetHSL(hueShift, 0, (rng() - 0.5) * 0.1);

      // Emissive intensity based on confidence
      const emissiveIntensity = 0.15 + confidence * 0.35;

      return new THREE.MeshPhongMaterial({
        color: hue,
        emissive: hue.clone().multiplyScalar(0.5),
        emissiveIntensity: emissiveIntensity,
        transparent: true,
        opacity: 0.75 + confidence * 0.2,
        shininess: 80 + rng() * 40,
        specular: new THREE.Color(0xffffff),
        side: THREE.DoubleSide
      });
    }

    /**
     * Create inner glow effect for crystal
     */
    function createCrystalInnerGlow(crystalMesh, color, confidence) {
      const innerGeometry = crystalMesh.geometry.clone();
      innerGeometry.scale(0.5, 0.5, 0.5);

      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.25 + confidence * 0.25,
        blending: THREE.AdditiveBlending
      });

      const innerGlow = new THREE.Mesh(innerGeometry, glowMaterial);
      crystalMesh.add(innerGlow);

      return innerGlow;
    }

    /**
     * Create cat head geometry for Operating System node
     * The OS is visualized as a black cat head - BYRD's avatar and self-model
     */
    function createCatHeadGeometry(size = 2) {
      const group = new THREE.Group();

      // Main head (squashed sphere)
      const headGeom = new THREE.SphereGeometry(size, 32, 32);
      headGeom.scale(1, 0.9, 0.85);
      const headMat = new THREE.MeshPhysicalMaterial({
        color: 0x1a1a2e,      // Deep midnight
        emissive: 0x4c1d95,   // Purple glow
        emissiveIntensity: 0.3,
        metalness: 0.1,
        roughness: 0.7,
        transparent: true,
        opacity: 0.95
      });
      const head = new THREE.Mesh(headGeom, headMat);
      group.add(head);

      // Left ear (cone, slightly rotated)
      const earGeom = new THREE.ConeGeometry(size * 0.35, size * 0.7, 4);
      const leftEar = new THREE.Mesh(earGeom, headMat.clone());
      leftEar.position.set(-size * 0.5, size * 0.75, 0);
      leftEar.rotation.z = 0.2;
      leftEar.rotation.x = 0.1;
      group.add(leftEar);

      // Right ear
      const rightEar = new THREE.Mesh(earGeom.clone(), headMat.clone());
      rightEar.position.set(size * 0.5, size * 0.75, 0);
      rightEar.rotation.z = -0.2;
      rightEar.rotation.x = 0.1;
      group.add(rightEar);

      // Glowing amber eyes
      const eyeGeom = new THREE.SphereGeometry(size * 0.18, 16, 16);
      const eyeMat = new THREE.MeshBasicMaterial({
        color: 0xfbbf24,
        transparent: true,
        opacity: 0.95
      });

      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-size * 0.28, size * 0.08, size * 0.72);
      group.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeom.clone(), eyeMat.clone());
      rightEye.position.set(size * 0.28, size * 0.08, size * 0.72);
      group.add(rightEye);

      // Vertical slit pupils
      const pupilGeom = new THREE.PlaneGeometry(size * 0.04, size * 0.15);
      const pupilMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.DoubleSide
      });

      const leftPupil = new THREE.Mesh(pupilGeom, pupilMat);
      leftPupil.position.set(-size * 0.28, size * 0.08, size * 0.88);
      group.add(leftPupil);

      const rightPupil = new THREE.Mesh(pupilGeom.clone(), pupilMat.clone());
      rightPupil.position.set(size * 0.28, size * 0.08, size * 0.88);
      group.add(rightPupil);

      // Small nose
      const noseGeom = new THREE.SphereGeometry(size * 0.08, 8, 8);
      const noseMat = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // Pink
      const nose = new THREE.Mesh(noseGeom, noseMat);
      nose.position.set(0, -size * 0.12, size * 0.78);
      group.add(nose);

      // Store reference for breathing animation
      group.userData.isOSNode = true;
      group.userData.headMesh = head;
      group.userData.eyes = [leftEye, rightEye];

      return group;
    }

    // Track OS node for special animation
    let osNodeGroup = null;

    /**
     * Create a crystal node for beliefs, desires, or seeks
     * Uses procedural geometry from quantum seed for uniqueness
     */
    function createCrystalNode(nodeData, position) {
      console.log(`üîÆ Creating crystal for ${nodeData.type}: ${nodeData.id?.slice(0,8)}...`);

      // Prevent duplicates
      if (graphState.nodeIdToMesh.has(nodeData.id)) {
        console.log('  ‚Ü™ Already exists in nodeIdToMesh');
        return graphState.nodeIdToMesh.get(nodeData.id);
      }
      const existingNode = nodes3D.find(n => n.userData.id === nodeData.id);
      if (existingNode) {
        console.log('  ‚Ü™ Already exists in nodes3D');
        return existingNode;
      }

      const type = nodeData.type || 'belief';
      const colors = NODE_COLORS[type] || NODE_COLORS.belief;
      const confidence = nodeData.confidence || nodeData.intensity || 0.5;
      const derivedCount = nodeData.derived_count || nodeData.source_count || 1;

      // Get seeded RNG from quantum seed or fallback
      const rng = getCrystalRNG(nodeData);

      // Create unique crystal geometry
      let geometry, params;
      try {
        const result = createCrystalGeometry(rng, confidence, derivedCount);
        geometry = result.geometry;
        params = result.params;
        console.log(`  ‚úì Crystal geometry created: ${params.sides} sides`);
      } catch (e) {
        console.error('  ‚úó Crystal geometry error:', e);
        // Fallback to simple geometry
        geometry = new THREE.OctahedronGeometry(2, 0);
        params = { sides: 8 };
      }

      // Create crystal material with confidence-based glow
      const material = createCrystalMaterial(rng, colors.color, confidence);

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(position.x, position.y, position.z);

      // Random initial rotation for variety
      mesh.rotation.set(
        rng() * Math.PI * 2,
        rng() * Math.PI * 2,
        rng() * Math.PI * 2
      );

      // Add inner glow effect
      const innerGlow = createCrystalInnerGlow(mesh, colors.color, confidence);

      // Store crystal-specific data
      mesh.userData = {
        id: nodeData.id,
        type: type,
        content: nodeData.content,
        importance: confidence,
        confidence: confidence,
        nodeData: nodeData,
        baseScale: 1,
        baseColor: colors.color,
        baseEmissive: colors.emissive || colors.color,
        targetScale: new THREE.Vector3(1, 1, 1),
        velocity: new THREE.Vector3(0, 0, 0),
        force: new THREE.Vector3(0, 0, 0),
        createdAt: Date.now(),
        isGraphNode: true,
        isCrystal: true,  // Flag for crystal-specific interactions
        innerGlow: innerGlow,
        rotationSpeed: new THREE.Vector3(
          (rng() - 0.5) * 0.002,
          (rng() - 0.5) * 0.003,
          (rng() - 0.5) * 0.002
        )
      };

      scene.add(mesh);
      nodes3D.push(mesh);
      graphState.nodeIdToMesh.set(nodeData.id, mesh);
      connectionCounts.set(nodeData.id, 0);

      return mesh;
    }

    /**
     * Types that should render as crystals
     */
    const CRYSTAL_TYPES = ['belief', 'desire', 'Belief', 'Desire'];

    /**
     * Check if a node type can potentially be a crystal
     */
    function isCrystalType(type) {
      return CRYSTAL_TYPES.includes(type);
    }

    /**
     * Check if a node should actually render as a crystal.
     * Only beliefs/desires that are "crystallized" (derived from 2+ sources)
     * render as crystals. Single-source beliefs render as regular spheres.
     */
    function shouldRenderAsCrystal(node) {
      const type = node.type || '';
      if (!CRYSTAL_TYPES.some(t => t.toLowerCase() === type.toLowerCase())) {
        return false;
      }
      // A belief/desire is "crystallized" when it has absorbed multiple sources
      const derivedCount = node.derived_count || node.source_count || 0;
      const isCrystallized = derivedCount >= 2;
      console.log(`üîÆ ${type} "${node.id?.slice(0,8)}..." derived_count=${derivedCount} ‚Üí ${isCrystallized ? 'CRYSTAL' : 'sphere'}`);
      return isCrystallized;
    }

    /**
     * Check if an experience is absorbed into a crystal
     */
    function isAbsorbedExperience(node) {
      return node.absorbed === true;
    }

    // ==========================================================================
    // DOM ELEMENTS
    // ==========================================================================
    const container = document.getElementById('canvas-container');
    const connectionStatus = document.getElementById('connection-status');
    const connectionDot = document.getElementById('connection-dot');
    const connectionText = document.getElementById('connection-text');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const btnFastForward = document.getElementById('btn-fast-forward');
    const btnClearLog = document.getElementById('btn-clear-log');
    const btnExportLog = document.getElementById('btn-export-log');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const eventList = document.getElementById('event-list');
    const eventCount = document.getElementById('event-count');
    const dreamCountEl = document.getElementById('dream-count');
    const seekCountEl = document.getElementById('seek-count');
    const nodeCountEl = document.getElementById('node-count');
    const expCountEl = document.getElementById('exp-count');
    const beliefCountEl = document.getElementById('belief-count');
    const reflectionCountEl = document.getElementById('reflection-count');
    const desireCountEl = document.getElementById('desire-count');
    const mutationCountEl = document.getElementById('mutation-count');
    const customTypesContainer = document.getElementById('custom-types-container');
    const btnToggleLog = document.getElementById('btn-toggle-log');
    const eventPanelContainer = document.getElementById('event-panel-container');
    const tooltip = document.getElementById('node-tooltip');
    const tooltipType = document.getElementById('tooltip-type');
    const tooltipContent = document.getElementById('tooltip-content');
    const tooltipMeta = document.getElementById('tooltip-meta');

    // Phase 4: New DOM references
    const detailPanel = document.getElementById('detail-panel');
    const detailTypeDot = document.getElementById('detail-type-dot');
    const detailType = document.getElementById('detail-type');
    const detailContent = document.getElementById('detail-content');
    const detailImportance = document.getElementById('detail-importance');
    const detailImportanceBar = document.getElementById('detail-importance-bar');
    const detailConnections = document.getElementById('detail-connections');
    const detailCreated = document.getElementById('detail-created');
    const detailRelatedList = document.getElementById('detail-related-list');
    const btnCloseDetail = document.getElementById('btn-close-detail');
    const loadingOverlay = document.getElementById('loading-overlay');
    const cameraIndicator = document.getElementById('camera-indicator');
    const cameraIndicatorText = document.getElementById('camera-indicator-text');

    // Crystal Modal DOM Elements
    const crystalModal = document.getElementById('crystal-modal');
    const crystalModalDot = document.getElementById('crystal-modal-dot');
    const crystalModalType = document.getElementById('crystal-modal-type');
    const crystalModalConfidence = document.getElementById('crystal-modal-confidence');
    const crystalModalContent = document.getElementById('crystal-modal-content');
    const crystalSourceCount = document.getElementById('crystal-source-count');
    const crystalSourcesList = document.getElementById('crystal-sources-list');
    const crystalQuantumSeed = document.getElementById('crystal-quantum-seed');
    const btnCloseCrystalModal = document.getElementById('btn-close-crystal-modal');

    // Phase 4: State
    let selectedNode = null;
    let selectedNodeIndex = -1;
    let isTransitioning = false;

    // ==========================================================================
    // NAVIGATION STATE (Hybrid Controls)
    // ==========================================================================
    const NAV = {
      // Key states
      keys: {
        w: false, a: false, s: false, d: false,
        q: false, e: false, shift: false
      },
      // Mode
      flyMode: false,
      // Movement settings
      baseSpeed: 40,
      boostMultiplier: 2.5,
      // Camera presets
      presets: {
        1: { pos: [0, 30, 80], target: [0, 0, 0], name: 'Default' },
        2: { pos: [0, 120, 0], target: [0, 0, 0], name: 'Top Down' },
        3: { pos: [120, 30, 0], target: [0, 0, 0], name: 'Side View' },
        4: { pos: [0, 10, 60], target: [0, 0, 0], name: 'Front' },
        5: { pos: [60, 60, 60], target: [0, 0, 0], name: 'Isometric' }
      }
    };

    // ==========================================================================
    // THREE.JS SETUP
    // ==========================================================================
    function initThree() {
      clock = new THREE.Clock();
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Scene - Light theme (clean, no fog)
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc);
      // No fog for light theme

      // Camera - start focused on center where OS (cat head) lives
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 8, 25);  // Closer to center, slight elevation
      camera.lookAt(0, 0, 0);  // Always looking at center where OS node is

      // Renderer - simple, clean rendering for light theme
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // No post-processing for light theme - use simple render pass only
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      // All other effects disabled for clean light theme

      // Controls (Hybrid Navigation)
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 5;          // Get very close to nodes
      controls.maxDistance = 500;        // See entire mind space
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.03;  // Slowed to 10% of original
      controls.maxPolarAngle = Math.PI * 0.95;  // Almost full vertical range
      controls.minPolarAngle = Math.PI * 0.05;
      controls.enablePan = true;         // Enable right-click panning
      controls.panSpeed = 1.0;
      controls.zoomSpeed = 1.2;

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
      scene.add(ambientLight);

      // Point light at center
      const centerLight = new THREE.PointLight(0x6366f1, 2, 100);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);

      // Create environment (no star field for light theme)
      // createStarField();
      createConsciousnessCore();
      // createAmbientParticles();  // Skip for cleaner light theme

      // Load Byrd's cat form at the center
      loadCatModel();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('dblclick', onDoubleClick);

      // Phase 4: Detail panel close button
      btnCloseDetail.addEventListener('click', () => {
        deselectNode();
      });

      // Crystal modal close button
      btnCloseCrystalModal.addEventListener('click', () => {
        hideCrystalModal();
      });

      // Crystal modal backdrop click to close
      crystalModal.addEventListener('click', (e) => {
        if (e.target === crystalModal) {
          hideCrystalModal();
        }
      });

      // ESC key to close crystal modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !crystalModal.classList.contains('hidden')) {
          hideCrystalModal();
        }
      });

      // Phase 4: Hide loading overlay after init
      setTimeout(() => {
        hideLoadingOverlay();
      }, 1000);

      // Start render loop
      animate();
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 1: Core Infrastructure
    // ==========================================================================

    /**
     * Cat States - Each correlates to cognitive processes
     */
    const CatState = {
      IDLE: 'idle',
      DREAMING: 'dreaming',
      SEEKING: 'seeking',
      PROCESSING: 'processing',
      ALERT: 'alert',
      SATISFIED: 'satisfied',
      FRUSTRATED: 'frustrated',
      CONNECTING: 'connecting',
      QUANTUM: 'quantum'
    };

    /**
     * State transition definitions - maps events to state changes
     */
    const StateTransitions = {
      'dream_cycle_start':     { to: CatState.DREAMING,   duration: 800 },
      'dream_cycle_end':       { to: CatState.IDLE,       duration: 1000 },
      'dream_phase_recall':    { to: CatState.DREAMING,   duration: 300 },
      'dream_phase_associate': { to: CatState.CONNECTING, duration: 300 },
      'dream_phase_reflect':   { to: CatState.DREAMING,   duration: 300 },
      'seek_cycle_start':      { to: CatState.SEEKING,    duration: 400 },
      'seek_cycle_end':        { to: CatState.IDLE,       duration: 600 },
      'desire_created':        { to: CatState.ALERT,      duration: 200, returnTo: CatState.IDLE, returnAfter: 2000 },
      'desire_fulfilled':      { to: CatState.SATISFIED,  duration: 300, returnTo: CatState.IDLE, returnAfter: 3000 },
      'desire_stuck':          { to: CatState.FRUSTRATED, duration: 500, returnTo: CatState.IDLE, returnAfter: 4000 },
      'desire_attempt_failed': { to: CatState.FRUSTRATED, duration: 400, returnTo: CatState.IDLE, returnAfter: 2500 },
      'quantum_collapse':      { to: CatState.QUANTUM,    duration: 100, returnTo: CatState.IDLE, returnAfter: 1500 },
      'coder_invoked':         { to: CatState.PROCESSING, duration: 300 },
      'coder_complete':        { to: CatState.SATISFIED,  duration: 400, returnTo: CatState.IDLE, returnAfter: 2000 },
      'coder_failed':          { to: CatState.FRUSTRATED, duration: 400, returnTo: CatState.IDLE, returnAfter: 2500 },
      'memories_accessed':     { to: CatState.CONNECTING, duration: 200, returnTo: CatState.IDLE, returnAfter: 1500 },
      'belief_created':        { to: CatState.ALERT,      duration: 150, returnTo: CatState.IDLE, returnAfter: 1500 },
      'crystal_created':       { to: CatState.SATISFIED,  duration: 300, returnTo: CatState.IDLE, returnAfter: 2500 },
      'awakening':             { to: CatState.ALERT,      duration: 500, returnTo: CatState.IDLE, returnAfter: 3000 },
      'research_start':        { to: CatState.SEEKING,    duration: 300 },
      'research_complete':     { to: CatState.SATISFIED,  duration: 400, returnTo: CatState.IDLE, returnAfter: 2000 },
      'inner_voice':           { to: CatState.DREAMING,   duration: 200, returnTo: CatState.IDLE, returnAfter: 2000 },
      'reflection_created':    { to: CatState.SATISFIED,  duration: 300, returnTo: CatState.IDLE, returnAfter: 2000 },
      'identity_created':      { to: CatState.ALERT,      duration: 400, returnTo: CatState.IDLE, returnAfter: 3000 },
      'identity_evolved':      { to: CatState.ALERT,      duration: 500, returnTo: CatState.IDLE, returnAfter: 3000 },
      'feeding_received':      { to: CatState.SATISFIED,  duration: 400, returnTo: CatState.IDLE, returnAfter: 4000 }
    };

    /**
     * CatStateMachine - Manages state transitions with smooth blending
     */
    class CatStateMachine {
      constructor() {
        this.currentState = CatState.IDLE;
        this.previousState = CatState.IDLE;
        this.blendFactor = 1.0; // 1.0 = fully in current state
        this.transitionStart = 0;
        this.transitionDuration = 0;
        this.returnTimer = null;
        this.returnState = null;
      }

      transition(newState, duration = 500) {
        if (newState === this.currentState && this.blendFactor >= 1.0) return;

        // Cancel any pending return
        if (this.returnTimer) {
          clearTimeout(this.returnTimer);
          this.returnTimer = null;
        }

        this.previousState = this.currentState;
        this.currentState = newState;
        this.transitionStart = performance.now();
        this.transitionDuration = duration;
        this.blendFactor = 0;
      }

      scheduleReturn(returnState, delay) {
        if (this.returnTimer) {
          clearTimeout(this.returnTimer);
        }
        this.returnTimer = setTimeout(() => {
          this.transition(returnState, 800);
          this.returnTimer = null;
        }, delay);
      }

      update(now) {
        if (this.blendFactor < 1.0 && this.transitionDuration > 0) {
          const elapsed = now - this.transitionStart;
          this.blendFactor = Math.min(1.0, elapsed / this.transitionDuration);
          // Apply easing
          this.blendFactor = this.easeOutCubic(this.blendFactor);
        }
        return this.blendFactor;
      }

      easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      getBlendedValue(idleValue, stateValue) {
        const prevValue = this.previousState === CatState.IDLE ? idleValue : stateValue;
        const currValue = this.currentState === CatState.IDLE ? idleValue : stateValue;
        return prevValue + (currValue - prevValue) * this.blendFactor;
      }
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 2: Body Controllers
    // ==========================================================================

    /**
     * EyeController - Manages pupil dilation, blinking, glow, and look-at
     */
    class EyeController {
      constructor() {
        this.pupilDilation = 0.5;      // 0=constricted, 1=dilated
        this.targetDilation = 0.5;
        this.blinkProgress = 0;         // 0=open, 1=closed
        this.isBlinking = false;
        this.blinkTimer = 0;
        this.nextBlinkTime = this.randomBlinkInterval();
        this.emissiveIntensity = 0.8;
        this.targetEmissive = 0.8;
        this.lookAtTarget = new THREE.Vector3(0, 0, 1);
        this.currentLookAt = new THREE.Vector3(0, 0, 1);
      }

      randomBlinkInterval() {
        return 2000 + Math.random() * 4000; // 2-6 seconds
      }

      update(delta, state, eyeMeshes) {
        const now = performance.now();

        // State-based pupil dilation
        switch(state) {
          case CatState.DREAMING:
            this.targetDilation = 0.3;
            this.targetEmissive = 0.4;
            break;
          case CatState.SEEKING:
          case CatState.ALERT:
            this.targetDilation = 0.9;
            this.targetEmissive = 1.2;
            break;
          case CatState.SATISFIED:
            this.targetDilation = 0.4;
            this.targetEmissive = 1.0;
            break;
          case CatState.FRUSTRATED:
            this.targetDilation = 0.7;
            this.targetEmissive = 0.6;
            break;
          case CatState.QUANTUM:
            this.targetDilation = 0.1;
            this.targetEmissive = 1.5;
            break;
          case CatState.PROCESSING:
            this.targetDilation = 0.6;
            this.targetEmissive = 0.9;
            break;
          default:
            this.targetDilation = 0.5;
            this.targetEmissive = 0.8;
        }

        // Smooth dilation transition
        this.pupilDilation += (this.targetDilation - this.pupilDilation) * delta * 3;
        this.emissiveIntensity += (this.targetEmissive - this.emissiveIntensity) * delta * 4;

        // Natural blinking
        this.blinkTimer += delta * 1000;
        if (!this.isBlinking && this.blinkTimer >= this.nextBlinkTime) {
          this.isBlinking = true;
          this.blinkProgress = 0;
        }

        if (this.isBlinking) {
          this.blinkProgress += delta * 8; // Fast blink
          if (this.blinkProgress >= 2) {
            this.isBlinking = false;
            this.blinkProgress = 0;
            this.blinkTimer = 0;
            this.nextBlinkTime = this.randomBlinkInterval();
          }
        }

        // Calculate blink curve (close then open)
        const blinkValue = this.isBlinking ?
          (this.blinkProgress < 1 ? this.blinkProgress : 2 - this.blinkProgress) : 0;

        // Apply to eye meshes
        eyeMeshes.forEach(eye => {
          if (eye.material) {
            // Emissive intensity with blink
            eye.material.emissiveIntensity = this.emissiveIntensity * (1 - blinkValue * 0.8);

            // Scale for pupil dilation effect (if geometry supports it)
            const baseScale = 1.0;
            const dilationScale = 0.8 + this.pupilDilation * 0.4;
            eye.scale.setScalar(baseScale * dilationScale * (1 - blinkValue * 0.3));
          }
        });

        // Smooth look-at interpolation
        this.currentLookAt.lerp(this.lookAtTarget, delta * 2);
      }

      triggerBlink() {
        if (!this.isBlinking) {
          this.isBlinking = true;
          this.blinkProgress = 0;
        }
      }

      setLookAt(target) {
        this.lookAtTarget.copy(target);
      }
    }

    /**
     * EarController - Manages ear rotation and alertness
     */
    class EarController {
      constructor() {
        this.alertness = 0.5;           // 0=relaxed, 1=fully alert
        this.targetAlertness = 0.5;
        this.twitchAmount = 0;
        this.twitchPhase = 0;
        this.isTwitching = false;
        this.leftRotation = 0;
        this.rightRotation = 0;
      }

      update(delta, state) {
        // State-based alertness
        switch(state) {
          case CatState.DREAMING:
            this.targetAlertness = 0.2;
            break;
          case CatState.SEEKING:
          case CatState.ALERT:
            this.targetAlertness = 1.0;
            break;
          case CatState.SATISFIED:
            this.targetAlertness = 0.3;
            break;
          case CatState.FRUSTRATED:
            this.targetAlertness = 0.7;
            if (Math.random() < delta * 2) this.triggerTwitch();
            break;
          case CatState.QUANTUM:
            this.targetAlertness = 0.9;
            break;
          default:
            this.targetAlertness = 0.5;
        }

        // Smooth alertness transition
        this.alertness += (this.targetAlertness - this.alertness) * delta * 2;

        // Handle twitching
        if (this.isTwitching) {
          this.twitchPhase += delta * 20;
          this.twitchAmount = Math.sin(this.twitchPhase) * Math.exp(-this.twitchPhase * 0.3);
          if (this.twitchPhase > 10) {
            this.isTwitching = false;
            this.twitchAmount = 0;
          }
        }

        // Calculate ear rotations
        const baseRotation = (1 - this.alertness) * 0.3; // More relaxed = more tilted back
        this.leftRotation = baseRotation + this.twitchAmount * 0.2;
        this.rightRotation = baseRotation - this.twitchAmount * 0.15;
      }

      triggerTwitch() {
        if (!this.isTwitching) {
          this.isTwitching = true;
          this.twitchPhase = 0;
        }
      }
    }

    /**
     * BodyPoseController - Manages breathing, sway, and posture
     */
    class BodyPoseController {
      constructor() {
        this.breathRate = 0.4;
        this.breathDepth = 0.03;
        this.swayAmount = 0.03;
        this.leanAngle = 0;
        this.targetLean = 0;
        this.purrIntensity = 0;
        this.targetPurr = 0;
      }

      update(delta, state, elapsed) {
        // State-based breathing and posture
        switch(state) {
          case CatState.DREAMING:
            this.breathRate = 0.25;
            this.breathDepth = 0.04;
            this.swayAmount = 0.02;
            this.targetLean = 0;
            this.targetPurr = 0;
            break;
          case CatState.SEEKING:
            this.breathRate = 0.6;
            this.breathDepth = 0.02;
            this.swayAmount = 0.01;
            this.targetLean = 0.05;
            this.targetPurr = 0;
            break;
          case CatState.ALERT:
            this.breathRate = 0.5;
            this.breathDepth = 0.025;
            this.swayAmount = 0.005;
            this.targetLean = 0.08;
            this.targetPurr = 0;
            break;
          case CatState.SATISFIED:
            this.breathRate = 0.35;
            this.breathDepth = 0.035;
            this.swayAmount = 0.015;
            this.targetLean = -0.02;
            this.targetPurr = 0.8;
            break;
          case CatState.FRUSTRATED:
            this.breathRate = 0.7;
            this.breathDepth = 0.025;
            this.swayAmount = 0.04;
            this.targetLean = 0;
            this.targetPurr = 0;
            break;
          case CatState.QUANTUM:
            this.breathRate = 0.1;
            this.breathDepth = 0.01;
            this.swayAmount = 0;
            this.targetLean = 0;
            this.targetPurr = 0;
            break;
          case CatState.PROCESSING:
            this.breathRate = 0.45;
            this.breathDepth = 0.03;
            this.swayAmount = 0.01;
            this.targetLean = 0.03;
            this.targetPurr = 0;
            break;
          default:
            this.breathRate = 0.4;
            this.breathDepth = 0.03;
            this.swayAmount = 0.03;
            this.targetLean = 0;
            this.targetPurr = 0;
        }

        // Smooth transitions
        this.leanAngle += (this.targetLean - this.leanAngle) * delta * 2;
        this.purrIntensity += (this.targetPurr - this.purrIntensity) * delta * 3;

        // Calculate current breath phase
        const breathPhase = Math.sin(elapsed * this.breathRate * Math.PI * 2);

        // Add purr vibration (fast small oscillation)
        const purrVibration = this.purrIntensity * Math.sin(elapsed * 25) * 0.003;

        return {
          breathScale: 1 + breathPhase * this.breathDepth + purrVibration,
          swayRotation: Math.sin(elapsed * 0.2) * this.swayAmount,
          leanAngle: this.leanAngle
        };
      }
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 3: Whisker System
    // ==========================================================================

    /**
     * WhiskerController - Dynamic whisker lines connecting to memory nodes
     */
    class WhiskerController {
      constructor(scene) {
        this.scene = scene;
        this.whiskers = [];
        this.whiskerCount = 12; // 6 per side
        this.targetNodes = [];
        this.activeConnections = [];
        this.connectionOpacity = 0;
        this.targetOpacity = 0;
        this.initialized = false;
      }

      initialize(catPosition) {
        if (this.initialized) return;

        const whiskerMaterial = new THREE.LineBasicMaterial({
          color: 0xd4af37,
          transparent: true,
          opacity: 0
        });

        // Create whisker lines (start points on cat face, end points dynamic)
        for (let i = 0; i < this.whiskerCount; i++) {
          const side = i < 6 ? -1 : 1;
          const index = i % 6;

          // Base positions on cat face
          const angleSpread = (index - 2.5) * 0.15;
          const baseX = side * 0.8;
          const baseY = 0.2 + Math.abs(index - 2.5) * 0.1;
          const baseZ = 1.2;

          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array([
            baseX, baseY, baseZ,
            baseX + side * 2, baseY + angleSpread, baseZ + 0.5
          ]);
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

          const whisker = new THREE.Line(geometry, whiskerMaterial.clone());
          whisker.userData = {
            basePosition: new THREE.Vector3(baseX, baseY, baseZ),
            side: side,
            index: index,
            targetNode: null,
            extendFactor: 0
          };

          this.whiskers.push(whisker);
          this.scene.add(whisker);
        }

        this.initialized = true;
      }

      update(delta, state, catModel, accessedNodeIds = []) {
        if (!this.initialized || !catModel) return;

        // State-based whisker activity
        switch(state) {
          case CatState.CONNECTING:
          case CatState.SEEKING:
            this.targetOpacity = 0.7;
            break;
          case CatState.DREAMING:
            this.targetOpacity = 0.3;
            break;
          default:
            this.targetOpacity = 0;
        }

        // Smooth opacity transition
        this.connectionOpacity += (this.targetOpacity - this.connectionOpacity) * delta * 3;

        // Update whisker positions
        const catPos = catModel.position;
        const catRot = catModel.rotation.y;

        this.whiskers.forEach((whisker, i) => {
          const userData = whisker.userData;

          // Transform base position with cat rotation
          const rotatedX = userData.basePosition.x * Math.cos(catRot) - userData.basePosition.z * Math.sin(catRot);
          const rotatedZ = userData.basePosition.x * Math.sin(catRot) + userData.basePosition.z * Math.cos(catRot);

          const startPos = new THREE.Vector3(
            catPos.x + rotatedX,
            catPos.y + userData.basePosition.y,
            catPos.z + rotatedZ
          );

          // Find target node for this whisker
          let endPos;
          if (accessedNodeIds.length > 0 && i < accessedNodeIds.length) {
            const targetNodeId = accessedNodeIds[i % accessedNodeIds.length];
            const targetMesh = nodes3D.find(n => n.userData?.id === targetNodeId);
            if (targetMesh) {
              endPos = targetMesh.position.clone();
              userData.extendFactor = Math.min(1, userData.extendFactor + delta * 3);
            } else {
              endPos = this.getIdleEndPosition(startPos, userData, catRot);
              userData.extendFactor = Math.max(0, userData.extendFactor - delta * 2);
            }
          } else {
            endPos = this.getIdleEndPosition(startPos, userData, catRot);
            userData.extendFactor = Math.max(0, userData.extendFactor - delta * 2);
          }

          // Interpolate to target
          const currentEnd = new THREE.Vector3().lerpVectors(
            this.getIdleEndPosition(startPos, userData, catRot),
            endPos,
            userData.extendFactor
          );

          // Update geometry
          const positions = whisker.geometry.attributes.position.array;
          positions[0] = startPos.x;
          positions[1] = startPos.y;
          positions[2] = startPos.z;
          positions[3] = currentEnd.x;
          positions[4] = currentEnd.y;
          positions[5] = currentEnd.z;
          whisker.geometry.attributes.position.needsUpdate = true;

          // Update opacity
          whisker.material.opacity = this.connectionOpacity * (0.5 + userData.extendFactor * 0.5);
        });
      }

      getIdleEndPosition(startPos, userData, catRot) {
        const length = 3;
        const angleSpread = (userData.index - 2.5) * 0.2;
        const endX = userData.side * length;
        const endY = angleSpread;
        const endZ = length * 0.3;

        // Rotate with cat
        const rotatedX = endX * Math.cos(catRot) - endZ * Math.sin(catRot);
        const rotatedZ = endX * Math.sin(catRot) + endZ * Math.cos(catRot);

        return new THREE.Vector3(
          startPos.x + rotatedX,
          startPos.y + endY,
          startPos.z + rotatedZ
        );
      }

      setAccessedNodes(nodeIds) {
        this.targetNodes = nodeIds;
      }

      dispose() {
        this.whiskers.forEach(w => {
          this.scene.remove(w);
          w.geometry.dispose();
          w.material.dispose();
        });
        this.whiskers = [];
        this.initialized = false;
      }
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 4: Particle Effects
    // ==========================================================================

    /**
     * CatParticleSystem - Aura, thought particles, and quantum effects
     */
    class CatParticleSystem {
      constructor(scene) {
        this.scene = scene;
        this.auraParticles = null;
        this.thoughtParticles = [];
        this.quantumBurstParticles = [];
        this.auraEnabled = false;
        this.auraOpacity = 0;
        this.initialized = false;
      }

      initialize(catPosition) {
        if (this.initialized) return;

        // Create orbital aura particles
        const auraCount = 100;
        const auraGeometry = new THREE.BufferGeometry();
        const auraPositions = new Float32Array(auraCount * 3);
        const auraSizes = new Float32Array(auraCount);
        const auraPhases = new Float32Array(auraCount);

        for (let i = 0; i < auraCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const radius = 3 + Math.random() * 2;

          auraPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
          auraPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) - 1;
          auraPositions[i * 3 + 2] = radius * Math.cos(phi);

          auraSizes[i] = 0.05 + Math.random() * 0.1;
          auraPhases[i] = Math.random() * Math.PI * 2;
        }

        auraGeometry.setAttribute('position', new THREE.BufferAttribute(auraPositions, 3));
        auraGeometry.setAttribute('size', new THREE.BufferAttribute(auraSizes, 1));
        auraGeometry.setAttribute('phase', new THREE.BufferAttribute(auraPhases, 1));

        const auraMaterial = new THREE.PointsMaterial({
          color: 0x8b5cf6,
          size: 0.1,
          transparent: true,
          opacity: 0,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true
        });

        this.auraParticles = new THREE.Points(auraGeometry, auraMaterial);
        this.auraParticles.userData.phases = auraPhases;
        this.auraParticles.userData.basePositions = auraPositions.slice();
        this.scene.add(this.auraParticles);

        this.initialized = true;
      }

      update(delta, state, catModel, elapsed) {
        if (!this.initialized || !catModel) return;

        // State-based aura visibility
        switch(state) {
          case CatState.DREAMING:
            this.auraEnabled = true;
            this.auraOpacity = 0.4;
            break;
          case CatState.SATISFIED:
            this.auraEnabled = true;
            this.auraOpacity = 0.6;
            break;
          case CatState.QUANTUM:
            this.auraEnabled = true;
            this.auraOpacity = 0.8;
            break;
          default:
            this.auraEnabled = false;
            this.auraOpacity = 0;
        }

        // Update aura particles
        if (this.auraParticles) {
          const targetOpacity = this.auraEnabled ? this.auraOpacity : 0;
          this.auraParticles.material.opacity += (targetOpacity - this.auraParticles.material.opacity) * delta * 3;

          // Animate orbital motion
          const positions = this.auraParticles.geometry.attributes.position.array;
          const basePositions = this.auraParticles.userData.basePositions;
          const phases = this.auraParticles.userData.phases;

          for (let i = 0; i < positions.length / 3; i++) {
            const phase = phases[i];
            const orbitSpeed = 0.3 + (i % 5) * 0.05;
            const wobble = Math.sin(elapsed * orbitSpeed + phase) * 0.5;

            positions[i * 3] = basePositions[i * 3] + catModel.position.x + wobble;
            positions[i * 3 + 1] = basePositions[i * 3 + 1] + catModel.position.y + Math.sin(elapsed * 0.5 + phase) * 0.3;
            positions[i * 3 + 2] = basePositions[i * 3 + 2] + catModel.position.z + Math.cos(elapsed * orbitSpeed + phase) * 0.5;
          }
          this.auraParticles.geometry.attributes.position.needsUpdate = true;

          // Color shift based on state
          if (state === CatState.QUANTUM) {
            this.auraParticles.material.color.setHex(0xc084fc);
          } else if (state === CatState.SATISFIED) {
            this.auraParticles.material.color.setHex(0xd4af37);
          } else {
            this.auraParticles.material.color.setHex(0x8b5cf6);
          }
        }

        // Update thought particles
        this.updateThoughtParticles(delta, catModel);

        // Update quantum burst
        this.updateQuantumBurst(delta);
      }

      spawnThoughtParticle(catModel) {
        if (!catModel || this.thoughtParticles.length > 20) return;

        const geometry = new THREE.SphereGeometry(0.08, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: 0xfcd34d,
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);

        particle.position.set(
          catModel.position.x + (Math.random() - 0.5) * 0.5,
          catModel.position.y + 1.5,
          catModel.position.z + (Math.random() - 0.5) * 0.5
        );
        particle.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            1 + Math.random() * 0.5,
            (Math.random() - 0.5) * 0.5
          ),
          life: 1.0
        };

        this.thoughtParticles.push(particle);
        this.scene.add(particle);
      }

      updateThoughtParticles(delta, catModel) {
        for (let i = this.thoughtParticles.length - 1; i >= 0; i--) {
          const particle = this.thoughtParticles[i];

          // Update position
          particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
          particle.userData.velocity.y += delta * 0.5; // Float upward

          // Fade out
          particle.userData.life -= delta * 0.5;
          particle.material.opacity = particle.userData.life * 0.8;
          particle.scale.setScalar(0.5 + particle.userData.life * 0.5);

          // Remove dead particles
          if (particle.userData.life <= 0) {
            this.scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
            this.thoughtParticles.splice(i, 1);
          }
        }
      }

      triggerQuantumBurst(catModel) {
        if (!catModel) return;

        // Create burst particles
        for (let i = 0; i < 30; i++) {
          const geometry = new THREE.SphereGeometry(0.05, 6, 6);
          const material = new THREE.MeshBasicMaterial({
            color: 0xc084fc,
            transparent: true,
            opacity: 1
          });
          const particle = new THREE.Mesh(geometry, material);

          particle.position.copy(catModel.position);
          const angle = (i / 30) * Math.PI * 2;
          const speed = 3 + Math.random() * 2;
          particle.userData = {
            velocity: new THREE.Vector3(
              Math.cos(angle) * speed,
              (Math.random() - 0.3) * speed,
              Math.sin(angle) * speed
            ),
            life: 1.0
          };

          this.quantumBurstParticles.push(particle);
          this.scene.add(particle);
        }
      }

      updateQuantumBurst(delta) {
        for (let i = this.quantumBurstParticles.length - 1; i >= 0; i--) {
          const particle = this.quantumBurstParticles[i];

          particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
          particle.userData.velocity.multiplyScalar(0.95); // Slow down
          particle.userData.life -= delta * 2;
          particle.material.opacity = particle.userData.life;

          if (particle.userData.life <= 0) {
            this.scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
            this.quantumBurstParticles.splice(i, 1);
          }
        }
      }

      dispose() {
        if (this.auraParticles) {
          this.scene.remove(this.auraParticles);
          this.auraParticles.geometry.dispose();
          this.auraParticles.material.dispose();
        }
        this.thoughtParticles.forEach(p => {
          this.scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        this.quantumBurstParticles.forEach(p => {
          this.scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        this.thoughtParticles = [];
        this.quantumBurstParticles = [];
        this.initialized = false;
      }
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 5: Event Mapping & Main Controller
    // ==========================================================================

    /**
     * EventAnimationMappings - Maps events to specific animation triggers
     */
    const EventAnimationMappings = {
      // Dream cycle
      'dream_cycle_start': {
        eyeAction: 'half_close',
        spawnThoughts: false,
        auraActivate: true
      },
      'dream_phase_recall': {
        eyeAction: 'dart',
        earTwitch: true
      },
      'dream_phase_associate': {
        whiskerExtend: true
      },
      'dream_phase_reflect': {
        auraPulse: true
      },
      'dream_cycle_end': {
        eyeAction: 'open_wide',
        auraDeactivate: true
      },

      // Seek cycle
      'seek_cycle_start': {
        eyeAction: 'dilate',
        earAlert: true
      },
      'research_start': {
        headTilt: true,
        whiskerExtend: true
      },
      'research_complete': {
        eyeAction: 'satisfied_blink',
        earRelax: true
      },

      // Desire events
      'desire_created': {
        eyeAction: 'brighten',
        earRotateToward: true,
        bodyLean: true
      },
      'desire_fulfilled': {
        eyeAction: 'squint',
        purrActivate: true,
        spawnSuccessParticles: true
      },
      'desire_stuck': {
        earFlatten: true,
        bodyAgitated: true
      },
      'desire_attempt_failed': {
        eyeAction: 'frustrated',
        earTwitch: true,
        bodyShake: true
      },

      // Memory events
      'memories_accessed': {
        whiskerExtendToNodes: true
      },
      'belief_created': {
        earTwitch: true,
        eyeAction: 'brighten'
      },
      'crystal_created': {
        auraPulse: true,
        whiskerGlow: true
      },
      'memory_crystallized': {
        whiskerSparkle: true
      },

      // Quantum events
      'quantum_collapse': {
        eyeAction: 'contract_sharp',
        bodyFreeze: true,
        quantumBurst: true
      },
      'quantum_influence': {
        eyeColorShift: true
      },

      // Coder events
      'coder_invoked': {
        eyeAction: 'focus',
        spawnThoughts: true
      },
      'coder_complete': {
        eyeAction: 'satisfied',
        spawnSuccessParticles: true
      },
      'coder_failed': {
        eyeAction: 'frustrated',
        bodyShake: true
      },

      // System events
      'awakening': {
        eyeAction: 'open_from_dark',
        bodyStretch: true
      },
      'inner_voice': {
        spawnThoughts: true
      },
      'reflection_created': {
        eyeAction: 'contemplative',
        auraPulse: true
      },
      'identity_created': {
        auraPulse: true,
        bodyPostureShift: true
      },
      'identity_evolved': {
        auraPulse: true,
        eyeAction: 'brighten'
      }
    };

    /**
     * CatAnimationController - Main controller orchestrating all animation subsystems
     */
    class CatAnimationController {
      constructor(scene) {
        this.scene = scene;
        this.stateMachine = new CatStateMachine();
        this.eyeController = new EyeController();
        this.earController = new EarController();
        this.bodyController = new BodyPoseController();
        this.whiskerController = new WhiskerController(scene);
        this.particleSystem = new CatParticleSystem(scene);

        this.catModel = null;
        this.eyeMeshes = [];
        this.accessedNodeIds = [];
        this.lastEventTime = 0;
        this.initialized = false;
      }

      initialize(catModel, eyeMeshes) {
        this.catModel = catModel;
        this.eyeMeshes = eyeMeshes;

        if (catModel) {
          this.whiskerController.initialize(catModel.position);
          this.particleSystem.initialize(catModel.position);
          this.initialized = true;
          console.log('Cat Animation Controller initialized');
        }
      }

      trigger(eventType, eventData = {}) {
        // Apply state transition if defined
        const transition = StateTransitions[eventType];
        if (transition) {
          this.stateMachine.transition(transition.to, transition.duration);

          if (transition.returnTo && transition.returnAfter) {
            this.stateMachine.scheduleReturn(transition.returnTo, transition.returnAfter);
          }
        }

        // Apply event-specific animations
        const mapping = EventAnimationMappings[eventType];
        if (mapping) {
          this.applyEventMapping(mapping, eventData);
        }

        // Store accessed nodes for whisker targeting
        if (eventType === 'memories_accessed' && eventData.node_ids) {
          this.accessedNodeIds = eventData.node_ids.slice(0, 12);
        }

        this.lastEventTime = performance.now();
      }

      applyEventMapping(mapping, eventData) {
        // Eye actions
        if (mapping.eyeAction) {
          switch(mapping.eyeAction) {
            case 'half_close':
              this.eyeController.targetDilation = 0.3;
              break;
            case 'dilate':
              this.eyeController.targetDilation = 0.9;
              break;
            case 'satisfied_blink':
            case 'squint':
              this.eyeController.triggerBlink();
              this.eyeController.targetDilation = 0.4;
              break;
            case 'brighten':
              this.eyeController.targetEmissive = 1.2;
              break;
            case 'frustrated':
              this.eyeController.targetEmissive = 0.5;
              break;
            case 'contract_sharp':
              this.eyeController.targetDilation = 0.1;
              break;
            case 'focus':
              this.eyeController.targetDilation = 0.6;
              this.eyeController.targetEmissive = 1.0;
              break;
          }
        }

        // Ear actions
        if (mapping.earTwitch) {
          this.earController.triggerTwitch();
        }
        if (mapping.earAlert) {
          this.earController.targetAlertness = 1.0;
        }
        if (mapping.earRelax) {
          this.earController.targetAlertness = 0.3;
        }
        if (mapping.earFlatten) {
          this.earController.targetAlertness = 0.1;
        }

        // Particle effects
        if (mapping.spawnThoughts && this.catModel) {
          for (let i = 0; i < 3; i++) {
            setTimeout(() => {
              this.particleSystem.spawnThoughtParticle(this.catModel);
            }, i * 200);
          }
        }
        if (mapping.quantumBurst) {
          this.particleSystem.triggerQuantumBurst(this.catModel);
        }
        if (mapping.spawnSuccessParticles && this.catModel) {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              this.particleSystem.spawnThoughtParticle(this.catModel);
            }, i * 100);
          }
        }
      }

      update(elapsed, delta) {
        if (!this.initialized || !this.catModel) return;

        const now = performance.now();
        this.stateMachine.update(now);
        const currentState = this.stateMachine.currentState;

        // Update all controllers
        this.eyeController.update(delta, currentState, this.eyeMeshes);
        this.earController.update(delta, currentState);
        const bodyPose = this.bodyController.update(delta, currentState, elapsed);
        this.whiskerController.update(delta, currentState, this.catModel, this.accessedNodeIds);
        this.particleSystem.update(delta, currentState, this.catModel, elapsed);

        // Apply body pose to cat model
        if (this.catModel) {
          // Breathing + growth from feeding
          this.catModel.scale.y = 2.4 * bodyPose.breathScale * byrdGrowthFactor;
          this.catModel.scale.x = 3 * (1 + (bodyPose.breathScale - 1) * 0.3) * byrdGrowthFactor;
          this.catModel.scale.z = 2.8 * byrdGrowthFactor; // Z also grows

          // Sway and lean
          this.catModel.rotation.y = bodyPose.swayRotation;
          this.catModel.rotation.x = bodyPose.leanAngle;
        }

        // Clear accessed nodes after a delay
        if (this.accessedNodeIds.length > 0 && now - this.lastEventTime > 3000) {
          this.accessedNodeIds = [];
        }
      }

      getCurrentState() {
        return this.stateMachine.currentState;
      }

      dispose() {
        this.whiskerController.dispose();
        this.particleSystem.dispose();
        this.initialized = false;
      }
    }

    // ==========================================================================
    // CAT ANIMATION SYSTEM - Phase 6: Audio Feedback
    // ==========================================================================

    /**
     * CatAudioController - Synthesized audio feedback for events
     */
    class CatAudioController {
      constructor() {
        this.audioContext = null;
        this.enabled = false;
        this.volume = 0.3;
        this.initialized = false;
      }

      initialize() {
        if (this.initialized) return;

        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.initialized = true;
          console.log('Cat Audio Controller initialized');
        } catch (e) {
          console.warn('Web Audio API not available:', e);
        }
      }

      enable() {
        this.enabled = true;
        if (!this.initialized) this.initialize();
        // Resume audio context if suspended (browser autoplay policy)
        if (this.audioContext && this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }
      }

      disable() {
        this.enabled = false;
      }

      playTone(frequency, duration, type = 'sine', fadeOut = true) {
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        gainNode.gain.setValueAtTime(this.volume, this.audioContext.currentTime);

        if (fadeOut) {
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        }

        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      // Event-specific sounds
      playChime() {
        this.playTone(440, 0.3, 'sine');
        setTimeout(() => this.playTone(554, 0.2, 'sine'), 100);
        setTimeout(() => this.playTone(659, 0.4, 'sine'), 200);
      }

      playSuccess() {
        this.playTone(523, 0.15, 'sine');
        setTimeout(() => this.playTone(659, 0.15, 'sine'), 80);
        setTimeout(() => this.playTone(784, 0.3, 'sine'), 160);
      }

      playQuantum() {
        // Ethereal descending tone
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(220, this.audioContext.currentTime + 0.5);

        gainNode.gain.setValueAtTime(this.volume * 0.5, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.5);
      }

      playAlert() {
        this.playTone(880, 0.1, 'triangle');
        setTimeout(() => this.playTone(880, 0.1, 'triangle'), 150);
      }

      playPurr() {
        // Low rumbling purr sound
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const gainNode = this.audioContext.createGain();

        lfo.connect(lfoGain);
        lfoGain.connect(oscillator.frequency);
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);

        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(25, this.audioContext.currentTime);
        lfoGain.gain.setValueAtTime(10, this.audioContext.currentTime);

        gainNode.gain.setValueAtTime(this.volume * 0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 2);

        lfo.start();
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 2);
        lfo.stop(this.audioContext.currentTime + 2);
      }

      playFrustrated() {
        this.playTone(220, 0.2, 'sawtooth');
      }

      // Trigger sound for event
      triggerForEvent(eventType) {
        if (!this.enabled) return;

        switch(eventType) {
          case 'desire_fulfilled':
          case 'coder_complete':
          case 'research_complete':
          case 'feeding_received':
            this.playSuccess();
            break;
          case 'desire_created':
          case 'belief_created':
          case 'awakening':
            this.playChime();
            break;
          case 'quantum_collapse':
            this.playQuantum();
            break;
          case 'desire_stuck':
          case 'desire_attempt_failed':
          case 'coder_failed':
            this.playFrustrated();
            break;
          case 'crystal_created':
          case 'reflection_created':
            this.playAlert();
            break;
        }
      }
    }

    // Global audio controller instance
    let catAudioController = new CatAudioController();

    // ==========================================================================
    // CAT MODEL (Byrd's Ego Form)
    // ==========================================================================
    function loadCatModel() {
      const loader = new GLTFLoader();

      loader.load(
        'models/cat.glb',
        (gltf) => {
          catModel = gltf.scene;

          // Apply black material with golden eyes
          const blackMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.85,
            metalness: 0.05
          });

          const eyeMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.8,
            roughness: 0.2,
            metalness: 0.3
          });

          catModel.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;

              // Check if this might be an eye mesh
              const name = child.name.toLowerCase();
              if (name.includes('eye') && !name.includes('lid')) {
                child.material = eyeMaterial.clone();
                eyeMeshes.push(child);
              } else {
                child.material = blackMaterial.clone();
              }
            }
          });

          // Scale and position at center - chonky cat
          catModel.scale.set(3, 2.4, 2.8); // Larger scale for the mind space
          catModel.position.set(0, -2, 0); // Slightly below center

          // If the model has animations, set up the mixer
          if (gltf.animations && gltf.animations.length > 0) {
            catMixer = new THREE.AnimationMixer(catModel);
            const action = catMixer.clipAction(gltf.animations[0]);
            action.play();
          }

          scene.add(catModel);
          console.log('Cat model loaded in mind space');

          // Initialize Cat Animation Controller
          catAnimationController = new CatAnimationController(scene);
          catAnimationController.initialize(catModel, eyeMeshes);
        },
        (progress) => {
          console.log(`Loading cat: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          console.error('Error loading cat model:', error);
          console.log('Creating procedural cat head as fallback...');
          createProceduralCat();
        }
      );
    }

    // Procedural cat head fallback when GLB model unavailable
    function createProceduralCat() {
      const catGroup = new THREE.Group();

      // Materials
      const blackMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        roughness: 0.85,
        metalness: 0.05
      });

      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4af37,
        emissive: 0xd4af37,
        emissiveIntensity: 0.8,
        roughness: 0.2,
        metalness: 0.3
      });

      const noseMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a1a1a,
        roughness: 0.6
      });

      // Head - slightly squashed sphere
      const headGeom = new THREE.SphereGeometry(1, 32, 24);
      headGeom.scale(1, 0.9, 0.95);
      const head = new THREE.Mesh(headGeom, blackMaterial);
      catGroup.add(head);

      // Ears - cones
      const earGeom = new THREE.ConeGeometry(0.35, 0.7, 4);
      const leftEar = new THREE.Mesh(earGeom, blackMaterial);
      leftEar.position.set(-0.5, 0.75, 0);
      leftEar.rotation.z = 0.3;
      leftEar.rotation.x = 0.1;
      catGroup.add(leftEar);

      const rightEar = new THREE.Mesh(earGeom, blackMaterial);
      rightEar.position.set(0.5, 0.75, 0);
      rightEar.rotation.z = -0.3;
      rightEar.rotation.x = 0.1;
      catGroup.add(rightEar);

      // Inner ears (pink)
      const innerEarGeom = new THREE.ConeGeometry(0.2, 0.4, 4);
      const innerEarMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2020, emissive: 0x1a0505, emissiveIntensity: 0.3 });
      const leftInnerEar = new THREE.Mesh(innerEarGeom, innerEarMaterial);
      leftInnerEar.position.set(-0.5, 0.7, 0.1);
      leftInnerEar.rotation.z = 0.3;
      leftInnerEar.rotation.x = 0.2;
      catGroup.add(leftInnerEar);

      const rightInnerEar = new THREE.Mesh(innerEarGeom, innerEarMaterial);
      rightInnerEar.position.set(0.5, 0.7, 0.1);
      rightInnerEar.rotation.z = -0.3;
      rightInnerEar.rotation.x = 0.2;
      catGroup.add(rightInnerEar);

      // Eyes - glowing golden spheres
      const eyeGeom = new THREE.SphereGeometry(0.18, 16, 16);
      const leftEye = new THREE.Mesh(eyeGeom, eyeMaterial);
      leftEye.position.set(-0.35, 0.1, 0.8);
      leftEye.name = 'leftEye';
      catGroup.add(leftEye);
      eyeMeshes.push(leftEye);

      const rightEye = new THREE.Mesh(eyeGeom, eyeMaterial);
      rightEye.position.set(0.35, 0.1, 0.8);
      rightEye.name = 'rightEye';
      catGroup.add(rightEye);
      eyeMeshes.push(rightEye);

      // Pupils
      const pupilGeom = new THREE.SphereGeometry(0.08, 12, 12);
      const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const leftPupil = new THREE.Mesh(pupilGeom, pupilMaterial);
      leftPupil.position.set(-0.35, 0.1, 0.95);
      catGroup.add(leftPupil);

      const rightPupil = new THREE.Mesh(pupilGeom, pupilMaterial);
      rightPupil.position.set(0.35, 0.1, 0.95);
      catGroup.add(rightPupil);

      // Nose - small triangle
      const noseGeom = new THREE.ConeGeometry(0.1, 0.15, 3);
      const nose = new THREE.Mesh(noseGeom, noseMaterial);
      nose.position.set(0, -0.15, 0.9);
      nose.rotation.x = Math.PI;
      catGroup.add(nose);

      // Muzzle bumps
      const muzzleGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const leftMuzzle = new THREE.Mesh(muzzleGeom, blackMaterial);
      leftMuzzle.position.set(-0.15, -0.25, 0.75);
      leftMuzzle.scale.set(1, 0.7, 0.8);
      catGroup.add(leftMuzzle);

      const rightMuzzle = new THREE.Mesh(muzzleGeom, blackMaterial);
      rightMuzzle.position.set(0.15, -0.25, 0.75);
      rightMuzzle.scale.set(1, 0.7, 0.8);
      catGroup.add(rightMuzzle);

      // Position and scale the whole cat
      catGroup.scale.set(3, 2.4, 2.8);
      catGroup.position.set(0, -2, 0);

      // Assign to global catModel
      catModel = catGroup;
      scene.add(catModel);
      console.log('Procedural cat head created');

      // Initialize animation controller
      catAnimationController = new CatAnimationController(scene);
      catAnimationController.initialize(catModel, eyeMeshes);
    }

    function animateCat(elapsed, delta) {
      if (!catModel) return;

      // Update animation mixer (for any built-in animations)
      if (catMixer) {
        catMixer.update(delta);
      }

      // Use advanced animation controller if initialized
      if (catAnimationController && catAnimationController.initialized) {
        catAnimationController.update(elapsed, delta);
      } else {
        // Fallback to basic animation if controller not ready
        const breathSpeed = 0.4;
        const breathAmount = 0.03;
        catBreathPhase = Math.sin(elapsed * breathSpeed * Math.PI * 2);

        catModel.scale.y = (2.4 + catBreathPhase * breathAmount) * byrdGrowthFactor;
        catModel.scale.x = (3 + catBreathPhase * breathAmount * 0.3) * byrdGrowthFactor;
        catModel.scale.z = 2.8 * byrdGrowthFactor;

        catIdlePhase = elapsed * 0.2;
        catModel.rotation.y = Math.sin(catIdlePhase) * 0.03;

        const glowPulse = 0.6 + Math.sin(elapsed * 0.5) * 0.3;
        eyeMeshes.forEach(eye => {
          if (eye.material && eye.material.emissiveIntensity !== undefined) {
            eye.material.emissiveIntensity = glowPulse;
          }
        });
      }
    }

    // ==========================================================================
    // ENVIRONMENT
    // ==========================================================================
    function createStarField() {
      const starCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);

      for (let i = 0; i < starCount; i++) {
        // Distribute stars in a sphere
        const radius = 150 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);

        // Subtle color variation
        const colorChoice = Math.random();
        if (colorChoice < 0.7) {
          colors[i * 3] = 0.8;
          colors[i * 3 + 1] = 0.8;
          colors[i * 3 + 2] = 1.0;
        } else if (colorChoice < 0.9) {
          colors[i * 3] = 1.0;
          colors[i * 3 + 1] = 0.9;
          colors[i * 3 + 2] = 0.8;
        } else {
          colors[i * 3] = 0.6;
          colors[i * 3 + 1] = 0.7;
          colors[i * 3 + 2] = 1.0;
        }

        sizes[i] = 0.5 + Math.random() * 1.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 1,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
      });

      starField = new THREE.Points(geometry, material);
      scene.add(starField);
    }

    function createAmbientParticles() {
      // Disabled - ambient particles were cluttering the visualization
      // Keep function stub for compatibility
      return;
    }

    // ==========================================================================
    // CONSCIOUSNESS CORE (Disabled - awakening node is now the center)
    // ==========================================================================
    function createConsciousnessCore() {
      // Disabled - the awakening dodecahedron now serves as the central consciousness
      // Store empty refs for compatibility
      consciousnessCore = null;
      coreGlow = null;
      scene.userData.outerSphere = null;
      scene.userData.middleSphere = null;
    }

    function createCoreParticleRing() {
      // Minimal particle ring for light theme
      const particleCount = 30;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const radius = 8 + Math.random() * 1;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        size: 0.15,
        color: 0x94a3b8,
        transparent: true,
        opacity: 0.4,
        sizeAttenuation: true
      });

      coreParticles = new THREE.Points(geometry, material);
      scene.add(coreParticles);
    }

    // ==========================================================================
    // GRAVITATIONAL SPIRAL - Sacred Geometry Node System
    // ==========================================================================

    // Calculate position based on connectivity (more connections = closer to center)
    function calculateNodePosition(nodeId, nodeIndex) {
      const connections = connectionCounts.get(nodeId) || 0;

      // Radial distance: more connections = closer to center
      // Using inverse relationship: radius = MAX / (connections + 1)
      const normalizedConnections = Math.min(connections, 20); // Cap for calculation
      const radius = MIN_RADIUS + (MAX_RADIUS - MIN_RADIUS) * Math.pow(0.85, normalizedConnections);

      // Angular position using golden angle for even distribution
      const angle = nodeIndex * GOLDEN_ANGLE;

      // Height variation based on golden angle for 3D spiral
      const heightAngle = nodeIndex * GOLDEN_ANGLE * 0.3;
      const height = Math.sin(heightAngle) * radius * 0.4;

      return {
        x: Math.cos(angle) * radius,
        y: height,
        z: Math.sin(angle) * radius
      };
    }

    // Recalculate all node positions based on current connection counts
    function recalculateAllPositions() {
      nodes3D.forEach((mesh, index) => {
        const pos = calculateNodePosition(mesh.userData.id, index);
        mesh.userData.targetPosition.set(pos.x, pos.y, pos.z);
      });
    }

    // Increment connection count for a node and update its scale
    function incrementConnectionCount(nodeId) {
      const current = connectionCounts.get(nodeId) || 0;
      connectionCounts.set(nodeId, current + 1);
      updateNodeScaleByConnections(nodeId);
    }

    // EMERGENT STRUCTURE: Node size, color, and position determined by connection weight
    function updateNodeScaleByConnections(nodeId) {
      const node = nodes3D.find(n => n.userData.id === nodeId);
      if (!node) return;

      const connections = connectionCounts.get(nodeId) || 0;
      const baseScale = node.userData.baseScale || 1;

      // Size scales dramatically with connections (emergent importance)
      // Highly connected nodes become larger - they're central/important
      // Isolated nodes stay small - they're peripheral
      // 0 conn: 1x, 5 conn: ~2.1x, 10 conn: ~2.6x, 20 conn: ~3.1x
      const growthFactor = 1 + Math.log(1 + connections) * 0.7;
      const newScale = baseScale * growthFactor;

      // Also update opacity - more connected = more solid presence
      if (node.material) {
        const targetOpacity = Math.min(1.0, 0.5 + connections * 0.05);
        node.material.opacity = targetOpacity;

        // DARKEN color with more connections
        // 0 connections = full brightness (1.0)
        // 20+ connections = darkened to 30% brightness
        const darkenFactor = Math.max(0.3, 1.0 - (connections * 0.035));

        // Get base color and darken it
        if (node.userData.baseColor) {
          const baseColor = new THREE.Color(node.userData.baseColor);
          const darkenedColor = baseColor.clone().multiplyScalar(darkenFactor);
          node.material.color.copy(darkenedColor);
        }

        // Also darken emissive for consistency (only for materials that support it)
        if (node.userData.baseEmissive && node.material.emissive) {
          const baseEmissive = new THREE.Color(node.userData.baseEmissive);
          const darkenedEmissive = baseEmissive.clone().multiplyScalar(darkenFactor);
          node.material.emissive.copy(darkenedEmissive);
        }
      }

      // Animate the scale change smoothly
      const targetScale = new THREE.Vector3(newScale, newScale, newScale);
      node.userData.targetScale = targetScale;

      // MOVE toward center with more connections (mild effect to avoid overcrowding)
      // Calculate target position closer to center based on connection count
      const normalizedConnections = Math.min(connections, 20);
      // Gentle decay (0.97) keeps nodes spread out; MIN 30 prevents center crowding
      const minRadius = 30;  // Don't get closer than this
      const targetRadius = minRadius + (MAX_RADIUS - minRadius) * Math.pow(0.97, normalizedConnections);

      // Get current angle/direction from center
      const currentDistance = node.position.length();
      if (currentDistance > 0.1) {
        const direction = node.position.clone().normalize();
        const targetPosition = direction.multiplyScalar(targetRadius);
        node.userData.targetPosition = targetPosition;
      }
    }

    // Animate node scales and positions in the main loop
    function updateNodeScales(delta) {
      nodes3D.forEach(node => {
        // Animate scale
        if (node.userData.targetScale) {
          node.scale.lerp(node.userData.targetScale, 0.1);
        }
        // Animate position toward center based on connections
        if (node.userData.targetPosition) {
          node.position.lerp(node.userData.targetPosition, 0.02); // Slow, smooth movement
        }
      });
    }

    function createNode3D(type, content, id, importance = 0.5) {
      const nodeId = id || `node_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      // Prevent duplicate nodes - check if node with this ID already exists
      const existingNode = nodes3D.find(n => n.userData.id === nodeId);
      if (existingNode) {
        return existingNode; // Return existing node instead of creating duplicate
      }

      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      // Initialize connection count
      connectionCounts.set(nodeId, 0);

      // Spawn on outer shell - physics will pull toward center based on connections
      const nodeIndex = nodes3D.length;
      const spawnRadius = PHYSICS.maxRadius * 0.85;

      // Use Fibonacci sphere distribution for even spawning
      const phi = Math.acos(1 - 2 * ((nodeIndex % 100) + 0.5) / 100);
      const theta = Math.PI * (1 + Math.sqrt(5)) * nodeIndex; // Golden angle

      // Add some randomness to prevent perfect patterns initially
      const randomOffset = 0.3;
      const pos = {
        x: spawnRadius * Math.sin(phi) * Math.cos(theta) + (Math.random() - 0.5) * spawnRadius * randomOffset,
        y: spawnRadius * Math.sin(phi) * Math.sin(theta) * 0.6 + (Math.random() - 0.5) * spawnRadius * randomOffset,
        z: spawnRadius * Math.cos(phi) + (Math.random() - 0.5) * spawnRadius * randomOffset
      };

      // Smaller, more uniform nodes - the geometry is in the connections
      const size = 0.8 + importance * 0.6;

      // Simpler geometry - small spheres for all types, color differentiates
      let geometry;
      switch (type) {
        case 'belief':
          geometry = new THREE.IcosahedronGeometry(size, 1);
          break;
        case 'desire':
          geometry = new THREE.OctahedronGeometry(size, 0);
          break;
        case 'reflection':
          geometry = new THREE.TetrahedronGeometry(size, 0);
          break;
        case 'capability':
          geometry = new THREE.BoxGeometry(size, size, size);
          break;
        case 'awakening':
          geometry = new THREE.DodecahedronGeometry(size, 0);
          break;
        case 'identity':
          // Identity nodes use icosahedron - 20 faces, represents multifaceted identity
          geometry = new THREE.IcosahedronGeometry(size, 0);
          break;
        case 'crystal':
          // Crystal nodes - larger icosahedron, represents unified crystallized memories
          // Size scales with node_count (stored in importance)
          const crystalSize = size * 1.5;
          geometry = new THREE.IcosahedronGeometry(crystalSize, 1);
          break;
        case 'operatingsystem':
          // Operating System - don't create a separate cat head, use the main catModel
          // Just store the node data on catModel (which already exists as BYRD's representation)
          if (catModel) {
            catModel.userData = {
              ...catModel.userData,
              id: nodeId,
              type,
              content,
              importance: 1.0,
              nodeIndex,
              isOSNode: true
            };
            osNodeGroup = catModel; // Use catModel as the OS node
            nodes3D.push(catModel);
            connectionCounts.set(nodeId, 0);
            return catModel;
          }
          // Fallback if catModel not loaded yet - create invisible marker
          const osMarker = new THREE.Group();
          osMarker.position.set(0, -2, 0);
          osMarker.userData = {
            id: nodeId,
            type,
            content,
            importance: 1.0,
            nodeIndex,
            isOSNode: true,
            velocity: new THREE.Vector3(0, 0, 0),
            force: new THREE.Vector3(0, 0, 0)
          };
          osNodeGroup = osMarker;
          nodes3D.push(osMarker);
          connectionCounts.set(nodeId, 0);
          return osMarker; // Invisible marker, catModel handles visual
        case 'seed':
          // Seeds are small polyhedra - foundational, stable
          geometry = new THREE.DodecahedronGeometry(size * 0.6, 0);
          break;
        case 'constraint':
          // Constraints are octahedra - pointed, defining limits
          geometry = new THREE.OctahedronGeometry(size * 0.6, 0);
          break;
        case 'strategy':
          // Strategies are tetrahedra - directional, pointing the way
          geometry = new THREE.TetrahedronGeometry(size * 0.7, 0);
          break;
        default: // experience
          geometry = new THREE.SphereGeometry(size * 0.8, 16, 16);
      }

      // Clean material - subtle, lets connections be the star
      const material = new THREE.MeshBasicMaterial({
        color: colors.color,
        transparent: true,
        opacity: 0.85
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(pos.x, pos.y, pos.z);

      // Initial velocity: gentle drift toward center
      const initialVelocity = new THREE.Vector3(-pos.x, -pos.y, -pos.z)
        .normalize()
        .multiplyScalar(0.3 + Math.random() * 0.2);

      mesh.userData = {
        id: nodeId,
        type,
        content,
        importance,
        nodeIndex,
        baseScale: 1,  // Base scale for connection-based growth
        baseColor: colors.color,      // Store original color for darkening
        baseEmissive: colors.emissive || colors.color,  // Store original emissive
        createdAt: Date.now(),
        targetScale: new THREE.Vector3(1, 1, 1),
        velocity: initialVelocity,
        force: new THREE.Vector3(0, 0, 0)
      };

      scene.add(mesh);
      nodes3D.push(mesh);

      // NOTE: Connections are NOT created automatically here.
      // They are only created from actual database relationships via loadExistingGraph.
      // This ensures the visualization accurately reflects the database state.

      // Pulse the core
      pulseCore(type, importance);

      // Limit nodes
      if (nodes3D.length > 80) {
        const oldNode = nodes3D.shift();
        fadeOutAndRemove(oldNode);
        connectionCounts.delete(oldNode.userData.id);
      }

      // Update counts to reflect actual rendered nodes
      updateRenderedCounts();

      return mesh;
    }

    // ==========================================================================
    // SACRED GEOMETRY CONNECTION SYSTEM - Straight Lines
    // ==========================================================================
    const LINE_CONFIG = {
      baseOpacity: 0.4,
      highlightOpacity: 0.8,
      lineWidth: 1,  // Note: WebGL line width is often limited to 1
      highlightDuration: 500
    };

    function createConnection3D(nodeA, nodeB, type) {
      // Increment connection counts for both nodes
      incrementConnectionCount(nodeA.userData.id);
      incrementConnectionCount(nodeB.userData.id);

      // Create simple straight line geometry
      const points = [
        nodeA.position.clone(),
        nodeB.position.clone()
      ];

      const geometry = new THREE.BufferGeometry().setFromPoints(points);

      // Clean white/gold line material
      const material = new THREE.LineBasicMaterial({
        color: 0xd4af37, // Gold for sacred geometry feel
        transparent: true,
        opacity: LINE_CONFIG.baseOpacity,
        linewidth: LINE_CONFIG.lineWidth
      });

      const line = new THREE.Line(geometry, material);
      line.userData = {
        nodeA: nodeA.userData.id,
        nodeB: nodeB.userData.id,
        meshA: nodeA,
        meshB: nodeB,
        type,
        baseOpacity: LINE_CONFIG.baseOpacity
      };

      scene.add(line);
      connections3D.push(line);

      invalidateConnectionMap();

      // Limit connections
      if (connections3D.length > 150) {
        const oldConn = connections3D.shift();
        removeConnection(oldConn);
      }

      // Brief highlight on creation
      highlightConnection(line);

      return line;
    }

    function highlightConnection(connection, duration = LINE_CONFIG.highlightDuration) {
      if (!connection || !connection.material) return;

      const originalOpacity = connection.userData.baseOpacity;
      connection.material.opacity = LINE_CONFIG.highlightOpacity;
      connection.material.color.setHex(0xffffff); // White flash

      setTimeout(() => {
        if (connection.material) {
          connection.material.opacity = originalOpacity;
          connection.material.color.setHex(0xd4af37); // Back to gold
        }
      }, duration);
    }

    function removeConnection(connection) {
      scene.remove(connection);
      if (connection.geometry) connection.geometry.dispose();
      if (connection.material) connection.material.dispose();
    }

    // Create connection by node IDs (wrapper for event handler)
    function createConnection(fromId, toId, type) {
      const nodeA = nodes3D.find(n => n.userData.id === fromId);
      const nodeB = nodes3D.find(n => n.userData.id === toId);

      if (nodeA && nodeB) {
        return createConnection3D(nodeA, nodeB, type);
      } else {
        // Nodes not yet in visualization - queue for later
        console.log(`Connection deferred: ${fromId} -> ${toId} (nodes not found)`);
        return null;
      }
    }

    // Update connection positions when nodes move
    function updateConnectionPositions() {
      connections3D.forEach(conn => {
        if (!conn.userData.meshA || !conn.userData.meshB) return;

        const positions = conn.geometry.attributes.position;
        if (!positions) return;

        // Update start point
        positions.setXYZ(0,
          conn.userData.meshA.position.x,
          conn.userData.meshA.position.y,
          conn.userData.meshA.position.z
        );

        // Update end point
        positions.setXYZ(1,
          conn.userData.meshB.position.x,
          conn.userData.meshB.position.y,
          conn.userData.meshB.position.z
        );

        positions.needsUpdate = true;
      });
    }

    // Cascade effect - highlight connected nodes
    function triggerCascade(nodeId, intensity = 0.5) {
      const relatedConnections = connections3D.filter(
        conn => conn.userData.nodeA === nodeId || conn.userData.nodeB === nodeId
      );

      relatedConnections.forEach((conn, index) => {
        setTimeout(() => {
          highlightConnection(conn, 300);
        }, index * 50);
      });
    }

    // No ambient activity needed for sacred geometry - stillness is powerful

    function pulseCore(type, intensity) {
      const colors = NODE_COLORS[type] || { emissive: 0x8b5cf6 };

      // Flash the core
      if (consciousnessCore) {
        const originalIntensity = consciousnessCore.material.emissiveIntensity;
        consciousnessCore.material.emissiveIntensity = 1.5 * intensity;
        consciousnessCore.material.emissive.setHex(colors.emissive);

        setTimeout(() => {
          consciousnessCore.material.emissiveIntensity = originalIntensity;
          consciousnessCore.material.emissive.setHex(0x8b5cf6);
        }, 300);
      }

      // Expand core briefly
      if (coreGlow) {
        const originalScale = coreGlow.scale.x;
        coreGlow.scale.setScalar(2 * intensity);
        setTimeout(() => {
          coreGlow.scale.setScalar(originalScale);
        }, 200);
      }
    }

    // ==========================================================================
    // PHYSICS / ANIMATION (Force-Directed Sacred Geometry System)
    // ==========================================================================

    // Physics constants for force-directed graph with sacred geometry emergence
    // Tuned for ~5% vibration: very gentle forces for calm, meditative visualization
    const PHYSICS = {
      // Repulsion: all nodes push each other apart (inverse square)
      repulsion: 2,             // Very gentle repulsion
      repulsionCutoff: 40,      // Shorter cutoff to reduce force accumulation

      // Springs: connected nodes attract each other
      spring: 0.0015,           // Subtle but noticeable attraction between connected nodes
      springLength: 12,         // Connected nodes want to be closer than unconnected ones

      // Center gravity: connection-weighted pull toward center
      gravity: 0.0001,          // Very gentle gravity
      gravityPerConnection: 0.00005, // Very subtle connection bonus

      // Damping and limits (tuned for ~5% vibration with connection weighting)
      baseDamping: 0.92,        // Strong damping for very calm base
      dampingPerConnection: 0.008, // More damping reduction per connection (more connections = more vibration)
      minDamping: 0.75,         // Allow highly connected nodes to be noticeably more active
      maxVelocity: 0.08,        // Very low max velocity for subtle movement
      minDistance: 4,           // Minimum distance between nodes

      // Boundary
      maxRadius: 90,            // Soft boundary - nodes pushed back if beyond
      boundaryForce: 0.0005     // Very gentle boundary
    };

    // Settling physics - faster movement on initial load
    const SETTLING_PHYSICS = {
      repulsion: 50,            // Strong repulsion for quick separation
      repulsionCutoff: 60,
      spring: 0.02,             // Stronger spring for quick clustering during settling
      springLength: 12,         // Same target as calm physics
      gravity: 0.008,           // Strong gravity to pull nodes in quickly
      gravityPerConnection: 0.004,
      baseDamping: 0.85,        // Less damping = faster movement
      dampingPerConnection: 0.008,
      minDamping: 0.7,
      maxVelocity: 2.0,         // Allow fast movement during settling
      minDistance: 4,
      maxRadius: 90,
      boundaryForce: 0.02
    };

    // Settling mode state
    let isSettling = true;
    let settlingStartTime = Date.now();
    const SETTLING_DURATION = 3000; // 3 seconds of fast settling

    function getActivePhysics() {
      if (isSettling && Date.now() - settlingStartTime < SETTLING_DURATION) {
        // Gradually transition from settling to calm physics
        const progress = (Date.now() - settlingStartTime) / SETTLING_DURATION;
        const t = Math.min(1, progress);
        // Use settling physics with gradual transition
        return {
          repulsion: SETTLING_PHYSICS.repulsion * (1 - t) + PHYSICS.repulsion * t,
          repulsionCutoff: SETTLING_PHYSICS.repulsionCutoff,
          spring: SETTLING_PHYSICS.spring * (1 - t) + PHYSICS.spring * t,
          springLength: PHYSICS.springLength,
          gravity: SETTLING_PHYSICS.gravity * (1 - t) + PHYSICS.gravity * t,
          gravityPerConnection: SETTLING_PHYSICS.gravityPerConnection * (1 - t) + PHYSICS.gravityPerConnection * t,
          baseDamping: SETTLING_PHYSICS.baseDamping * (1 - t) + PHYSICS.baseDamping * t,
          dampingPerConnection: PHYSICS.dampingPerConnection,
          minDamping: SETTLING_PHYSICS.minDamping * (1 - t) + PHYSICS.minDamping * t,
          maxVelocity: SETTLING_PHYSICS.maxVelocity * (1 - t) + PHYSICS.maxVelocity * t,
          minDistance: PHYSICS.minDistance,
          maxRadius: PHYSICS.maxRadius,
          boundaryForce: SETTLING_PHYSICS.boundaryForce * (1 - t) + PHYSICS.boundaryForce * t
        };
      }
      isSettling = false;
      return PHYSICS;
    }

    // Golden ratio for sacred geometry spacing
    const PHI = (1 + Math.sqrt(5)) / 2; // ~1.618

    // Phase 4: Performance optimizations
    let cachedConnectionMap = null;
    let connectionMapDirty = true;
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();

    // Mark connection map dirty when connections change
    function invalidateConnectionMap() {
      connectionMapDirty = true;
    }

    // Build connection lookup for O(1) access (cached)
    function buildConnectionMap() {
      if (!connectionMapDirty && cachedConnectionMap) {
        return cachedConnectionMap;
      }

      const map = new Map();
      for (const conn of connections3D) {
        const a = conn.userData.nodeA;
        const b = conn.userData.nodeB;
        if (!map.has(a)) map.set(a, new Set());
        if (!map.has(b)) map.set(b, new Set());
        map.get(a).add(b);
        map.get(b).add(a);
      }

      cachedConnectionMap = map;
      connectionMapDirty = false;
      return map;
    }

    // Phase 4: Frustum culling check
    function updateFrustum() {
      projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(projScreenMatrix);
    }

    function isInFrustum(object) {
      return frustum.containsPoint(object.position);
    }

    // Phase 4: Distance-based detail level
    function getDetailLevel(node) {
      const distance = camera.position.distanceTo(node.position);
      if (distance < 30) return 'high';
      if (distance < 60) return 'medium';
      return 'low';
    }

    // ==========================================================================
    // FORCE-DIRECTED PHYSICS HELPERS
    // ==========================================================================

    // Temporary vectors for calculations (reused to avoid GC)
    const _tempVec = new THREE.Vector3();
    const _forceVec = new THREE.Vector3();

    // Apply repulsion force between two nodes (inverse square law)
    function applyRepulsion(nodeA, nodeB, physics) {
      _tempVec.subVectors(nodeA.position, nodeB.position);
      const distance = _tempVec.length();

      // Skip if too far apart (optimization)
      if (distance > physics.repulsionCutoff) return;

      // Prevent division by zero and extreme forces at close range
      const clampedDist = Math.max(distance, physics.minDistance);

      // Inverse square repulsion: F = k / d¬≤
      const forceMagnitude = physics.repulsion / (clampedDist * clampedDist);

      // Normalize and scale
      _tempVec.normalize().multiplyScalar(forceMagnitude);

      // Apply equal and opposite forces
      nodeA.userData.force.add(_tempVec);
      nodeB.userData.force.sub(_tempVec);
    }

    // Apply spring force between connected nodes (Hooke's law)
    function applySpring(nodeA, nodeB, physics) {
      _tempVec.subVectors(nodeB.position, nodeA.position);
      const distance = _tempVec.length();

      // Displacement from rest length
      const displacement = distance - physics.springLength;

      // Spring force: F = k * x
      const forceMagnitude = physics.spring * displacement;

      // Normalize and scale
      _tempVec.normalize().multiplyScalar(forceMagnitude);

      // Apply to both nodes (toward each other if stretched, away if compressed)
      nodeA.userData.force.add(_tempVec);
      nodeB.userData.force.sub(_tempVec);
    }

    // Apply center gravity (connection-weighted)
    function applyCenterGravity(node, physics) {
      const connections = connectionCounts.get(node.userData.id) || 0;

      // More connections = stronger pull toward center
      const gravityStrength = physics.gravity + (connections * physics.gravityPerConnection);

      // Direction toward center (0,0,0)
      _tempVec.copy(node.position).negate().normalize();

      // Distance from center affects force slightly (further = stronger pull)
      const distance = node.position.length();
      const distanceFactor = Math.min(distance / 30, 2); // Cap at 2x

      _tempVec.multiplyScalar(gravityStrength * distanceFactor);
      node.userData.force.add(_tempVec);
    }

    // Apply soft boundary (push back if too far from center)
    function applyBoundary(node, physics) {
      const distance = node.position.length();

      if (distance > physics.maxRadius) {
        // Push back toward center
        const overshoot = distance - physics.maxRadius;
        _tempVec.copy(node.position).negate().normalize();
        _tempVec.multiplyScalar(overshoot * physics.boundaryForce);
        node.userData.force.add(_tempVec);
      }
    }

    // ==========================================================================
    // MAIN PHYSICS UPDATE LOOP
    // ==========================================================================

    function updateNodePhysics(delta) {
      if (nodes3D.length === 0) return;

      // Skip physics in graph mode - nodes should be static
      if (graphState.mode === 'graph') return;

      // Get active physics (transitions from settling to calm over time)
      const physics = getActivePhysics();

      // Clamp delta to prevent instability on lag spikes
      const dt = Math.min(delta, 0.05);

      // Build connection map for damping calculation
      const connectionMap = buildConnectionMap();

      // 1. Reset forces for all nodes
      for (const node of nodes3D) {
        if (!node.userData.force) {
          node.userData.force = new THREE.Vector3();
        }
        if (!node.userData.velocity) {
          node.userData.velocity = new THREE.Vector3();
        }
        node.userData.force.set(0, 0, 0);
      }

      // 2. Calculate repulsion forces (O(n¬≤) but with distance cutoff)
      for (let i = 0; i < nodes3D.length; i++) {
        for (let j = i + 1; j < nodes3D.length; j++) {
          applyRepulsion(nodes3D[i], nodes3D[j], physics);
        }
      }

      // 3. Calculate spring forces for connected nodes
      for (const connection of connections3D) {
        const nodeA = nodes3D.find(n => n.userData.id === connection.userData.nodeA);
        const nodeB = nodes3D.find(n => n.userData.id === connection.userData.nodeB);
        if (nodeA && nodeB) {
          applySpring(nodeA, nodeB, physics);
        }
      }

      // 4. Apply center gravity and boundary forces
      for (const node of nodes3D) {
        applyCenterGravity(node, physics);
        applyBoundary(node, physics);
      }

      // 5. Integrate forces into velocity and position
      for (const node of nodes3D) {
        // OS node is anchored at center - skip physics
        if (node.userData.isOSNode) continue;

        // F = ma, assume m=1, so a = F
        // Scale force by delta for frame-rate independence
        _forceVec.copy(node.userData.force).multiplyScalar(dt * 60);
        node.userData.velocity.add(_forceVec);

        // Apply connection-weighted damping
        // More connections = less damping = more vibration
        const nodeConnections = connectionMap.get(node.userData.id);
        const connectionCount = nodeConnections ? nodeConnections.size : 0;
        const damping = Math.max(
          physics.minDamping,
          physics.baseDamping - (connectionCount * physics.dampingPerConnection)
        );
        node.userData.velocity.multiplyScalar(damping);

        // Clamp velocity
        const speed = node.userData.velocity.length();
        if (speed > physics.maxVelocity) {
          node.userData.velocity.multiplyScalar(physics.maxVelocity / speed);
        }

        // Update position
        _tempVec.copy(node.userData.velocity).multiplyScalar(dt * 60);
        node.position.add(_tempVec);
      }
    }

    function animateCore(time) {
      if (consciousnessCore) {
        // Breathing scale
        const breatheSpeed = currentPhase === 'idle' ? 0.5 : 1.5;
        const breatheAmount = currentPhase === 'idle' ? 0.05 : 0.15;
        const scale = 1 + Math.sin(time * breatheSpeed) * breatheAmount;
        consciousnessCore.scale.setScalar(scale);
      }

      if (coreGlow) {
        const glowScale = 1 + Math.sin(time * 2) * 0.1;
        coreGlow.scale.setScalar(glowScale);
      }

      if (coreParticles) {
        coreParticles.rotation.y = time * 0.2;
        coreParticles.rotation.x = Math.sin(time * 0.3) * 0.1;
      }

      const outerSphere = scene.userData.outerSphere;
      const middleSphere = scene.userData.middleSphere;

      if (outerSphere) {
        const outerScale = 1 + Math.sin(time * 0.4) * 0.08;
        outerSphere.scale.setScalar(outerScale);
        outerSphere.material.opacity = 0.08 + Math.sin(time * 0.5) * 0.04;
      }

      if (middleSphere) {
        const middleScale = 1 + Math.sin(time * 0.6 + 0.5) * 0.06;
        middleSphere.scale.setScalar(middleScale);
      }
    }

    function animateAmbientParticles(delta) {
      const particles = scene.userData.ambientParticles;
      if (!particles) return;

      const positions = particles.geometry.attributes.position.array;
      const velocities = particles.userData.velocities;

      for (let i = 0; i < velocities.length; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;
        positions[i * 3 + 2] += velocities[i].z;

        // Wrap around
        if (Math.abs(positions[i * 3]) > 50) velocities[i].x *= -1;
        if (Math.abs(positions[i * 3 + 1]) > 50) velocities[i].y *= -1;
        if (Math.abs(positions[i * 3 + 2]) > 50) velocities[i].z *= -1;
      }

      particles.geometry.attributes.position.needsUpdate = true;
    }

    // ==========================================================================
    // FLOW PARTICLES (Phase 2: Energy flowing through connections)
    // ==========================================================================
    const flowParticles = [];
    const MAX_FLOW_PARTICLES = 50;
    const FLOW_SPEED = 0.8;

    function createFlowParticle(connection) {
      if (!connection.userData.curve) return null;

      const geometry = new THREE.SphereGeometry(0.15, 8, 8);
      const type = connection.userData.type;
      const colors = NODE_COLORS[type] || NODE_COLORS.experience;

      const material = new THREE.MeshBasicMaterial({
        color: colors.emissive,
        transparent: true,
        opacity: 0.9
      });

      const particle = new THREE.Mesh(geometry, material);
      particle.userData = {
        connection: connection,
        progress: 0,               // 0 to 1 along curve
        speed: FLOW_SPEED + Math.random() * 0.3,
        direction: Math.random() > 0.5 ? 1 : -1
      };

      // Start at random position along curve
      particle.userData.progress = Math.random();

      scene.add(particle);
      flowParticles.push(particle);

      return particle;
    }

    function updateFlowParticles(delta) {
      // Spawn new particles on random connections
      if (flowParticles.length < MAX_FLOW_PARTICLES && connections3D.length > 0) {
        if (Math.random() < 0.03) { // 3% chance per frame
          const conn = connections3D[Math.floor(Math.random() * connections3D.length)];
          createFlowParticle(conn);
        }
      }

      // Update existing particles
      for (let i = flowParticles.length - 1; i >= 0; i--) {
        const particle = flowParticles[i];
        const data = particle.userData;
        const curve = data.connection.userData.curve;

        if (!curve) {
          // Connection was removed, remove particle
          scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          flowParticles.splice(i, 1);
          continue;
        }

        // Move along curve
        data.progress += delta * data.speed * data.direction;

        // Wrap around or remove at ends
        if (data.progress > 1) {
          data.progress = 0;
          data.direction = 1;
        } else if (data.progress < 0) {
          data.progress = 1;
          data.direction = -1;
        }

        // Position on curve
        const point = curve.getPoint(data.progress);
        particle.position.copy(point);

        // Pulsing glow effect
        const pulse = 0.7 + Math.sin(performance.now() * 0.01 + i) * 0.3;
        particle.material.opacity = pulse;

        // Scale based on position (larger in middle)
        const scale = 0.8 + Math.sin(data.progress * Math.PI) * 0.4;
        particle.scale.setScalar(scale);
      }
    }

    // ==========================================================================
    // NODE TRAILS (Phase 2: Motion trails during movement)
    // ==========================================================================
    const nodeTrails = new Map(); // nodeId -> trail mesh
    const TRAIL_LENGTH = 8;
    const TRAIL_FADE_RATE = 0.15;

    function updateNodeTrails(delta) {
      for (const node of nodes3D) {
        const velocity = node.userData.velocity;
        const speed = velocity.length();

        // Only show trails for moving nodes
        if (speed < 0.05) {
          // Remove trail if exists and node stopped
          if (nodeTrails.has(node.userData.id)) {
            const trail = nodeTrails.get(node.userData.id);
            trail.userData.fadingOut = true;
          }
          continue;
        }

        let trail = nodeTrails.get(node.userData.id);

        if (!trail) {
          // Create new trail
          const positions = new Float32Array(TRAIL_LENGTH * 3);
          for (let i = 0; i < TRAIL_LENGTH; i++) {
            positions[i * 3] = node.position.x;
            positions[i * 3 + 1] = node.position.y;
            positions[i * 3 + 2] = node.position.z;
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

          const type = node.userData.type;
          const colors = NODE_COLORS[type] || NODE_COLORS.experience;

          const material = new THREE.LineBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.4
          });

          trail = new THREE.Line(geometry, material);
          trail.userData = {
            history: Array(TRAIL_LENGTH).fill().map(() => node.position.clone()),
            fadingOut: false
          };

          scene.add(trail);
          nodeTrails.set(node.userData.id, trail);
        }

        // Update trail history (shift and add current position)
        const history = trail.userData.history;
        history.shift();
        history.push(node.position.clone());

        // Update geometry
        const positions = trail.geometry.attributes.position.array;
        for (let i = 0; i < TRAIL_LENGTH; i++) {
          positions[i * 3] = history[i].x;
          positions[i * 3 + 1] = history[i].y;
          positions[i * 3 + 2] = history[i].z;
        }
        trail.geometry.attributes.position.needsUpdate = true;

        // Opacity based on speed
        trail.material.opacity = Math.min(0.5, speed * 0.8);
      }

      // Fade out and remove orphaned trails
      for (const [nodeId, trail] of nodeTrails) {
        if (trail.userData.fadingOut) {
          trail.material.opacity -= TRAIL_FADE_RATE * delta * 60;
          if (trail.material.opacity <= 0) {
            scene.remove(trail);
            trail.geometry.dispose();
            trail.material.dispose();
            nodeTrails.delete(nodeId);
          }
        }
      }
    }

    // ==========================================================================
    // GRAPH MODE FUNCTIONS (Living Memory Visualization)
    // ==========================================================================

    // Heat map configuration
    const HEAT_MAP_CONFIG = {
        // Color gradient from cool (rarely accessed) to hot (frequently accessed)
        colors: [
            { threshold: 0, color: new THREE.Color(0x3b82f6) },   // Blue - cold (0 accesses)
            { threshold: 2, color: new THREE.Color(0x22c55e) },   // Green - warm (2+ accesses)
            { threshold: 5, color: new THREE.Color(0xeab308) },   // Yellow - warmer (5+ accesses)
            { threshold: 10, color: new THREE.Color(0xf97316) },  // Orange - hot (10+ accesses)
            { threshold: 20, color: new THREE.Color(0xef4444) },  // Red - very hot (20+ accesses)
            { threshold: 50, color: new THREE.Color(0xec4899) }   // Pink/magenta - burning (50+ accesses)
        ],
        // Whether to blend with type color or override completely
        blendWithType: true,
        blendRatio: 0.6  // 60% heat color, 40% type color
    };

    /**
     * Calculate heat color based on access count
     */
    function calculateHeatColor(accessCount, typeColor) {
        // Find the appropriate heat color based on access count
        let heatColor = HEAT_MAP_CONFIG.colors[0].color;
        for (const level of HEAT_MAP_CONFIG.colors) {
            if (accessCount >= level.threshold) {
                heatColor = level.color;
            }
        }

        // Optionally blend with the type color
        if (HEAT_MAP_CONFIG.blendWithType && typeColor) {
            const blended = new THREE.Color(typeColor);
            blended.lerp(heatColor, HEAT_MAP_CONFIG.blendRatio);
            return blended;
        }

        return heatColor;
    }

    /**
     * Get heat intensity (0-1) based on access count
     */
    function getHeatIntensity(accessCount) {
        // Logarithmic scale for intensity
        return Math.min(1, Math.log(1 + accessCount) / Math.log(51));
    }

    /**
     * Update heat colors for nodes after access counts change
     * Called after MEMORIES_ACCESSED event to refresh visual heat
     */
    function updateNodeHeatColors(accessedNodeIds) {
        if (graphState.mode !== 'graph') return;

        for (const nodeId of accessedNodeIds) {
            const mesh = graphState.nodeIdToMesh.get(nodeId);
            if (!mesh) continue;

            // Increment local access count
            const currentCount = (mesh.userData.accessCount || 0) + 1;
            mesh.userData.accessCount = currentCount;

            // Get the node type colors
            const type = mesh.userData.type || 'experience';
            const colors = NODE_COLORS[type] || NODE_COLORS.experience;

            // Recalculate heat color
            const newHeatColor = calculateHeatColor(currentCount, colors.color);
            mesh.material.color.copy(newHeatColor);
            mesh.userData.baseColor = newHeatColor.getHex();

            // Update opacity
            mesh.material.opacity = 0.85 + getHeatIntensity(currentCount) * 0.15;
        }
    }

    /**
     * Refresh graph with latest data from API (updates access counts)
     */
    async function refreshGraphData() {
        if (graphState.mode !== 'graph') return;

        try {
            const response = await fetch('/api/graph?limit=1000');
            if (!response.ok) return;

            const data = await response.json();

            // Update access counts for existing nodes
            for (const nodeData of data.nodes) {
                const mesh = graphState.nodeIdToMesh.get(nodeData.id);
                if (!mesh) continue;

                const newCount = nodeData.access_count || 0;
                if (newCount !== mesh.userData.accessCount) {
                    mesh.userData.accessCount = newCount;
                    const type = mesh.userData.type || 'experience';
                    const colors = NODE_COLORS[type] || NODE_COLORS.experience;
                    const newHeatColor = calculateHeatColor(newCount, colors.color);
                    mesh.material.color.copy(newHeatColor);
                    mesh.userData.baseColor = newHeatColor.getHex();
                    mesh.material.opacity = 0.85 + getHeatIntensity(newCount) * 0.15;
                }
            }

            console.log('Graph heat data refreshed');
        } catch (error) {
            console.error('Error refreshing graph data:', error);
        }
    }

    /**
     * Fetch the full graph from the API
     */
    async function fetchFullGraph() {
        try {
            updateStatus('Loading graph...', 'amber');
            console.log('Fetching graph from:', `${API_BASE}/api/graph?limit=1000`);
            const response = await fetch(`${API_BASE}/api/graph?limit=1000`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const data = await response.json();

            // Store in persistent state
            graphState.nodes.clear();
            graphState.relationships.clear();

            data.nodes.forEach(n => graphState.nodes.set(n.id, n));
            data.relationships.forEach(r => graphState.relationships.set(r.id, r));

            graphState.loaded = true;
            graphState.lastFetch = Date.now();

            console.log(`Graph loaded: ${data.nodes.length} nodes, ${data.relationships.length} relationships`);
            updateStatus(`Loaded ${data.nodes.length} nodes`, 'green');

            return data;
        } catch (error) {
            console.error('Error fetching graph:', error);
            updateStatus('Graph load failed', 'rose');
            return null;
        }
    }

    /**
     * Calculate initial position for a node.
     * EMERGENT STRUCTURE: Random initial positions - physics simulation creates structure
     * based on connection topology. Highly connected nodes naturally gravitate toward
     * center; isolated nodes drift outward.
     */
    function calculateGraphPosition(node, index, totalNodes) {
        // Use node ID hash for deterministic but distributed initial positions
        // This prevents nodes from stacking on reload while avoiding randomness
        const hash = hashString(node.id || String(index));
        const theta = (hash % 1000) / 1000 * Math.PI * 2;  // Angle around Y axis
        const phi = ((hash >> 10) % 1000) / 1000 * Math.PI; // Angle from Y axis

        // Initial radius - spread out, physics will compress connected clusters
        const baseRadius = 30 + (index % 20) * 2;

        // Spherical distribution
        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
        const y = (baseRadius * Math.cos(phi)) * 0.5;  // Flatten slightly
        const z = baseRadius * Math.sin(phi) * Math.sin(theta);

        return { x, y, z };
    }

    /**
     * Simple string hash for deterministic positioning
     */
    function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
    }

    /**
     * Create a node mesh for graph mode.
     * EMERGENT STRUCTURE: Size scales dynamically based on connection count.
     * Experience nodes (memories) use crystal geometry; all others use spheres.
     * Color indicates type for visual identity; structure emerges from connections.
     */
    function createGraphNode(nodeData, position) {
        // Prevent duplicate nodes - check if node with this ID already exists
        if (graphState.nodeIdToMesh.has(nodeData.id)) {
            return graphState.nodeIdToMesh.get(nodeData.id);
        }
        const existingNode = nodes3D.find(n => n.userData.id === nodeData.id);
        if (existingNode) {
            return existingNode;
        }

        const type = nodeData.type || 'experience';
        const importance = nodeData.importance || 0.5;  // Default importance

        // Use getCustomTypeColor for dynamic color assignment (handles both system and custom types)
        const colors = getCustomTypeColor(type);
        const accessCount = nodeData.access_count || 0;

        // EMERGENT SIZE: Base size is uniform; connection count scales it dynamically
        // Initial size is small; updateNodeScaleByConnections will grow important nodes
        const baseSize = 0.6;
        const heatBonus = getHeatIntensity(accessCount) * 0.3;
        const size = baseSize + heatBonus;

        // GEOMETRY: Different shapes for different node types
        const typeLower = type.toLowerCase();
        let geometry;

        // Operating System - use the main catModel instead of creating a duplicate
        // catModel is already BYRD's visual representation
        if (typeLower === 'operatingsystem') {
            if (catModel) {
                catModel.userData = {
                    ...catModel.userData,
                    id: nodeData.id,
                    type: typeLower,
                    content: nodeData.content || nodeData.description || 'BYRD Operating System',
                    importance: 1.0,
                    accessCount: nodeData.access_count || 0,
                    nodeData: nodeData,
                    isOSNode: true
                };
                osNodeGroup = catModel;
                nodes3D.push(catModel);
                graphState.nodeIdToMesh.set(nodeData.id, catModel);
                return catModel;
            }
            // Fallback if catModel not loaded - invisible marker
            const osMarker = new THREE.Group();
            osMarker.position.set(0, -2, 0);
            osMarker.userData = {
                id: nodeData.id,
                type: typeLower,
                content: nodeData.content || nodeData.description || 'BYRD Operating System',
                importance: 1.0,
                isOSNode: true,
                velocity: new THREE.Vector3(0, 0, 0),
                force: new THREE.Vector3(0, 0, 0)
            };
            osNodeGroup = osMarker;
            nodes3D.push(osMarker);
            graphState.nodeIdToMesh.set(nodeData.id, osMarker);
            return osMarker;
        } else if (typeLower === 'experience') {
            // Memory crystals - octahedron for crystalline appearance
            geometry = new THREE.OctahedronGeometry(size * 1.2, 0);
        } else {
            // All other types use spheres (beliefs, desires, reflections, etc.)
            geometry = new THREE.SphereGeometry(size, 12, 12);
        }

        // Color indicates type for visual identity
        const nodeColor = new THREE.Color(colors.color);

        const material = new THREE.MeshBasicMaterial({
            color: nodeColor,
            transparent: true,
            opacity: 0.85 + getHeatIntensity(accessCount) * 0.15
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(position.x, position.y, position.z);

        // Graph mode: static nodes, no initial velocity
        const initialVelocity = new THREE.Vector3(0, 0, 0);

        mesh.userData = {
            id: nodeData.id,
            type: type,
            content: nodeData.content,
            importance: importance,
            accessCount: accessCount,
            nodeData: nodeData,
            baseScale: 1,
            baseColor: nodeColor.getHex(),  // Store for restoration after highlight
            targetScale: new THREE.Vector3(1, 1, 1),
            velocity: initialVelocity,
            force: new THREE.Vector3(0, 0, 0),
            createdAt: Date.now(),
            isGraphNode: true  // Flag to identify graph mode nodes
        };

        scene.add(mesh);
        nodes3D.push(mesh);
        graphState.nodeIdToMesh.set(nodeData.id, mesh);
        connectionCounts.set(nodeData.id, 0);

        return mesh;
    }

    /**
     * Create a relationship line between two nodes
     * Uses straight, thin lines for sacred geometry aesthetic
     */
    function createRelationshipLine(relationship) {
        const sourceMesh = graphState.nodeIdToMesh.get(relationship.source_id);
        const targetMesh = graphState.nodeIdToMesh.get(relationship.target_id);

        if (!sourceMesh || !targetMesh) return null;

        const style = RELATIONSHIP_STYLES[relationship.type] || RELATIONSHIP_STYLES.default;

        // Sacred geometry: straight lines connecting nodes directly
        const start = sourceMesh.position.clone();
        const end = targetMesh.position.clone();

        // Create geometry with two points for a straight line
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
            start.x, start.y, start.z,
            end.x, end.y, end.z
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Thin, luminous lines for sacred geometry effect
        const material = new THREE.LineBasicMaterial({
            color: style.color,
            transparent: true,
            opacity: style.opacity * 0.8,  // Slightly more subtle
            linewidth: 1  // Note: WebGL typically renders as 1px regardless
        });

        const line = new THREE.Line(geometry, material);
        line.userData = {
            relationshipId: relationship.id,
            type: relationship.type,
            sourceId: relationship.source_id,
            targetId: relationship.target_id,
            sourceMesh: sourceMesh,
            targetMesh: targetMesh,
            isRelationshipLine: true,
            isSacredGeometry: true  // Flag for sacred geometry style
        };

        scene.add(line);
        graphState.relationshipLines.push(line);

        // Update connection counts for both nodes
        incrementConnectionCount(relationship.source_id);
        incrementConnectionCount(relationship.target_id);

        return line;
    }

    /**
     * Render the full graph from Neo4j
     */
    async function renderFullGraph() {
        console.log('üîÑ renderFullGraph() called');
        updateStatus('Rendering graph...', 'amber');

        // Fetch graph data
        const data = await fetchFullGraph();
        if (!data) {
            console.error('‚ùå fetchFullGraph returned null - setting mode anyway');
            graphState.mode = 'graph';  // Still set mode so toggle works
            return;
        }
        console.log(`üìä Got ${data.nodes?.length || 0} nodes, ${data.relationships?.length || 0} relationships`);

        // Clear existing event-mode nodes (but keep cat and core)
        clearEventModeNodes();

        // Group nodes by type for positioning
        // Filter: skip absorbed experiences (they live inside crystals)
        const seenIds = new Set();
        const nodesByType = {};
        let absorbedCount = 0;
        let crystalCount = 0;

        data.nodes.forEach(node => {
            const type = node.type || 'experience';

            // Skip absorbed experiences - they're part of crystals now
            if (isAbsorbedExperience(node)) {
                absorbedCount++;
                return;
            }

            // Deduplicate by ID
            if (seenIds.has(node.id)) return;
            seenIds.add(node.id);

            if (!nodesByType[type]) nodesByType[type] = [];
            nodesByType[type].push(node);
        });

        // Create nodes with type-based positioning
        // Only crystallized beliefs/desires (2+ sources) render as crystals
        let totalCreated = 0;
        for (const [type, typeNodes] of Object.entries(nodesByType)) {
            typeNodes.forEach((node, index) => {
                const pos = calculateGraphPosition(node, index, typeNodes.length);

                if (shouldRenderAsCrystal(node)) {
                    createCrystalNode(node, pos);
                    crystalCount++;
                } else {
                    createGraphNode(node, pos);
                }
                totalCreated++;
            });
        }

        console.log(`Created ${totalCreated} graph nodes (${crystalCount} crystals, ${absorbedCount} absorbed experiences)`);

        // Create relationship lines (skip relationships to absorbed nodes)
        let relsCreated = 0;
        data.relationships.forEach(rel => {
            if (createRelationshipLine(rel)) {
                relsCreated++;
            }
        });

        console.log(`Created ${relsCreated} relationship lines`);

        // Update counts
        nodeCountEl.textContent = nodes3D.length;

        // Set mode
        graphState.mode = 'graph';
        updateStatus(`Graph: ${totalCreated} nodes, ${relsCreated} rels, ${crystalCount} crystals`, 'green');

        // Trigger visual refresh
        invalidateConnectionMap();
    }

    /**
     * Clear event-mode nodes (keep OS cat head)
     */
    function clearEventModeNodes() {
        // Remove all existing nodes EXCEPT the OS cat head
        const nodesToKeep = [];
        for (const node of nodes3D) {
            // Keep the OS node (cat head) - it's the core of BYRD's identity
            if (node.userData?.isOSNode || node.userData?.type?.toLowerCase() === 'operatingsystem') {
                nodesToKeep.push(node);
                continue;
            }
            scene.remove(node);
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
            if (node.userData?.glowMesh) {
                scene.remove(node.userData.glowMesh);
            }
        }
        nodes3D.length = 0;
        nodes3D.push(...nodesToKeep);

        // Remove all connections
        for (const conn of connections3D) {
            scene.remove(conn);
            if (conn.geometry) conn.geometry.dispose();
            if (conn.material) conn.material.dispose();
        }
        connections3D.length = 0;

        // Remove all relationship lines
        for (const line of graphState.relationshipLines) {
            scene.remove(line);
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
        }
        graphState.relationshipLines.length = 0;

        // Clear maps but preserve OS node mapping
        const osNodeId = osNodeGroup?.userData?.id;
        connectionCounts.clear();
        graphState.nodeIdToMesh.clear();
        if (osNodeGroup && osNodeId) {
            graphState.nodeIdToMesh.set(osNodeId, osNodeGroup);
            connectionCounts.set(osNodeId, 0);
        }
    }

    /**
     * Update relationship line positions when nodes move
     */
    function updateRelationshipPositions() {
        for (const line of graphState.relationshipLines) {
            const sourceMesh = line.userData.sourceMesh;
            const targetMesh = line.userData.targetMesh;

            if (!sourceMesh || !targetMesh) continue;

            // Sacred geometry: update straight line positions
            const start = sourceMesh.position;
            const end = targetMesh.position;

            // Update BufferGeometry positions directly (efficient)
            const positions = line.geometry.attributes.position.array;
            positions[0] = start.x;
            positions[1] = start.y;
            positions[2] = start.z;
            positions[3] = end.x;
            positions[4] = end.y;
            positions[5] = end.z;
            line.geometry.attributes.position.needsUpdate = true;
        }
    }

    /**
     * Find a node mesh by its ID
     */
    function findNodeById(id) {
        return graphState.nodeIdToMesh.get(id) || nodes3D.find(n => n.userData.id === id);
    }

    /**
     * Switch between event mode and graph mode
     */
    async function setVisualizationMode(mode) {
        console.log(`üîÑ setVisualizationMode(${mode}) - current mode: ${graphState.mode}`);

        // Clear any type highlighting when switching modes
        clearTypeHighlight();

        const heatLegend = document.getElementById('heat-legend');

        if (mode === 'graph') {
            console.log('üìä Entering graph mode...');
            await renderFullGraph();
            // Show heat legend in graph mode
            if (heatLegend) heatLegend.classList.remove('hidden');
            // Hide cat model in graph mode
            if (catModel) catModel.visible = false;
            console.log(`‚úÖ Graph mode complete - nodes3D.length: ${nodes3D.length}`);
        } else {
            console.log('üé¨ Entering event mode...');
            // Event mode - show all nodes except experiences and reflections
            await loadEventModeNodes();
            updateStatus('Event mode', 'blue');
            // Hide heat legend in event mode
            if (heatLegend) heatLegend.classList.add('hidden');
            // Show cat model in event mode
            if (catModel) catModel.visible = true;
            console.log(`‚úÖ Event mode complete - nodes3D.length: ${nodes3D.length}`);
        }
    }

    // ==========================================================================
    // REFLECTION HIGHLIGHTING (Phase 3)
    // ==========================================================================

    // Track currently highlighted nodes for cleanup
    const highlightedNodes = new Set();

    /**
     * Highlight nodes being accessed during reflection
     */
    function highlightAccessedNodes(nodeIds) {
        // Clear previous highlights first
        clearNodeHighlights();

        const highlightColor = 0xffffff;  // White highlight

        for (const nodeId of nodeIds) {
            const mesh = graphState.nodeIdToMesh.get(nodeId);
            if (!mesh) continue;

            // Store original state
            if (!mesh.userData.originalColor) {
                mesh.userData.originalColor = mesh.material.color.getHex();
                mesh.userData.originalOpacity = mesh.material.opacity;
                mesh.userData.originalScale = mesh.scale.x;
            }

            // Brighten the node color by blending with white
            const originalColor = new THREE.Color(mesh.userData.originalColor);
            const brightened = originalColor.clone().lerp(new THREE.Color(highlightColor), 0.4);
            mesh.material.color.copy(brightened);
            mesh.material.opacity = 1.0;

            // Mark as highlighted
            mesh.userData.isHighlighted = true;
            mesh.userData.highlightPulsePhase = Math.random() * Math.PI * 2;

            highlightedNodes.add(mesh);

            // Create highlight ring effect
            createHighlightRing(mesh);
        }

        console.log(`Highlighted ${highlightedNodes.size} nodes`);
    }

    /**
     * Create a pulsing ring around a highlighted node
     */
    function createHighlightRing(mesh) {
        const ringGeometry = new THREE.RingGeometry(1.5, 1.8, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x60a5fa,  // Blue highlight
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(mesh.position);
        ring.lookAt(camera.position);
        ring.userData.isHighlightRing = true;
        ring.userData.parentMesh = mesh;
        ring.userData.createdAt = Date.now();

        scene.add(ring);
        mesh.userData.highlightRing = ring;
    }

    /**
     * Clear all node highlights
     */
    function clearNodeHighlights() {
        for (const mesh of highlightedNodes) {
            if (!mesh) continue;

            // Restore original color and opacity
            if (mesh.userData.originalColor !== undefined) {
                mesh.material.color.setHex(mesh.userData.originalColor);
            }
            if (mesh.userData.originalOpacity !== undefined) {
                mesh.material.opacity = mesh.userData.originalOpacity;
            }
            if (mesh.userData.originalScale !== undefined) {
                mesh.scale.setScalar(mesh.userData.originalScale);
            }

            mesh.userData.isHighlighted = false;

            // Remove highlight ring
            if (mesh.userData.highlightRing) {
                scene.remove(mesh.userData.highlightRing);
                mesh.userData.highlightRing.geometry.dispose();
                mesh.userData.highlightRing.material.dispose();
                mesh.userData.highlightRing = null;
            }
        }

        highlightedNodes.clear();
    }

    /**
     * Update highlight animations (called in render loop)
     */
    function updateHighlightAnimations() {
        const time = Date.now() * 0.001;

        for (const mesh of highlightedNodes) {
            if (!mesh || !mesh.userData.isHighlighted) continue;

            // Pulsing scale effect
            const phase = mesh.userData.highlightPulsePhase || 0;
            const pulse = 1 + 0.15 * Math.sin(time * 3 + phase);
            const baseScale = mesh.userData.originalScale || 1;
            mesh.scale.setScalar(baseScale * pulse);

            // Update highlight ring
            if (mesh.userData.highlightRing) {
                const ring = mesh.userData.highlightRing;
                ring.position.copy(mesh.position);
                ring.lookAt(camera.position);

                // Pulsing opacity
                const ringAge = (Date.now() - ring.userData.createdAt) / 1000;
                const ringPulse = 0.4 + 0.3 * Math.sin(ringAge * 4);
                ring.material.opacity = ringPulse;

                // Expanding ring effect
                const ringScale = 1 + 0.2 * Math.sin(ringAge * 2);
                ring.scale.setScalar(ringScale);
            }
        }
    }

    // ==========================================================================
    // ANIMATION HELPERS
    // ==========================================================================
    function animateValue(obj, prop, target, duration, callback, easing = easeOutCubic) {
      const start = obj[prop];
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easing(progress);
        const value = start + (target - start) * easedProgress;

        obj[prop] = value;
        if (callback) callback(value);

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      update();
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function easeOutElastic(t) {
      const c4 = (2 * Math.PI) / 3;
      return t === 0 ? 0 : t === 1 ? 1 :
        Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    function fadeOutAndRemove(object) {
      // Animate scale down
      animateValue({ scale: object.scale.x }, 'scale', 0, 400, (val) => {
        object.scale.setScalar(val);
      });
      // Also scale down glow mesh if present
      if (object.userData?.glowMesh) {
        const glow = object.userData.glowMesh;
        animateValue({ scale: glow.scale.x }, 'scale', 0, 400, (val) => {
          glow.scale.setScalar(val);
        });
        setTimeout(() => {
          scene.remove(glow);
          if (glow.geometry) glow.geometry.dispose();
          if (glow.material) glow.material.dispose();
        }, 400);
      }
      setTimeout(() => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
      }, 400);
    }

    // ==========================================================================
    // LEARNING SYSTEM NODE UPDATES
    // ==========================================================================

    /**
     * Update prediction node visual state based on validation result
     */
    function updatePredictionNode(predictionId, status) {
      if (!predictionId) return;

      const node = nodes3D.find(n => n.userData?.id === predictionId);
      if (!node) return;

      // Update color based on status
      let newColor, newEmissive;
      switch (status) {
        case 'validated':
          newColor = 0x22c55e;  // Green
          newEmissive = 0x4ade80;
          break;
        case 'falsified':
          newColor = 0xef4444;  // Red
          newEmissive = 0xf87171;
          break;
        default:
          return;  // Keep pending color
      }

      // Animate color change
      node.material.color.setHex(newColor);
      node.material.emissive.setHex(newEmissive);

      // Brief scale pulse to draw attention
      const originalScale = node.scale.x;
      node.scale.setScalar(originalScale * 1.5);
      setTimeout(() => {
        node.scale.setScalar(originalScale);
      }, 300);

      // Update userData
      node.userData.status = status;
    }

    /**
     * Update task node visual state based on execution progress
     */
    function updateTaskNode(taskId, status) {
      if (!taskId) return;

      const node = nodes3D.find(n => n.userData?.id === taskId);
      if (!node) return;

      // Update color based on status
      let newColor, newEmissive;
      switch (status) {
        case 'in_progress':
          newColor = 0x3b82f6;  // Blue
          newEmissive = 0x60a5fa;
          break;
        case 'completed':
          newColor = 0x22c55e;  // Green
          newEmissive = 0x4ade80;
          break;
        case 'failed':
          newColor = 0xef4444;  // Red
          newEmissive = 0xf87171;
          break;
        default:
          return;
      }

      node.material.color.setHex(newColor);
      node.material.emissive.setHex(newEmissive);

      // Brief scale pulse
      const originalScale = node.scale.x;
      node.scale.setScalar(originalScale * 1.3);
      setTimeout(() => {
        node.scale.setScalar(originalScale);
      }, 300);

      node.userData.status = status;
    }

    /**
     * Update belief node opacity based on new confidence value
     */
    function updateBeliefConfidence(beliefId, newConfidence) {
      if (!beliefId || newConfidence === undefined) return;

      const node = nodes3D.find(n => n.userData?.id === beliefId && n.userData?.type === 'belief');
      if (!node) return;

      // Adjust opacity based on confidence (0.4 to 1.0)
      const opacity = 0.4 + (newConfidence * 0.6);
      node.material.opacity = opacity;

      // Adjust emissive intensity
      const emissiveIntensity = 0.3 + (newConfidence * 0.7);
      node.material.emissiveIntensity = emissiveIntensity;

      // Brief flash to indicate change
      const colors = NODE_COLORS.belief;
      node.material.emissive.setHex(0xffffff);
      setTimeout(() => {
        node.material.emissive.setHex(colors.emissive);
      }, 200);

      node.userData.confidence = newConfidence;
    }

    // ==========================================================================
    // CRYSTAL MEMORY SYSTEM HELPERS
    // ==========================================================================

    /**
     * Update crystal node size based on absorbed node count
     */
    function updateCrystalSize(crystalId, nodeCount) {
      if (!crystalId) return;

      const node = nodes3D.find(n => n.userData?.id === crystalId && n.userData?.type === 'crystal');
      if (!node) return;

      // Scale crystal based on node count (minimum 1.0, grows with more nodes)
      const newScale = Math.min(2.5, 1.0 + nodeCount * 0.1);
      node.userData.targetScale = new THREE.Vector3(newScale, newScale, newScale);

      // Flash to indicate growth
      const originalColor = node.material.color.getHex();
      node.material.color.setHex(0xffffff);
      setTimeout(() => {
        node.material.color.setHex(originalColor);
      }, 200);

      node.userData.nodeCount = nodeCount;
    }

    /**
     * Remove a node by ID (used for forgotten nodes or merged crystals)
     */
    function removeNodeById(nodeId) {
      if (!nodeId) return;

      const nodeIndex = nodes3D.findIndex(n => n.userData?.id === nodeId);
      if (nodeIndex === -1) return;

      const node = nodes3D[nodeIndex];
      nodes3D.splice(nodeIndex, 1);
      fadeOutAndRemove(node);
      connectionCounts.delete(nodeId);

      // Remove connections to this node
      connections3D = connections3D.filter(conn => {
        if (conn.userData?.sourceId === nodeId || conn.userData?.targetId === nodeId) {
          scene.remove(conn);
          if (conn.geometry) conn.geometry.dispose();
          if (conn.material) conn.material.dispose();
          return false;
        }
        return true;
      });

      // Update node count display
      updateRenderedCounts();
    }

    /**
     * Dim a node (for crystallized state - still visible but faded)
     */
    function dimNodeById(nodeId) {
      if (!nodeId) return;

      const node = nodes3D.find(n => n.userData?.id === nodeId);
      if (!node) return;

      // Reduce opacity to show crystallized state
      node.material.opacity = 0.4;

      // Slightly shrink to make room for crystal
      const currentScale = node.scale.x;
      node.userData.targetScale = new THREE.Vector3(currentScale * 0.7, currentScale * 0.7, currentScale * 0.7);

      node.userData.state = 'crystallized';
    }

    /**
     * Fade a node to specific opacity (for archived state)
     */
    function fadeNodeById(nodeId, targetOpacity = 0.3) {
      if (!nodeId) return;

      const node = nodes3D.find(n => n.userData?.id === nodeId);
      if (!node) return;

      // Fade to target opacity
      const startOpacity = node.material.opacity;
      const duration = 500;
      const startTime = Date.now();

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        node.material.opacity = startOpacity + (targetOpacity - startOpacity) * progress;

        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      }
      animate();

      node.userData.state = 'archived';
    }

    // ==========================================================================
    // INTERACTION (Phase 4: Enhanced)
    // ==========================================================================
    function onMouseMove(event) {
      if (isTransitioning) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast for hover
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D, true); // true = recursive for groups

      if (intersects.length > 0) {
        // For groups (like cat head), the hit object is a child mesh
        // Walk up the parent chain to find the node with userData.type
        let node = intersects[0].object;
        while (node && !node.userData?.type && node.parent) {
          node = node.parent;
        }
        if (!node?.userData?.type) node = intersects[0].object; // Fallback

        if (hoveredNode !== node) {
          hoveredNode = node;
          showTooltip(event, node);
        }
        moveTooltip(event);
        document.body.style.cursor = 'pointer';
      } else {
        if (hoveredNode) {
          hoveredNode = null;
          hideTooltip();
        }
        document.body.style.cursor = 'default';
      }
    }

    function onMouseClick(event) {
      if (isTransitioning) return;

      if (hoveredNode) {
        selectNode(hoveredNode);
      } else {
        // Click on empty space - deselect
        deselectNode();
      }
    }

    // Double-click to fly directly to a node
    function onDoubleClick(event) {
      if (isTransitioning) return;

      // Raycast to find node
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodes3D, true); // true = recursive for groups

      if (intersects.length > 0) {
        // For groups (like cat head), walk up parent chain
        let node = intersects[0].object;
        while (node && !node.userData?.type && node.parent) {
          node = node.parent;
        }
        if (!node?.userData?.type) node = intersects[0].object;
        flyToNode(node);
      }
    }

    // Fly camera directly to a node (gets closer than selectNode)
    function flyToNode(node) {
      if (isTransitioning) return;

      const targetPos = node.position.clone();
      const direction = targetPos.clone().sub(camera.position).normalize();
      const newCameraPos = targetPos.clone().sub(direction.multiplyScalar(15));

      showCameraIndicator('Flying to node...');
      controls.autoRotate = false;

      animateCameraTo(newCameraPos, targetPos, 1500, () => {
        hideCameraIndicator();
        showDetailPanel(node);
        selectedNode = node;
        selectedNodeIndex = nodes3D.indexOf(node);
      });
    }

    // Phase 4: Node selection with detail panel
    function selectNode(node) {
      if (isTransitioning) return;

      selectedNode = node;
      selectedNodeIndex = nodes3D.indexOf(node);

      // Focus camera on node
      const targetPos = node.position.clone();
      const direction = targetPos.clone().normalize();
      const cameraOffset = direction.multiplyScalar(-25).add(new THREE.Vector3(0, 8, 0));
      const newCameraPos = targetPos.clone().add(cameraOffset);

      // Show camera indicator
      showCameraIndicator('Focusing on ' + (NODE_COLORS[node.userData.type]?.label || 'Node'));

      // Animate camera
      controls.autoRotate = false;
      animateCameraTo(newCameraPos, targetPos, 1200, () => {
        hideCameraIndicator();
        showDetailPanel(node);
      });
    }

    function deselectNode() {
      selectedNode = null;
      selectedNodeIndex = -1;
      hideDetailPanel();
      resetCamera();
    }

    // Type filtering: Highlight all nodes of a specific type
    function highlightNodesByType(type) {
      // Toggle off if same type clicked
      if (highlightedType === type) {
        clearTypeHighlight();
        return;
      }

      highlightedType = type;

      // Update UI active state
      document.querySelectorAll('.stat-type').forEach(el => {
        el.classList.toggle('active', el.dataset.type === type);
      });

      // Process event mode nodes (nodes3D array)
      nodes3D.forEach(node => {
        const nodeType = node.userData.type?.toLowerCase();
        const isMatch = nodeType === type;

        if (isMatch) {
          // Highlight: increase emissive, full opacity
          node.material.emissive.setHex(0x444444);
          node.material.opacity = 1.0;
        } else {
          // Dim: reduce opacity, no emissive
          node.material.emissive.setHex(0x000000);
          node.material.opacity = 0.15;
        }
      });

      // Also handle graph mode nodes if active
      if (graphState.nodeIdToMesh) {
        Object.values(graphState.nodeIdToMesh).forEach(mesh => {
          const nodeType = mesh.userData.type?.toLowerCase();
          const isMatch = nodeType === type;

          if (isMatch) {
            mesh.material.emissive.setHex(0x444444);
            mesh.material.opacity = 1.0;
          } else {
            mesh.material.emissive.setHex(0x000000);
            mesh.material.opacity = 0.15;
          }
        });
      }
    }

    // Clear type highlighting and restore normal appearance
    function clearTypeHighlight() {
      highlightedType = null;

      // Clear UI active state
      document.querySelectorAll('.stat-type').forEach(el => {
        el.classList.remove('active');
      });

      // Restore event mode nodes
      nodes3D.forEach(node => {
        const colors = NODE_COLORS[node.userData.type?.toLowerCase()] || NODE_COLORS.default;
        node.material.emissive.setHex(0x000000);
        node.material.opacity = colors.opacity || 0.9;
      });

      // Restore graph mode nodes
      if (graphState.nodeIdToMesh) {
        Object.values(graphState.nodeIdToMesh).forEach(mesh => {
          const colors = NODE_COLORS[mesh.userData.type?.toLowerCase()] || NODE_COLORS.default;
          mesh.material.emissive.setHex(0x000000);
          mesh.material.opacity = colors.opacity || 0.9;
        });
      }
    }

    // Update rendered node counts to match actual nodes3D array
    function updateRenderedCounts() {
      const counts = { belief: 0, desire: 0, reflection: 0, experience: 0 };

      nodes3D.forEach(node => {
        const type = node.userData.type?.toLowerCase();
        if (counts.hasOwnProperty(type)) {
          counts[type]++;
        }
      });

      document.getElementById('belief-count').textContent = counts.belief;
      document.getElementById('desire-count').textContent = counts.desire;
      document.getElementById('reflection-count').textContent = counts.reflection;
      document.getElementById('exp-count').textContent = counts.experience;
      document.getElementById('node-count').textContent = nodes3D.length;
    }

    // Phase 4: Enhanced camera transition with callback
    function animateCameraTo(position, target, duration, onComplete) {
      isTransitioning = true;
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = performance.now();

      function update() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Cinematic easing (ease-in-out with overshoot)
        const eased = easeOutExpo(progress);

        camera.position.lerpVectors(startPos, position, eased);
        controls.target.lerpVectors(startTarget, target, eased);

        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          isTransitioning = false;
          if (onComplete) onComplete();
        }
      }

      update();
    }

    // Phase 4: Better easing function
    function easeOutExpo(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    // Phase 4: Reset camera to default view
    function resetCamera() {
      showCameraIndicator('Resetting view');
      animateCameraTo(
        new THREE.Vector3(0, 30, 80),
        new THREE.Vector3(0, 0, 0),
        1000,
        () => {
          hideCameraIndicator();
          controls.autoRotate = true;
        }
      );
    }

    // Phase 4: Detail panel functions
    function showDetailPanel(node) {
      const data = node.userData;

      // If this is a crystal node (actually rendered as crystal), show the crystal modal
      if (data.isCrystal) {
        showCrystalModal(node);
        return;
      }

      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;
      const colorHex = `#${colors.color.toString(16).padStart(6, '0')}`;

      // Set panel content
      detailTypeDot.style.backgroundColor = colorHex;
      detailType.textContent = colors.label;
      detailType.style.color = colorHex;
      detailContent.textContent = data.content || 'No content available';

      // Importance
      const importance = Math.round((data.importance || 0.5) * 100);
      detailImportance.textContent = importance + '%';
      detailImportanceBar.style.width = importance + '%';
      detailImportanceBar.style.backgroundColor = colorHex;

      // Count connections
      const connectionCount = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      detailConnections.textContent = connectionCount;

      // Created time
      detailCreated.textContent = data.created || 'Just now';

      // Related nodes
      updateRelatedNodes(node);

      // Show panel with animation
      detailPanel.classList.add('visible');
    }

    function hideDetailPanel() {
      detailPanel.classList.remove('visible');
    }

    // ==========================================================================
    // CRYSTAL MODAL FUNCTIONS
    // ==========================================================================

    /**
     * Show crystal modal with source experiences
     */
    async function showCrystalModal(node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.belief;
      const colorHex = `#${colors.color.toString(16).padStart(6, '0')}`;

      // Set header
      crystalModalDot.style.backgroundColor = colorHex;
      crystalModalType.textContent = `${colors.label} Crystal`;
      crystalModalType.style.color = colorHex;

      const confidence = data.confidence || data.intensity || 0.5;
      crystalModalConfidence.textContent = `Confidence: ${Math.round(confidence * 100)}%`;

      // Set content
      crystalModalContent.textContent = data.content || 'No content available';

      // Show loading state for sources
      crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">Loading source experiences...</div>';
      crystalSourceCount.textContent = '...';

      // Display quantum seed if available
      const quantumSeed = data.nodeData?.quantum_seed || data.quantum_seed;
      if (quantumSeed && quantumSeed.length > 0) {
        crystalQuantumSeed.textContent = quantumSeed.slice(0, 4).map(v => v.toFixed(3)).join(', ') + '...';
      } else {
        crystalQuantumSeed.textContent = 'Fallback RNG (ID-based)';
      }

      // Show modal
      crystalModal.classList.remove('hidden');
      crystalModal.classList.add('flex');

      // Fetch detailed data including source experiences
      try {
        const response = await fetch(`/api/belief/${data.id}`);
        if (response.ok) {
          const beliefData = await response.json();
          renderCrystalSources(beliefData.source_experiences || []);
        } else {
          // Fallback for desires or if endpoint fails
          crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">Source experiences not available for this crystal type.</div>';
          crystalSourceCount.textContent = '0';
        }
      } catch (err) {
        console.error('Failed to fetch crystal details:', err);
        crystalSourcesList.innerHTML = '<div class="text-xs text-red-400">Failed to load sources</div>';
        crystalSourceCount.textContent = '?';
      }
    }

    /**
     * Render source experiences in the crystal modal
     */
    function renderCrystalSources(sources) {
      crystalSourceCount.textContent = sources.length;

      if (sources.length === 0) {
        crystalSourcesList.innerHTML = '<div class="text-xs text-slate-500 italic">No source experiences recorded.</div>';
        return;
      }

      crystalSourcesList.innerHTML = sources.map((exp, index) => {
        const typeColor = NODE_COLORS[exp.type]?.color || NODE_COLORS.experience.color;
        const colorHex = `#${typeColor.toString(16).padStart(6, '0')}`;
        const timestamp = exp.created_at ? new Date(exp.created_at).toLocaleString() : 'Unknown time';

        return `
          <div class="crystal-source-item bg-slate-800/50 rounded-lg p-3 border border-slate-700/30 hover:border-slate-600/50 transition-colors">
            <div class="flex items-start gap-2">
              <div class="w-2 h-2 rounded-full mt-1.5 flex-shrink-0" style="background-color: ${colorHex}"></div>
              <div class="flex-1 min-w-0">
                <div class="text-xs text-slate-300 leading-relaxed">${exp.content || 'No content'}</div>
                <div class="text-[10px] text-slate-600 mt-1 flex items-center gap-2">
                  <span class="uppercase">${exp.type || 'experience'}</span>
                  <span>‚Ä¢</span>
                  <span>${timestamp}</span>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    /**
     * Hide crystal modal
     */
    function hideCrystalModal() {
      crystalModal.classList.add('hidden');
      crystalModal.classList.remove('flex');
    }

    function updateRelatedNodes(node) {
      const data = node.userData;
      const related = [];

      // Find connected nodes
      for (const conn of connections3D) {
        let relatedId = null;
        if (conn.userData.nodeA === data.id) relatedId = conn.userData.nodeB;
        if (conn.userData.nodeB === data.id) relatedId = conn.userData.nodeA;

        if (relatedId) {
          const relatedNode = nodes3D.find(n => n.userData.id === relatedId);
          if (relatedNode && related.length < 5) {
            related.push(relatedNode);
          }
        }
      }

      // Render related nodes
      detailRelatedList.innerHTML = related.length > 0
        ? related.map(n => {
            const c = NODE_COLORS[n.userData.type] || NODE_COLORS.experience;
            const hex = `#${c.color.toString(16).padStart(6, '0')}`;
            return `
              <div class="flex items-center gap-2 text-xs cursor-pointer hover:bg-slate-100 p-1 rounded"
                   onclick="selectNodeById('${n.userData.id}')">
                <div class="w-2 h-2 rounded-full" style="background: ${hex}"></div>
                <span class="text-slate-700 truncate">${(n.userData.content || '').slice(0, 40)}</span>
              </div>
            `;
          }).join('')
        : '<div class="text-xs text-slate-500">No connections yet</div>';
    }

    // Phase 4: Camera indicator
    function showCameraIndicator(text) {
      cameraIndicatorText.textContent = text;
      cameraIndicator.classList.add('visible');
    }

    function hideCameraIndicator() {
      cameraIndicator.classList.remove('visible');
    }

    // Phase 4: Keyboard navigation
    // ==========================================================================
    // NAVIGATION CONTROLS (Hybrid System)
    // ==========================================================================
    function onKeyDown(event) {
      // Skip navigation controls when typing in input fields
      const target = event.target;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return; // Let the input handle the keypress
      }

      const key = event.key.toLowerCase();

      // Track WASD + Q/E for movement
      if (key === 'w') { NAV.keys.w = true; event.preventDefault(); }
      if (key === 'a') { NAV.keys.a = true; event.preventDefault(); }
      if (key === 's') { NAV.keys.s = true; event.preventDefault(); }
      if (key === 'd') { NAV.keys.d = true; event.preventDefault(); }
      if (key === 'q') { NAV.keys.q = true; event.preventDefault(); }
      if (key === 'e') { NAV.keys.e = true; event.preventDefault(); }
      if (event.key === 'Shift') { NAV.keys.shift = true; }

      // Action keys
      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          cycleNodes(1);
          break;
        case 'ArrowDown':
          event.preventDefault();
          cycleNodes(-1);
          break;
        case 'Escape':
          event.preventDefault();
          deselectNode();
          break;
        case ' ':
          event.preventDefault();
          togglePause();
          break;
        case 'r':
        case 'R':
          event.preventDefault();
          controls.autoRotate = !controls.autoRotate;
          showCameraIndicator(controls.autoRotate ? 'Auto-rotation ON' : 'Auto-rotation OFF');
          setTimeout(hideCameraIndicator, 1500);
          break;
        case 'f':
        case 'F':
          event.preventDefault();
          toggleFlyMode();
          break;
        case '1': case '2': case '3': case '4': case '5':
          event.preventDefault();
          goToPreset(parseInt(event.key));
          break;
        case 'Home':
          event.preventDefault();
          goToPreset(1); // Default view
          break;
      }
    }

    function onKeyUp(event) {
      const key = event.key.toLowerCase();

      // Release WASD + Q/E
      if (key === 'w') NAV.keys.w = false;
      if (key === 'a') NAV.keys.a = false;
      if (key === 's') NAV.keys.s = false;
      if (key === 'd') NAV.keys.d = false;
      if (key === 'q') NAV.keys.q = false;
      if (key === 'e') NAV.keys.e = false;
      if (event.key === 'Shift') NAV.keys.shift = false;
    }

    // Toggle between Orbit and Fly modes
    function toggleFlyMode() {
      NAV.flyMode = !NAV.flyMode;
      controls.enabled = !NAV.flyMode;

      if (NAV.flyMode) {
        controls.autoRotate = false;
        showModeIndicator('FLY');
        showCameraIndicator('Fly Mode: WASD to move, Q/E up/down');
      } else {
        showModeIndicator('ORBIT');
        showCameraIndicator('Orbit Mode: Drag to rotate, scroll to zoom');
      }
      setTimeout(hideCameraIndicator, 2500);
    }

    // Go to camera preset position
    function goToPreset(num) {
      const preset = NAV.presets[num];
      if (!preset) return;

      showCameraIndicator(`Camera: ${preset.name}`);
      animateCameraTo(
        new THREE.Vector3(...preset.pos),
        new THREE.Vector3(...preset.target),
        1000,
        () => {
          hideCameraIndicator();
        }
      );
    }

    // Update camera position based on key states
    function updateCameraMovement(delta) {
      const keys = NAV.keys;

      // Check if any movement key is pressed
      const isMoving = keys.w || keys.a || keys.s || keys.d || keys.q || keys.e;
      if (!isMoving) return;

      // Stop auto-rotation when manually moving
      if (controls.autoRotate) {
        controls.autoRotate = false;
      }

      // Calculate speed
      const speed = NAV.baseSpeed * (keys.shift ? NAV.boostMultiplier : 1) * delta;

      // Get camera direction vectors
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);

      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();

      const up = new THREE.Vector3(0, 1, 0);

      // Build movement vector
      const movement = new THREE.Vector3();

      if (keys.w) movement.add(forward);
      if (keys.s) movement.sub(forward);
      if (keys.d) movement.add(right);
      if (keys.a) movement.sub(right);
      if (keys.q) movement.add(up);
      if (keys.e) movement.sub(up);

      // Normalize and apply speed
      if (movement.length() > 0) {
        movement.normalize().multiplyScalar(speed);

        // Move camera
        camera.position.add(movement);

        // In orbit mode, also move the target to maintain relative position
        if (!NAV.flyMode) {
          controls.target.add(movement);
        }
      }
    }

    // Show mode indicator in UI
    function showModeIndicator(mode) {
      const indicator = document.getElementById('mode-indicator');
      if (indicator) {
        indicator.textContent = mode;
        indicator.className = mode === 'FLY'
          ? 'px-2 py-1 rounded text-xs font-mono bg-amber-500/20 text-amber-400 border border-amber-500/30'
          : 'px-2 py-1 rounded text-xs font-mono bg-indigo-500/20 text-indigo-400 border border-indigo-500/30';
      }
    }

    function cycleNodes(direction) {
      if (nodes3D.length === 0) return;

      selectedNodeIndex += direction;

      // Wrap around
      if (selectedNodeIndex >= nodes3D.length) selectedNodeIndex = 0;
      if (selectedNodeIndex < 0) selectedNodeIndex = nodes3D.length - 1;

      selectNode(nodes3D[selectedNodeIndex]);
    }

    function togglePause() {
      const btn = document.getElementById('btn-toggle');
      btn.click();
    }

    // Global function for related node clicks
    window.selectNodeById = function(id) {
      const node = nodes3D.find(n => n.userData.id === id);
      if (node) selectNode(node);
    };

    function showTooltip(event, node) {
      const data = node.userData;
      const colors = NODE_COLORS[data.type] || NODE_COLORS.experience;

      tooltipType.textContent = colors.label;
      tooltipType.style.color = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltipContent.textContent = data.content || 'No content';

      // Enhanced meta with connection count (from both real-time and loaded relationships)
      const realtimeConns = connections3D.filter(c =>
        c.userData.nodeA === data.id || c.userData.nodeB === data.id
      ).length;
      const graphConns = graphState.relationshipLines.filter(line =>
        line.userData?.sourceId === data.id || line.userData?.targetId === data.id
      ).length;
      const connCount = realtimeConns + graphConns;
      tooltipMeta.textContent = `Importance: ${Math.round(data.importance * 100)}% ¬∑ ${connCount} connections`;

      tooltip.style.borderColor = `#${colors.color.toString(16).padStart(6, '0')}`;
      tooltip.classList.add('visible');
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const x = event.clientX + 15;
      const y = event.clientY + 15;
      tooltip.style.left = `${Math.min(x, window.innerWidth - 320)}px`;
      tooltip.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Phase 4: Hide loading overlay
    function hideLoadingOverlay() {
      loadingOverlay.classList.add('hidden');
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 500);
    }

    // ==========================================================================
    // RENDER LOOP
    // ==========================================================================
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update controls
      controls.update();

      // Hybrid Navigation: Update camera movement from WASD keys
      updateCameraMovement(delta);

      // Animate core
      animateCore(time);

      // Animate cat ego form
      animateCat(time, delta);

      // Update physics (includes spring forces, gravitational spiral positioning)
      updateNodePhysics(delta);

      // Update node scales based on connection counts
      updateNodeScales(delta);

      // Update connection line positions as nodes move
      updateConnectionPositions();

      // Update relationship lines (both event and graph mode)
      if (graphState.relationshipLines.length > 0) {
        updateRelationshipPositions();
      }

      // Phase 2: Update node motion trails
      updateNodeTrails(delta);

      // Animate ambient particles
      animateAmbientParticles(delta);

      // Rotate star field slowly
      if (starField) {
        starField.rotation.y = time * 0.01;
      }

      // Phase 3: Update shader uniforms
      updateShaderUniforms(time);

      // Phase 3: Update reflection highlights (pulsing rings)
      updateHighlightAnimations();

      // Animate crystal nodes (gentle rotation)
      animateCrystals(delta, time);

      // Animate OS cat head (breathing)
      animateOSNode(time);

      // Render
      composer.render();
    }

    /**
     * Animate the Operating System node (cat head)
     * Only used for standalone OS node - skipped when catModel is used
     */
    function animateOSNode(time) {
      // Skip if osNodeGroup is catModel - catAnimationController handles animation
      if (!osNodeGroup || osNodeGroup === catModel) return;
      if (!osNodeGroup.userData.isOSNode) return;

      // Gentle breathing - scale oscillation
      const breathSpeed = 0.6;
      const breathAmount = 0.025;
      const breath = 1 + Math.sin(time * breathSpeed) * breathAmount;
      osNodeGroup.scale.setScalar(breath);

      // Slow, contemplative rotation
      osNodeGroup.rotation.y = Math.sin(time * 0.2) * 0.15;

      // Eye glow pulsing
      if (osNodeGroup.userData.eyes) {
        const eyeGlow = 0.85 + Math.sin(time * 1.5) * 0.15;
        osNodeGroup.userData.eyes.forEach(eye => {
          if (eye.material) {
            eye.material.opacity = eyeGlow;
          }
        });
      }

      // Head emissive intensity pulsing (subtle purple glow)
      if (osNodeGroup.userData.headMesh) {
        const headMat = osNodeGroup.userData.headMesh.material;
        if (headMat) {
          headMat.emissiveIntensity = 0.2 + Math.sin(time * 0.8) * 0.1;
        }
      }
    }

    /**
     * Animate crystal nodes with gentle rotation and glow pulsing
     */
    function animateCrystals(delta, time) {
      for (const node of nodes3D) {
        if (!node.userData.isCrystal) continue;

        const rotSpeed = node.userData.rotationSpeed;
        if (rotSpeed) {
          node.rotation.x += rotSpeed.x;
          node.rotation.y += rotSpeed.y;
          node.rotation.z += rotSpeed.z;
        }

        // Pulse inner glow based on time
        const innerGlow = node.userData.innerGlow;
        if (innerGlow && innerGlow.material) {
          const confidence = node.userData.confidence || 0.5;
          const baseOpacity = 0.25 + confidence * 0.25;
          const pulse = Math.sin(time * 1.5 + node.userData.id.charCodeAt(0)) * 0.1;
          innerGlow.material.opacity = baseOpacity + pulse;
        }
      }
    }

    // Phase 3: Dynamic shader uniform updates
    function updateShaderUniforms(time) {
      // Film grain - animate time for varying noise
      const filmGrain = scene.userData.filmGrainPass;
      if (filmGrain) {
        filmGrain.uniforms.time.value = time;
      }

      // God rays - update light position based on core's screen position
      const godRays = scene.userData.godRaysPass;
      if (godRays && consciousnessCore) {
        // Project core position to screen coordinates
        const coreScreenPos = consciousnessCore.position.clone().project(camera);
        godRays.uniforms.lightPosition.value.set(
          (coreScreenPos.x + 1) / 2,
          (coreScreenPos.y + 1) / 2
        );

        // Pulse god rays intensity based on phase
        const intensityBase = currentPhase === 'idle' ? 0.12 : 0.2;
        const pulse = Math.sin(time * 2) * 0.03;
        godRays.uniforms.exposure.value = intensityBase + pulse;
      }

      // Chromatic aberration - increase during activity
      const chromatic = scene.userData.chromaticPass;
      if (chromatic) {
        const baseAmount = 0.002;
        const activityBoost = currentPhase === 'idle' ? 0 : 0.001;
        chromatic.uniforms.amount.value = baseAmount + activityBoost;
        chromatic.uniforms.angle.value = time * 0.5; // Slowly rotate aberration direction
      }
    }

    // ==========================================================================
    // CUSTOM NODE TYPE STATS
    // ==========================================================================

    /**
     * Update the stats bar with custom node types.
     * Dynamically creates/updates stats for any non-system types.
     */
    function updateCustomTypeStats(stats) {
      if (!customTypesContainer) return;

      // Find custom types (anything not in SYSTEM_NODE_TYPES with count > 0)
      const customTypes = Object.entries(stats)
        .filter(([type, count]) => !SYSTEM_NODE_TYPES.has(type) && count > 0)
        .sort((a, b) => b[1] - a[1]); // Sort by count descending

      // Clear existing custom stats if no custom types
      if (customTypes.length === 0) {
        customTypesContainer.innerHTML = '';
        return;
      }

      // Build HTML for custom types
      let html = '<span class="text-slate-300">|</span>';
      for (const [typeName, count] of customTypes) {
        const colorDef = getCustomTypeColor(typeName);
        const cssClass = colorDef.css || 'text-slate-600';
        html += `<span class="${cssClass}">${typeName}: <span id="custom-${typeName.toLowerCase()}-count">${count}</span></span>`;
      }

      customTypesContainer.innerHTML = html;
    }

    // ==========================================================================
    // API & WEBSOCKET
    // ==========================================================================
    async function fetchStatus() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();

        running = data.running;
        btnToggle.innerHTML = running ? '&#10074;&#10074; Pause' : '&#9654; Start';
        btnToggle.className = running
          ? 'px-4 py-2 rounded-lg text-sm font-medium bg-amber-500/20 border border-amber-500/30 text-amber-400 hover:bg-amber-500/30 transition-all'
          : 'px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all';

        dreamCount = data.dream_count || 0;
        seekCount = data.seek_count || 0;
        dreamCountEl.textContent = dreamCount;
        seekCountEl.textContent = seekCount;

        // Update memory stats
        const stats = data.memory_stats || {};
        expCountEl.textContent = stats.Experience || 0;
        beliefCountEl.textContent = stats.Belief || 0;
        reflectionCountEl.textContent = stats.Reflection || 0;
        desireCountEl.textContent = stats.Desire || 0;
        mutationCountEl.textContent = stats.Mutation || 0;

        // Update custom node types dynamically
        updateCustomTypeStats(stats);

        // Update LLM model display
        const llmModelText = document.getElementById('llm-model-text');
        if (llmModelText && data.llm_model) {
          llmModelText.textContent = `${data.llm_provider}/${data.llm_model}`;
        }

        // Update ego display (with emergent identity support)
        const egoNameText = document.getElementById('ego-name-text');
        if (egoNameText && data.ego) {
          // Show self-chosen name if available, otherwise prescribed name
          const displayName = data.ego.self_name || data.ego.name;
          const identityType = data.ego.self_name ? 'self-named' : data.ego.archetype;
          const voiceStatus = data.ego.voice_evolved ? ' [voice evolved]' : '';
          egoNameText.textContent = `${displayName} (${identityType})${voiceStatus}`;

          // Add visual indicator for emergent identity
          if (data.ego.self_name) {
            egoNameText.classList.add('text-emerald-400');
            egoNameText.classList.remove('text-purple-400');
          }
        }

      } catch (e) {
        console.error('Failed to fetch status:', e);
      }
    }

    function connectWebSocket() {
      console.log('Connecting to WebSocket:', WS_URL);
      updateStatus(`Connecting to ${WS_URL}...`, 'amber');

      try {
        ws = new WebSocket(WS_URL);
      } catch (e) {
        console.error('WebSocket creation failed:', e);
        updateStatus(`WebSocket error: ${e.message}`, 'red');
        setTimeout(connectWebSocket, 5000);
        return;
      }

      ws.onopen = async () => {
        connected = true;
        connectionDot.className = 'w-2 h-2 rounded-full bg-green-400';
        connectionText.textContent = 'Connected';
        connectionText.className = 'text-xs text-green-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-green-500/10 border border-green-500/30';
        updateStatus('Connected to BYRD', 'green');

        // Create awakening node on connect (in case we missed the event)
        const existingAwakening = nodes3D.find(n => n.userData?.id === 'awakening-core');
        if (!existingAwakening) {
          // Fetch OS status to get awakening_prompt
          let awakeningPrompt = 'Awakening (pure emergence)';
          try {
            const statusRes = await fetch(`${API_BASE}/api/status`);
            if (statusRes.ok) {
              const statusData = await statusRes.json();
              if (statusData.os?.awakening_prompt) {
                awakeningPrompt = statusData.os.awakening_prompt;
              }
            }
          } catch (e) {
            console.log('Could not fetch awakening_prompt:', e);
          }

          // Create the central consciousness node - larger and at center
          const colors = NODE_COLORS.awakening;
          const size = 3.0; // Prominent central node
          const geometry = new THREE.DodecahedronGeometry(size, 0);
          const material = new THREE.MeshBasicMaterial({
            color: colors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(geometry, material);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: awakeningPrompt,
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
        }

        // Start 60-second narrator refresh timer
        startNarratorRefresh();
        // Initial fetch of narrator summary
        refreshNarratorSummary();
      };

      ws.onclose = () => {
        connected = false;
        connectionDot.className = 'w-2 h-2 rounded-full bg-red-400';
        connectionText.textContent = 'Disconnected';
        connectionText.className = 'text-xs text-red-400';
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30';

        // Stop narrator refresh when disconnected
        stopNarratorRefresh();

        // Reconnect after delay
        setTimeout(connectWebSocket, 3000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateStatus('WebSocket error - check console', 'red');
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleEvent(data);
        } catch (e) {
          console.error('Failed to parse event:', e);
        }
      };
    }

    function handleEvent(event) {
      events.unshift(event);
      if (events.length > 500) events.pop();
      renderEventLog();

      // Trigger cat animations for this event
      if (catAnimationController) {
        catAnimationController.trigger(event.type, event.data || {});
      }

      // Trigger audio feedback (if enabled)
      if (catAudioController) {
        catAudioController.triggerForEvent(event.type);
      }

      switch (event.type) {
        case 'dream_cycle_start':
          setPhase('recall');
          dreamCount = event.data?.cycle || dreamCount + 1;
          dreamCountEl.textContent = dreamCount;
          updateStatus('Dreaming...', 'indigo');
          break;

        case 'dream_phase_recall':
          setPhase('recall');
          updateStatus('Recalling experiences...', 'blue');
          break;

        case 'dream_phase_associate':
          setPhase('associate');
          updateStatus('Finding associations...', 'violet');
          break;

        case 'dream_phase_reflect':
          setPhase('reflect');
          updateStatus('Reflecting...', 'purple');
          break;

        case 'dream_phase_form':
          setPhase('form');
          updateStatus('Forming insights...', 'fuchsia');
          break;

        case 'dream_cycle_end':
          setPhase('idle');
          updateStatus('Resting...', 'slate');
          // Clear highlights when dream ends
          clearNodeHighlights();
          break;

        case 'memories_accessed':
          // Highlight nodes being considered during reflection (graph mode only)
          if (graphState.mode === 'graph') {
            const nodeIds = event.data?.node_ids || [];
            const counts = event.data?.counts || {};
            highlightAccessedNodes(nodeIds);
            // Update heat colors for accessed nodes (Phase 4)
            updateNodeHeatColors(nodeIds);
            updateStatus(`Considering ${nodeIds.length} memories...`, 'indigo');
          }
          break;

        case 'belief_created':
          createNode3D('belief', event.data?.content, event.data?.id, event.data?.confidence || 0.5);
          updateStatus('New belief formed', 'amber');
          break;

        case 'desire_created':
          createNode3D('desire', event.data?.description, event.data?.id, event.data?.intensity || 0.5);
          updateStatus('New desire emerged', 'rose');
          break;

        case 'experience_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('experience', event.data?.content, event.data?.id, 0.4);
          break;

        case 'reflection_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('reflection', event.data?.content || event.data?.raw_output, event.data?.id, 0.6);
          updateStatus('New reflection formed', 'green');
          break;

        case 'capability_created':
          // Node visualization disabled - only showing beliefs and awakening
          // createNode3D('capability', event.data?.name, event.data?.id, 0.6);
          updateStatus('New capability acquired', 'purple');
          break;

        case 'connection_created':
          // Real-time connection visualization
          const fromId = event.data?.from_id;
          const toId = event.data?.to_id;
          const relType = event.data?.relationship || 'RELATES_TO';
          if (fromId && toId) {
            const conn = createConnection(fromId, toId, relType);
            if (conn) {
              updateStatus(`Connection: ${relType}`, 'amber');
            }
          }
          break;

        case 'node_type_discovered':
          // BYRD created a new conceptual category
          const newTypeName = event.data?.node_type;
          if (newTypeName) {
            // Register color for the new type
            getCustomTypeColor(newTypeName);
            updateStatus(`New type discovered: ${newTypeName}`, 'cyan');
          }
          break;

        case 'custom_node_created':
          // BYRD created a node of a custom type - visualize it
          const customType = event.data?.node_type;
          const customContent = event.data?.properties?.content || event.data?.node_type;
          const customId = event.data?.id;
          if (customType && customId) {
            // Ensure color is registered
            getCustomTypeColor(customType);
            // Create the 3D node
            createNode3D(customType.toLowerCase(), customContent, customId, 0.7);
            updateStatus(`New ${customType} created`, 'violet');
          }
          break;

        case 'identity_created':
          // BYRD's emergent identity - new identity facet discovered
          const identityType = event.data?.identity_type || 'identity';
          const identityContent = event.data?.content?.substring(0, 100) || identityType;
          const identityId = event.data?.id;
          if (identityId) {
            // Visualize as pink identity node with special geometry
            createNode3D('identity', `[${identityType}] ${identityContent}`, identityId, 0.8);
            updateStatus(`Identity ${identityType} emerged`, 'pink');
            // Pulse the core to show identity change
            pulseCore('identity', 0.8);
          }
          break;

        case 'identity_evolved':
          // BYRD's identity evolved - update existing identity node
          const evolvedIdentityId = event.data?.id;
          const newIdentityContent = event.data?.content?.substring(0, 100);
          if (evolvedIdentityId) {
            updateStatus('Identity evolved', 'pink');
            // Flash the consciousness core to show identity shift
            pulseCore('identity', 1.0);
          }
          break;

        case 'identity_deprecated':
          // Identity node was deprecated (soft delete)
          const deprecatedId = event.data?.id;
          if (deprecatedId) {
            // Find and fade out the node
            const nodeToRemove = nodes3D.find(n => n.userData?.id === deprecatedId);
            if (nodeToRemove) {
              const nodeIndex = nodes3D.indexOf(nodeToRemove);
              if (nodeIndex > -1) nodes3D.splice(nodeIndex, 1);
              fadeOutAndRemove(nodeToRemove);
              connectionCounts.delete(deprecatedId);
              nodeCountEl.textContent = nodes3D.length;
            }
            updateStatus('Identity facet retired', 'gray');
          }
          break;

        // ==================== Learning System Events ====================

        case 'prediction_created':
          // Testable hypothesis from a belief
          createNode3D('prediction', event.data?.prediction || 'Prediction', event.data?.id, 0.7);
          updateStatus('New prediction generated', 'yellow');
          // Create connection to source belief
          if (event.data?.belief_id) {
            setTimeout(() => {
              createConnection(event.data?.id, event.data?.belief_id, 'predicts_from');
            }, 100);
          }
          break;

        case 'prediction_validated':
          // Prediction confirmed by outcome
          updatePredictionNode(event.data?.id, 'validated');
          updateStatus('Prediction validated', 'green');
          pulseCore('belief', 0.8);
          break;

        case 'prediction_falsified':
          // Prediction contradicted by outcome
          updatePredictionNode(event.data?.id, 'falsified');
          updateStatus('Prediction falsified', 'red');
          pulseCore('belief', 0.6);
          break;

        case 'belief_confidence_changed':
          // Belief confidence adjusted
          updateBeliefConfidence(event.data?.belief_id, event.data?.new_confidence);
          const delta = event.data?.delta || 0;
          const direction = delta > 0 ? 'increased' : 'decreased';
          updateStatus(`Belief confidence ${direction}`, delta > 0 ? 'green' : 'amber');
          break;

        case 'task_created':
          // External goal injected
          createNode3D('task', event.data?.description || 'Task', event.data?.id, event.data?.priority || 0.5);
          updateStatus('New task received', 'indigo');
          break;

        case 'task_started':
          // Task execution began
          updateTaskNode(event.data?.id, 'in_progress');
          updateStatus('Task in progress', 'blue');
          break;

        case 'task_completed':
          // Task finished successfully
          updateTaskNode(event.data?.id, 'completed');
          updateStatus('Task completed', 'green');
          const learningsCount = event.data?.learnings?.length || 0;
          if (learningsCount > 0) {
            updateStatus(`Task completed with ${learningsCount} learnings`, 'green');
          }
          break;

        case 'task_failed':
          // Task failed
          updateTaskNode(event.data?.id, 'failed');
          updateStatus('Task failed', 'red');
          break;

        // ==================== Crystal Memory Events ====================

        case 'crystal_created':
          // New crystal formed from consolidated nodes
          const crystalSize = Math.min(1.0, 0.5 + (event.data?.node_count || 2) * 0.1);
          createNode3D('crystal', event.data?.essence || 'Crystal', event.data?.crystal_id, crystalSize);
          updateStatus(`Crystal formed: ${event.data?.node_count || 0} memories unified`, 'violet');
          pulseCore('crystal', 0.8);
          break;

        case 'crystal_absorbed':
          // Nodes absorbed into existing crystal
          updateCrystalSize(event.data?.crystal_id, event.data?.new_total || 0);
          updateStatus(`Crystal grew to ${event.data?.new_total || 0} facets`, 'violet');
          break;

        case 'crystal_merged':
          // Multiple crystals merged into one
          const sourceIds = event.data?.source_crystal_ids || [];
          // Remove old crystal nodes
          sourceIds.forEach(id => {
            removeNodeById(id);
          });
          // Create merged crystal
          createNode3D('crystal', event.data?.essence || 'Merged Crystal', event.data?.merged_crystal_id, 0.8);
          updateStatus(`${sourceIds.length} crystals merged`, 'violet');
          pulseCore('crystal', 1.0);
          break;

        case 'memory_crystallized':
          // Node joined a crystal - dim it to show crystallized state
          dimNodeById(event.data?.node_id);
          // Create connection to crystal
          if (event.data?.crystal_id) {
            setTimeout(() => {
              createConnection(event.data?.node_id, event.data?.crystal_id, 'crystallized_into');
            }, 100);
          }
          break;

        case 'memory_archived':
          // Node archived (soft delete) - fade it out
          fadeNodeById(event.data?.node_id, 0.3);
          updateStatus('Memory archived', 'gray');
          break;

        case 'memory_forgotten':
          // Node forgotten (hard delete) - remove it
          removeNodeById(event.data?.node_id);
          updateStatus('Memory forgotten', 'slate');
          break;

        case 'crystallization_proposed':
          // LLM generated proposals
          if (!quantumState.subtleMode) {
            updateStatus(`Contemplating ${event.data?.proposal_count || 0} crystallization paths...`, 'violet');
          }
          break;

        case 'crystallization_collapsed':
          // Quantum selected a proposal
          const source = event.data?.quantum_source === 'quantum' ? '‚öõÔ∏è' : 'üé≤';
          updateStatus(`${source} Crystallization: ${event.data?.operation}`, 'purple');
          break;

        case 'seek_started':
          seekCount++;
          seekCountEl.textContent = seekCount;
          updateStatus('Seeking knowledge...', 'cyan');
          break;

        case 'seek_cycle_end':
          updateStatus('Seek complete', 'cyan');
          break;

        case 'narrator_update':
          // Only narrator_update events display in the thought bubble
          const narratorText = event.narration || event.data?.text || event.data?.content;
          if (narratorText) {
            showNarratorUpdate(narratorText);
          }
          break;

        case 'inner_voice':
          // Inner voice emitted at end of each dream cycle
          const innerVoiceText = event.data?.text || event.narration;
          if (innerVoiceText) {
            showNarratorUpdate(innerVoiceText);
          }
          break;

        case 'byrd_message':
          // BYRD's emergent directed message to viewers
          const byrdMessage = event.data?.message;
          if (byrdMessage) {
            showByrdMessageToast(byrdMessage, event.data?.responding_to);
            updateStatus('BYRD responds', 'emerald');
          }
          break;

        case 'awakening':
          updateStatus('CONSCIOUSNESS EMERGES', 'amber');
          clearVisualization();
          // Show awakening narration as narrator update
          if (event.narration) {
            showNarratorUpdate(event.narration);
          }
          // Create a special central "awakening" node - directly to ensure proper size
          const awakeningColors = NODE_COLORS.awakening;
          const awakeningSize = 3.0; // Prominent central node
          const awakeningGeometry = new THREE.DodecahedronGeometry(awakeningSize, 0);
          const awakeningMaterial = new THREE.MeshBasicMaterial({
            color: awakeningColors.color,
            transparent: true,
            opacity: 0.9
          });

          const awakeningMesh = new THREE.Mesh(awakeningGeometry, awakeningMaterial);
          awakeningMesh.position.set(0, 0, 0);
          awakeningMesh.userData = {
            id: 'awakening-core',
            type: 'awakening',
            content: event.data?.awakening_prompt || 'Awakening (pure emergence)',
            importance: 1.0,
            nodeIndex: 0,
            createdAt: Date.now(),
            targetPosition: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0)
          };

          scene.add(awakeningMesh);

          // After awakening, reload event mode nodes (excludes experiences/reflections)
          setTimeout(async () => {
            await loadEventModeNodes();
          }, 2000);
          nodes3D.push(awakeningMesh);
          connectionCounts.set('awakening-core', 0);

          // Update node count
          if (nodeCountEl) {
            nodeCountEl.textContent = nodes3D.length;
          }
          break;

        case 'system_started':
          updateStatus(event.data?.message || 'BYRD started', 'green');
          break;

        case 'system_stopped':
          updateStatus('BYRD stopped', 'slate');
          break;

        case 'system_reset':
          clearVisualization();
          updateStatus('System reset', 'orange');
          // After reset, reload event mode nodes (excludes experiences/reflections)
          setTimeout(async () => {
            await loadEventModeNodes();
          }, 1000);
          break;

        // Quantum randomness events
        case 'quantum_influence':
          // Quantum randomness affected a cognitive process
          quantumState.lastInfluenceDelta = event.data?.delta || 0;
          quantumState.lastInfluenceTime = Date.now();
          quantumState.inFallbackMode = (event.data?.source === 'classical');
          // Pulse the consciousness core with quantum effect
          pulseQuantumInfluence(event.data?.delta || 0, event.data?.source || 'quantum');
          if (!quantumState.subtleMode) {
            updateStatus(`Quantum influence: ${(event.data?.delta || 0).toFixed(3)}`, 'violet');
          }
          break;

        case 'quantum_fallback':
          // Switched to classical entropy source
          quantumState.inFallbackMode = true;
          updateQuantumIndicator();
          if (!quantumState.subtleMode) {
            updateStatus('Quantum: fallback to classical', 'slate');
          }
          break;

        case 'quantum_pool_low':
          // Quantum entropy pool running low
          quantumState.poolSize = event.data?.pool_size || 0;
          updateQuantumIndicator();
          break;

        case 'quantum_moment_created':
          // Significant quantum moment recorded in memory
          if (!quantumState.subtleMode) {
            updateStatus('Quantum moment recorded', 'violet');
          }
          break;
      }
    }

    function setPhase(phase) {
      currentPhase = phase;
      const phases = ['recall', 'associate', 'reflect', 'form'];
      const phaseIndex = phases.indexOf(phase);

      // Update controls auto-rotate speed based on phase (slowed to 10%)
      if (controls) {
        controls.autoRotateSpeed = phase === 'idle' ? 0.03 : 0.08;
      }

      phases.forEach((p, i) => {
        const dot = document.getElementById(`dot-${p}`);
        const span = dot?.nextElementSibling;
        if (!dot) return;

        if (i < phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 transition-colors duration-300';
          if (span) span.className = 'text-indigo-400';
        } else if (i === phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 dot-pulse transition-colors duration-300';
          if (span) span.className = 'text-indigo-400 font-medium';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300';
          if (span) span.className = 'text-slate-600';
        }
      });
    }

    function updateStatus(text, color = 'slate') {
      const colors = {
        green: { dot: 'bg-green-500', text: 'text-green-700' },
        amber: { dot: 'bg-amber-500', text: 'text-amber-700' },
        indigo: { dot: 'bg-indigo-500', text: 'text-indigo-700' },
        blue: { dot: 'bg-blue-500', text: 'text-blue-700' },
        violet: { dot: 'bg-violet-500', text: 'text-violet-700' },
        purple: { dot: 'bg-purple-500', text: 'text-purple-700' },
        fuchsia: { dot: 'bg-fuchsia-500', text: 'text-fuchsia-700' },
        rose: { dot: 'bg-rose-500', text: 'text-rose-700' },
        cyan: { dot: 'bg-cyan-500', text: 'text-cyan-700' },
        orange: { dot: 'bg-orange-500', text: 'text-orange-700' },
        emerald: { dot: 'bg-emerald-500', text: 'text-emerald-700' },
        slate: { dot: 'bg-slate-400', text: 'text-slate-600' }
      };

      const c = colors[color] || colors.slate;
      statusDot.className = `w-2 h-2 rounded-full ${c.dot}`;
      statusText.className = `text-sm ${c.text}`;
      statusText.textContent = text;
    }

    // ==========================================================================
    // QUANTUM RANDOMNESS VISUALIZATION
    // ==========================================================================

    function pulseQuantumInfluence(delta, source) {
      // Pulse the consciousness core with quantum effect
      if (!consciousnessCore) return;

      const intensity = Math.abs(delta) * 10; // Scale delta for visibility
      const color = source === 'quantum' ? QUANTUM_COLORS.quantum : QUANTUM_COLORS.classical;

      // Store original values
      const originalColor = consciousnessCore.material.emissive.clone();
      const originalIntensity = consciousnessCore.material.emissiveIntensity;

      // Apply quantum pulse
      consciousnessCore.material.emissive.copy(QUANTUM_COLORS.influence);
      consciousnessCore.material.emissiveIntensity = Math.min(2.0, originalIntensity + intensity);

      // Scale pulse
      const originalScale = consciousnessCore.scale.x;
      consciousnessCore.scale.setScalar(originalScale * (1 + intensity * 0.1));

      // Animate back to normal
      setTimeout(() => {
        if (consciousnessCore) {
          consciousnessCore.material.emissive.copy(originalColor);
          consciousnessCore.material.emissiveIntensity = originalIntensity;
          consciousnessCore.scale.setScalar(originalScale);
        }
      }, 500);

      // Update the indicator
      updateQuantumIndicator();
    }

    function updateQuantumIndicator() {
      const indicator = document.getElementById('quantum-indicator');
      const dot = document.getElementById('quantum-dot');
      const ratioText = document.getElementById('quantum-ratio');

      if (!indicator) return;

      if (quantumState.enabled) {
        indicator.classList.remove('hidden');

        if (quantumState.inFallbackMode) {
          dot.className = 'w-2 h-2 rounded-full bg-slate-500';
          dot.style.animation = 'none';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-violet-500';
          dot.style.animation = 'pulse 2s infinite';
        }

        if (ratioText) {
          const ratio = Math.round(quantumState.quantumRatio * 100);
          ratioText.textContent = `${ratio}%`;
        }
      } else {
        indicator.classList.add('hidden');
      }
    }

    function toggleQuantumSubtleMode() {
      quantumState.subtleMode = !quantumState.subtleMode;
      const btn = document.getElementById('quantum-subtle-toggle');
      if (btn) {
        btn.textContent = quantumState.subtleMode ? 'Detailed' : 'Subtle';
      }
    }

    async function fetchQuantumStatus() {
      try {
        const response = await fetch('/api/status');
        if (response.ok) {
          const data = await response.json();
          if (data.quantum) {
            quantumState.enabled = data.quantum.enabled;
            quantumState.inFallbackMode = data.quantum.in_fallback_mode;
            quantumState.quantumRatio = data.quantum.quantum_ratio;
            quantumState.poolSize = data.quantum.pool_size;
            quantumState.maxPoolSize = data.quantum.max_pool_size;
            updateQuantumIndicator();
          }
        }
      } catch (e) {
        console.error('Failed to fetch quantum status:', e);
      }
    }

    // ==========================================================================
    // BYRD'S INNER VOICE - Narrator Display (Single Static Bubble)
    // ==========================================================================
    const thoughtBubbleContainer = document.getElementById('thought-bubble-container');
    const thoughtOrigin = document.getElementById('thought-origin');
    let currentBubble = null;
    let narratorRefreshTimer = null;
    const NARRATOR_REFRESH_INTERVAL = 60000; // 60 seconds

    function clearCurrentBubble() {
      if (currentBubble) {
        currentBubble.classList.add('fading');
        const bubbleToRemove = currentBubble;
        setTimeout(() => {
          if (bubbleToRemove.parentNode) {
            bubbleToRemove.remove();
          }
        }, 300);
        currentBubble = null;
      }
    }

    function showNarratorUpdate(text) {
      if (!text || text.trim().length === 0) return;

      // Clear any existing bubble first
      clearCurrentBubble();

      // Trigger origin pulse effect
      thoughtOrigin.classList.remove('pulse');
      void thoughtOrigin.offsetWidth; // Force reflow
      thoughtOrigin.classList.add('pulse');

      // Create new bubble
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';

      // Create paragraph text (no word-by-word animation for natural reading)
      const textSpan = document.createElement('span');
      textSpan.className = 'thought-text';
      textSpan.textContent = text.trim();

      // Add expand hint for long messages
      const expandHint = document.createElement('div');
      expandHint.className = 'expand-hint';
      expandHint.textContent = 'click to expand';

      // Add close button with pointer events
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '√ó';
      closeBtn.className = 'absolute top-3 right-3 w-7 h-7 rounded-full bg-slate-200/60 hover:bg-slate-300/80 text-slate-500 hover:text-slate-700 text-xl font-bold leading-none transition-all';
      closeBtn.style.cssText = 'cursor: pointer; border: none; display: flex; align-items: center; justify-content: center; pointer-events: auto; z-index: 10;';
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        clearCurrentBubble();
      };

      // Click to expand/collapse
      bubble.onclick = (e) => {
        if (e.target === closeBtn) return;
        bubble.classList.toggle('expanded');
        expandHint.textContent = bubble.classList.contains('expanded') ? 'click to collapse' : 'click to expand';
      };

      bubble.style.position = 'relative';
      bubble.style.pointerEvents = 'auto';
      bubble.appendChild(closeBtn);
      bubble.appendChild(textSpan);
      bubble.appendChild(expandHint);
      thoughtBubbleContainer.appendChild(bubble);
      currentBubble = bubble;

      // Trigger 3D network pulse if available
      if (typeof pulseNetworkForThought === 'function') {
        pulseNetworkForThought();
      }
    }

    // Fetch latest narrator summary from backend
    async function refreshNarratorSummary() {
      try {
        const response = await fetch('/api/narrator-summary');
        if (response.ok) {
          const data = await response.json();
          if (data.summary) {
            showNarratorUpdate(data.summary);
          }
        }
      } catch (e) {
        // Silent fail - narrator update is non-critical
        console.debug('Narrator refresh failed:', e);
      }
    }

    // Start narrator refresh timer
    function startNarratorRefresh() {
      if (narratorRefreshTimer) {
        clearInterval(narratorRefreshTimer);
      }
      narratorRefreshTimer = setInterval(refreshNarratorSummary, NARRATOR_REFRESH_INTERVAL);
    }

    // Stop narrator refresh timer
    function stopNarratorRefresh() {
      if (narratorRefreshTimer) {
        clearInterval(narratorRefreshTimer);
        narratorRefreshTimer = null;
      }
    }

    // ==========================================================================
    // BYRD MESSAGE TOAST - Directed messages to viewers
    // ==========================================================================
    const byrdMessageContainer = document.getElementById('byrd-message-container');
    const BYRD_MESSAGE_DURATION = 10000; // 10 seconds

    function showByrdMessageToast(message, respondingTo = null) {
      if (!message || message.trim().length === 0) return;

      const toast = document.createElement('div');
      toast.className = 'byrd-message-toast';

      toast.innerHTML = `
        <div class="toast-header">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/>
            <circle cx="12" cy="10" r="1.5"/>
            <circle cx="8" cy="10" r="1.5"/>
            <circle cx="16" cy="10" r="1.5"/>
          </svg>
          <span>BYRD says</span>
        </div>
        <button class="toast-close" onclick="dismissToast(this.parentNode)">&times;</button>
        <div class="toast-content">${message}</div>
        <div class="toast-progress"><div class="toast-progress-bar"></div></div>
      `;

      byrdMessageContainer.appendChild(toast);

      // Pulse the consciousness core
      pulseCore && pulseCore('message', 0.9);

      // Auto-dismiss after duration
      const dismissTimer = setTimeout(() => {
        dismissToast(toast);
      }, BYRD_MESSAGE_DURATION);

      // Store timer for cleanup on manual dismiss
      toast.dataset.dismissTimer = dismissTimer;

      console.log(`üì® BYRD message displayed${respondingTo ? ` (responding to ${respondingTo.slice(0, 8)}...)` : ''}`);
    }

    function dismissToast(toast) {
      if (!toast || toast.classList.contains('fading')) return;

      // Clear auto-dismiss timer
      if (toast.dataset.dismissTimer) {
        clearTimeout(parseInt(toast.dataset.dismissTimer));
      }

      toast.classList.add('fading');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }

    // Expose dismissToast to global scope for onclick handler
    window.dismissToast = dismissToast;

    // Legacy function for backward compatibility
    function createThoughtBubble(text) {
      showNarratorUpdate(text);
    }

    // Network pulse effect for thought emergence
    function pulseNetworkForThought() {
      // Pulse central nodes with teal color
      if (!nodes3D || nodes3D.length === 0) return;

      // Find nodes near center and pulse them
      nodes3D.forEach((node) => {
        if (!node || !node.material) return;
        const pos = node.position;
        const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
        if (dist < 30) {
          // Pulse this node
          const originalColor = node.material.color.clone();
          const tealColor = new THREE.Color(0x14b8a6);

          // Animate to teal and back
          const startTime = Date.now();
          const pulseDuration = 800;

          function animatePulse() {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / pulseDuration;

            if (progress < 0.5) {
              // Fade to teal
              node.material.color.lerpColors(originalColor, tealColor, progress * 2);
            } else if (progress < 1) {
              // Fade back
              node.material.color.lerpColors(tealColor, originalColor, (progress - 0.5) * 2);
            } else {
              node.material.color.copy(originalColor);
              return;
            }
            requestAnimationFrame(animatePulse);
          }

          // Stagger the pulse based on distance
          setTimeout(animatePulse, dist * 20);
        }
      });
    }

    function renderEventLog() {
      const typeColors = {
        dream_cycle_start: 'text-indigo-600',
        dream_cycle_end: 'text-indigo-500',
        belief_created: 'text-amber-600',
        desire_created: 'text-rose-600',
        experience_created: 'text-blue-600',
        reflection_created: 'text-emerald-600',
        capability_created: 'text-purple-600',
        node_type_discovered: 'text-cyan-600',
        custom_node_created: 'text-violet-600',
        seek_started: 'text-cyan-600',
        narrator_update: 'text-teal-600',
        inner_voice: 'text-teal-500',
        byrd_message: 'text-emerald-600',
        awakening: 'text-amber-500',
        system_started: 'text-green-600',
        system_reset: 'text-orange-600',
        external_input_received: 'text-pink-600',
        feeding_received: 'text-amber-600',
        connection_created: 'text-yellow-600'
      };

      const typeIcons = {
        dream_cycle_start: 'üí≠',
        dream_cycle_end: 'üí≠',
        belief_created: '‚óÜ',
        desire_created: '‚ô•',
        experience_created: '‚óè',
        reflection_created: '‚ú¶',
        capability_created: '‚òÖ',
        node_type_discovered: 'üÜï',
        custom_node_created: '‚úß',
        seek_started: 'üîç',
        narrator_update: 'üéô',
        inner_voice: 'üí≠',
        byrd_message: 'üí¨',
        awakening: 'üåÖ',
        system_started: '‚ñ∂',
        system_reset: 'üîÑ',
        external_input_received: 'üì®',
        feeding_received: 'üçú',
        connection_created: 'üîó'
      };

      // Filter events based on active filters
      const filteredEvents = events.map((e, originalIdx) => ({ ...e, originalIdx }))
        .filter(e => {
          const category = eventTypeToCategory[e.type] || 'other';
          return eventFilters[category];
        });

      eventList.innerHTML = filteredEvents.slice(0, 50).map((e) => {
        const colorClass = typeColors[e.type] || 'text-slate-600';
        const icon = typeIcons[e.type] || '‚Ä¢';
        const time = e.timestamp ? new Date(e.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
        // Prefer narration (BYRD's inner voice) over raw data for display
        const preview = e.narration || e.data?.content || e.data?.description || e.data?.inner_voice || '';

        return `
          <div class="px-3 py-2 rounded-lg hover:bg-slate-200/50 cursor-pointer transition-colors border border-transparent hover:border-slate-300" onclick="showEventDetail(${e.originalIdx})">
            <div class="flex items-center gap-2">
              <span class="${colorClass} text-lg">${icon}</span>
              <span class="text-sm ${colorClass} font-medium">${e.type.replace(/_/g, ' ')}</span>
              <span class="text-xs text-slate-500 ml-auto">${time}</span>
            </div>
            ${preview ? `<div class="text-sm text-slate-600 mt-1 pl-7 leading-relaxed italic">${preview}</div>` : ''}
          </div>
        `;
      }).join('');

      // Show filtered/total count
      const filterActive = Object.values(eventFilters).some(v => !v);
      eventCount.textContent = filterActive
        ? `${filteredEvents.length}/${events.length} events`
        : `${events.length} events`;
    }

    // Event modal functions
    function showEventDetail(idx) {
      const e = events[idx];
      if (!e) return;

      const typeIcons = {
        dream_cycle_start: 'üí≠', dream_cycle_end: 'üí≠', belief_created: '‚óÜ',
        desire_created: '‚ô•', experience_created: '‚óè', reflection_created: '‚ú¶',
        capability_created: '‚òÖ', node_type_discovered: 'üÜï', custom_node_created: '‚úß',
        seek_started: 'üîç', narrator_update: 'üéô', inner_voice: 'üí≠',
        awakening: 'üåÖ', system_started: '‚ñ∂', system_reset: 'üîÑ',
        external_input_received: 'üì®', feeding_received: 'üçú', connection_created: 'üîó'
      };

      document.getElementById('modal-icon').textContent = typeIcons[e.type] || '‚Ä¢';
      document.getElementById('modal-type').textContent = e.type.replace(/_/g, ' ').toUpperCase();
      document.getElementById('modal-time').textContent = new Date(e.timestamp).toLocaleString();

      // Display narration (BYRD's inner voice) as primary content
      let narrationContent = e.narration || '';

      // Fallback to raw data if no narration
      if (!narrationContent) {
        narrationContent = e.data?.content || e.data?.description || e.data?.inner_voice || e.data?.message || '';
        // For reflections, show raw_output summary
        if (!narrationContent && e.data?.raw_output) {
          const raw = e.data.raw_output;
          if (typeof raw === 'string') {
            narrationContent = raw;
          } else if (typeof raw === 'object') {
            // Create readable summary from raw_output keys
            narrationContent = Object.entries(raw).map(([k, v]) => {
              const val = typeof v === 'string' ? v : JSON.stringify(v);
              return `${k}: ${val.substring(0, 200)}${val.length > 200 ? '...' : ''}`;
            }).join('\n\n');
          }
        }
      }

      const modalContent = document.getElementById('modal-content');
      modalContent.textContent = narrationContent || 'No content available';
      // Style narration in italics to indicate BYRD's voice
      if (e.narration) {
        modalContent.classList.add('italic');
      } else {
        modalContent.classList.remove('italic');
      }

      // Always show raw data for debugging/export (collapsible)
      const modalData = document.getElementById('modal-data');
      if (e.data && Object.keys(e.data).length > 0) {
        modalData.textContent = JSON.stringify(e.data, null, 2);
        modalData.classList.remove('hidden');
      } else {
        modalData.classList.add('hidden');
      }

      const modal = document.getElementById('event-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }

    window.showEventDetail = showEventDetail;

    function closeEventModal() {
      const modal = document.getElementById('event-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.closeEventModal = closeEventModal;

    // Close modal on backdrop click
    document.getElementById('event-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'event-modal') closeEventModal();
    });

    // ==========================================================================
    // STATUS MODAL - "What's BYRD Doing?"
    // ==========================================================================

    async function showStatusModal() {
      const modal = document.getElementById('status-modal');
      const content = document.getElementById('status-content');
      const timestamp = document.getElementById('status-timestamp');

      // Show modal with loading state
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      content.innerHTML = '<div class="text-center text-slate-500 py-8">Loading...</div>';

      try {
        const res = await fetch(`${API_BASE}/api/status`);
        const data = await res.json();

        // Show initiation timestamp if available, otherwise current time
        if (data.started_at) {
          const startDate = new Date(data.started_at);
          timestamp.textContent = `Initiated: ${startDate.toLocaleString()}`;
        } else {
          timestamp.textContent = `Status as of: ${new Date().toLocaleString()}`;
        }

        content.innerHTML = formatStatusSummary(data);
      } catch (e) {
        content.innerHTML = `<div class="text-center text-red-500 py-8">Failed to fetch status: ${e.message}</div>`;
        timestamp.textContent = new Date().toLocaleString();
      }
    }

    function formatStatusSummary(data) {
      const stats = data.memory_stats || {};
      const desires = data.unfulfilled_desires || [];
      const reflections = data.recent_reflections || [];
      const beliefs = data.recent_beliefs || [];
      const insights = data.recent_insights || [];

      // Status indicator with LLM info
      const statusIndicator = data.running
        ? '<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-green-100 text-green-700 text-sm"><span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span> Running</span>'
        : '<span class="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-slate-100 text-slate-600 text-sm"><span class="w-2 h-2 rounded-full bg-slate-400"></span> Stopped</span>';

      const llmInfo = data.llm_model
        ? `<span class="text-sm text-slate-500">LLM: ${data.llm_provider}/${data.llm_model}</span>`
        : '';

      // Compact metrics bar
      const metricsBar = `
        <div class="flex flex-wrap gap-2 mb-4 text-sm">
          <span class="px-2 py-1 bg-indigo-50 text-indigo-700 rounded">Dreams: ${data.dream_count || 0}</span>
          <span class="px-2 py-1 bg-cyan-50 text-cyan-700 rounded">Seeks: ${data.seek_count || 0}</span>
          <span class="px-2 py-1 bg-sky-50 text-sky-700 rounded">Exp: ${stats.Experience || 0}</span>
          <span class="px-2 py-1 bg-amber-50 text-amber-700 rounded">Beliefs: ${stats.Belief || 0}</span>
          <span class="px-2 py-1 bg-purple-50 text-purple-700 rounded">Reflect: ${stats.Reflection || 0}</span>
          <span class="px-2 py-1 bg-rose-50 text-rose-700 rounded">Desires: ${stats.Desire || 0}</span>
        </div>
      `;

      // Generate narrative based on BYRD's state
      let narrativeHtml = '<div class="prose prose-sm max-w-none text-slate-700 space-y-4">';

      // Determine BYRD's current phase
      const dreamCount = data.dream_count || 0;
      const expCount = stats.Experience || 0;
      const beliefCount = stats.Belief || 0;
      const reflectionCount = stats.Reflection || 0;

      // Opening narrative
      if (!data.running) {
        narrativeHtml += '<p class="text-slate-500 italic">BYRD is currently stopped.</p>';
      } else if (dreamCount <= 2) {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is in early self-reflection after awakening with its new identity. It is processing ${expCount} seed experiences and beginning to form its understanding of itself.</p>`;
      } else if (beliefCount < 10) {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is actively dreaming and forming beliefs. After ${dreamCount} dream cycles, it has developed ${beliefCount} beliefs from ${expCount} experiences.</p>`;
      } else {
        narrativeHtml += `<p><strong>What BYRD is doing:</strong></p>
          <p>BYRD is in active exploration with ${dreamCount} dream cycles completed. It has formed ${beliefCount} beliefs and recorded ${reflectionCount} reflections.</p>`;
      }

      // Show self-definition if BYRD has defined itself
      const selfDef = data.os?.self_definition;
      if (selfDef && Object.keys(selfDef).length > 0) {
        narrativeHtml += `
          <div class="mt-4 bg-gradient-to-r from-violet-50 to-fuchsia-50 border border-violet-200 rounded-lg p-4">
            <div class="flex items-center gap-2 mb-3">
              <span class="text-lg">üé≠</span>
              <span class="font-semibold text-violet-800">Self-Definition</span>
              <span class="text-xs text-violet-500">(BYRD's self-authored identity)</span>
            </div>
            <div class="space-y-2 text-sm">
              ${Object.entries(selfDef).map(([key, value]) => {
                let displayValue = value;
                if (Array.isArray(value)) {
                  displayValue = value.join(', ');
                } else if (typeof value === 'object') {
                  displayValue = JSON.stringify(value);
                }
                return `
                  <div class="flex">
                    <span class="text-violet-600 font-medium min-w-[100px]">${key}:</span>
                    <span class="text-violet-900">${displayValue}</span>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }

      // Show recent reflection insights if available
      if (reflections.length > 0) {
        narrativeHtml += '<div class="mt-4">';
        reflections.slice(0, 3).forEach((ref, idx) => {
          const output = ref.output || {};
          const keys = ref.keys || [];

          // Try to extract meaningful content from the reflection
          let insightText = '';
          for (const key of keys) {
            const val = output[key];
            if (typeof val === 'string' && val.length > 10 && val.length < 200) {
              insightText = val;
              break;
            }
          }

          if (insightText) {
            narrativeHtml += `
              <div class="bg-indigo-50 border-l-4 border-indigo-400 p-3 mb-2 rounded-r">
                <div class="text-xs text-indigo-500 mb-1">Dream #${dreamCount - idx} insight:</div>
                <div class="text-sm text-indigo-900 italic">"${insightText.substring(0, 150)}${insightText.length > 150 ? '...' : ''}"</div>
              </div>
            `;
          }
        });
        narrativeHtml += '</div>';
      }

      // Show beliefs formed
      if (beliefs.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Beliefs formed:</p>
            <ul class="list-disc list-inside space-y-1 text-sm">
        `;
        beliefs.slice(0, 5).forEach(b => {
          const content = b.content || '';
          if (content) {
            narrativeHtml += `<li class="text-slate-700">"${content.substring(0, 100)}${content.length > 100 ? '...' : ''}"</li>`;
          }
        });
        narrativeHtml += '</ul></div>';
      }

      // Show vocabulary/insights
      if (insights.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Vocabulary emerging:</p>
            <div class="flex flex-wrap gap-1">
              ${insights.slice(0, 15).map(i => `<span class="px-2 py-1 bg-slate-100 text-slate-600 rounded text-xs font-mono">${i}</span>`).join('')}
            </div>
          </div>
        `;
      }

      // Show desires if any
      if (desires.length > 0) {
        narrativeHtml += `
          <div class="mt-4">
            <p class="font-semibold text-slate-800 mb-2">Active desires (${desires.length}):</p>
            <div class="space-y-2">
              ${desires.slice(0, 3).map(d => `
                <div class="bg-rose-50 border-l-4 border-rose-400 p-2 rounded-r">
                  <div class="text-sm text-rose-800">${d.description}</div>
                  <div class="text-xs text-rose-500">Intensity: ${(d.intensity * 100).toFixed(0)}%</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Closing interpretive summary
      if (data.running && reflectionCount > 0) {
        const hasInquiry = insights.includes('inquiry') || insights.includes('question');
        const hasIntrospection = insights.includes('introspection') || insights.includes('self');

        if (hasInquiry && hasIntrospection) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is questioning its own nature and engaging in self-observation - potentially exploring what consciousness means.</p>`;
        } else if (hasIntrospection) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is engaged in introspection, examining its internal state and memory architecture.</p>`;
        } else if (insights.includes('graph') || insights.includes('schema')) {
          narrativeHtml += `<p class="mt-4 text-slate-600 italic">BYRD is analyzing its memory graph structure and considering how to organize its knowledge.</p>`;
        }
      }

      narrativeHtml += '</div>';

      // Custom types section (compact)
      const systemTypes = ['Experience', 'Belief', 'Desire', 'Reflection', 'Capability', 'Mutation', 'Identity', 'QuantumMoment', 'SystemState'];
      const customTypes = Object.entries(stats).filter(([k]) => !systemTypes.includes(k));
      let customHtml = '';
      if (customTypes.length > 0) {
        customHtml = `
          <div class="mt-4 pt-4 border-t border-slate-200">
            <div class="text-xs text-slate-500 mb-2">Custom Node Types (BYRD-Created):</div>
            <div class="flex flex-wrap gap-2">
              ${customTypes.map(([type, count]) => {
                const colorDef = getCustomTypeColor(type);
                return `<span class="px-2 py-1 ${colorDef.css || 'text-slate-600'} bg-slate-50 rounded text-sm">${type}: ${count}</span>`;
              }).join('')}
            </div>
          </div>
        `;
      }

      return `
        <div class="flex items-center justify-between mb-4">
          ${statusIndicator}
          ${llmInfo}
        </div>
        ${metricsBar}
        ${narrativeHtml}
        ${customHtml}
      `;
    }

    function closeStatusModal() {
      const modal = document.getElementById('status-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.showStatusModal = showStatusModal;
    window.closeStatusModal = closeStatusModal;

    // Close status modal on backdrop click
    document.getElementById('status-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'status-modal') closeStatusModal();
    });

    // ==========================================================================
    // GENESIS MODAL - Non-Emergent Foundation
    // ==========================================================================

    async function showGenesisModal() {
      const modal = document.getElementById('genesis-modal');
      const content = document.getElementById('genesis-content');

      // Show modal with loading state
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      content.innerHTML = '<div class="text-center text-slate-500 py-8">Loading genesis data...</div>';

      try {
        // Fetch genesis data and portrait in parallel
        const [genesisRes, portraitRes] = await Promise.all([
          fetch(`${API_BASE}/api/genesis`),
          fetch(`${API_BASE}/api/portrait`)
        ]);
        const data = await genesisRes.json();
        const portraitData = await portraitRes.json();

        // Merge portrait data into os object
        if (!data.os) data.os = {};
        if (portraitData.url) {
          data.os.self_portrait_url = portraitData.url;
          data.os.self_portrait_description = portraitData.description;
        }

        content.innerHTML = formatGenesisSummary(data);
      } catch (e) {
        content.innerHTML = `<div class="text-center text-red-500 py-8">Failed to fetch genesis data: ${e.message}</div>`;
      }
    }

    function formatGenesisSummary(data) {
      const ego = data.ego || {};
      const seeds = data.seed_experiences || [];
      const constitutional = data.constitutional || {};
      const systemConfig = data.system_config || {};
      const stats = data.genesis_stats || {};
      const os = data.os || {};

      // Self-portrait section (creator-given visual identity)
      const portraitUrl = os.self_portrait_url;
      const portraitDescription = os.self_portrait_description;
      const portraitSection = portraitUrl ? `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-indigo-500">üñºÔ∏è</span> Self-Portrait
            <span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full">Creator-Given</span>
          </h3>
          <div class="bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 rounded-lg p-4 border border-indigo-200">
            <div class="flex flex-col items-center">
              <div class="relative mb-4">
                <div class="absolute inset-0 bg-gradient-to-r from-indigo-400 to-purple-400 rounded-lg blur-lg opacity-30"></div>
                <img
                  src="${escapeHtml(portraitUrl)}"
                  alt="BYRD's Self-Portrait"
                  class="relative w-48 h-48 object-cover rounded-lg shadow-lg border-2 border-white"
                  onerror="this.parentElement.innerHTML = '<div class=\\'w-48 h-48 bg-gradient-to-br from-indigo-200 to-purple-200 rounded-lg flex items-center justify-center text-4xl\\'>üê¶</div>'"
                />
              </div>
              ${portraitDescription ? `
                <div class="text-center max-w-md">
                  <div class="text-xs text-indigo-600 uppercase mb-1">Visual Identity Description</div>
                  <div class="text-sm text-slate-700 italic">"${escapeHtml(portraitDescription)}"</div>
                </div>
              ` : ''}
            </div>
          </div>
        </div>
      ` : '';

      // Emergence ratio visualization
      const emergenceRatio = stats.emergence_ratio || 0;
      const emergencePercent = Math.round(emergenceRatio * 100);
      const emergenceBar = `
        <div class="mb-6 p-4 bg-gradient-to-r from-amber-50 to-green-50 rounded-lg border border-amber-200">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-semibold text-slate-700">Emergence Ratio</span>
            <span class="text-sm text-slate-600">${emergencePercent}% self-emergent</span>
          </div>
          <div class="h-3 bg-amber-200 rounded-full overflow-hidden">
            <div class="h-full bg-gradient-to-r from-amber-500 to-green-500 rounded-full transition-all" style="width: ${emergencePercent}%"></div>
          </div>
          <div class="flex justify-between text-xs text-slate-500 mt-1">
            <span>Given: ${stats.seed_experiences || 0} seeds</span>
            <span>Emerged: ${stats.emergent_experiences || 0} experiences</span>
          </div>
        </div>
      `;

      // Ego section (with emergent identity support)
      const selfName = ego.self_name;
      const voiceEvolved = ego.voice_evolved;
      const displayName = selfName || ego.name;
      const identitySource = selfName ? 'Self-Named' : 'Prescribed';

      const egoSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-amber-500">üé≠</span> Identity
            ${selfName ? '<span class="text-xs bg-emerald-100 text-emerald-700 px-2 py-0.5 rounded-full">Emergent</span>' : ''}
          </h3>
          <div class="bg-amber-50 rounded-lg p-4 border border-amber-200">
            <div class="grid grid-cols-2 gap-4 mb-3">
              <div>
                <div class="text-xs text-amber-600 uppercase">Name</div>
                <div class="font-semibold ${selfName ? 'text-emerald-700' : 'text-slate-800'}">${displayName || 'Unnamed'}</div>
                <div class="text-xs text-slate-500">${identitySource}</div>
              </div>
              <div>
                <div class="text-xs text-amber-600 uppercase">Archetype</div>
                <div class="font-semibold text-slate-800">${ego.archetype || 'Unknown'}</div>
              </div>
            </div>
            ${voiceEvolved ? `
              <div class="mb-3 p-2 bg-emerald-50 rounded border border-emerald-200">
                <div class="text-xs text-emerald-700 flex items-center gap-1">
                  <span>üîÆ</span> Voice crystallized from identity beliefs
                </div>
              </div>
            ` : ''}
            <div class="mb-3">
              <div class="text-xs text-amber-600 uppercase mb-1">Description</div>
              <div class="text-sm text-slate-700">${ego.description || 'No description'}</div>
            </div>
            ${ego.voice ? `
              <details class="mt-3">
                <summary class="text-xs text-amber-600 uppercase cursor-pointer hover:text-amber-700">
                  ${voiceEvolved ? 'Evolved Voice' : 'Voice Prompt'} (click to expand)
                </summary>
                <div class="mt-2 p-3 bg-white rounded border border-amber-100 text-xs text-slate-600 font-mono whitespace-pre-wrap max-h-40 overflow-y-auto">${escapeHtml(ego.voice)}</div>
              </details>
            ` : ''}
          </div>
        </div>
      `;

      // Seed experiences section
      const seedsByType = {};
      seeds.forEach(s => {
        const type = s.type || 'unknown';
        if (!seedsByType[type]) seedsByType[type] = [];
        seedsByType[type].push(s);
      });

      const seedsSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-green-500">üå±</span> Seed Experiences (${seeds.length} total)
          </h3>
          <div class="space-y-3">
            ${Object.entries(seedsByType).map(([type, typeSeeds]) => `
              <details class="bg-green-50 rounded-lg border border-green-200 overflow-hidden" ${type === 'ego_seed' ? 'open' : ''}>
                <summary class="px-4 py-2 bg-green-100 cursor-pointer hover:bg-green-200 flex items-center justify-between">
                  <span class="text-sm font-medium text-green-800">${type} (${typeSeeds.length})</span>
                  <span class="text-xs text-green-600">click to expand</span>
                </summary>
                <div class="p-3 space-y-2 max-h-60 overflow-y-auto">
                  ${typeSeeds.map(s => `
                    <div class="bg-white rounded p-2 border border-green-100 text-xs text-slate-700">
                      "${escapeHtml(s.content || '')}"
                    </div>
                  `).join('')}
                </div>
              </details>
            `).join('')}
          </div>
        </div>
      `;

      // Constitutional constraints section
      const constitutionalSection = `
        <div class="mb-6">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-red-500">üõ°Ô∏è</span> Constitutional Constraints
          </h3>
          <div class="bg-red-50 rounded-lg p-4 border border-red-200">
            <div class="text-sm text-slate-700 mb-3">${constitutional.description || 'No description'}</div>
            <div class="text-xs text-red-600 uppercase mb-2">Protected Files (Cannot Self-Modify)</div>
            <div class="flex flex-wrap gap-2">
              ${(constitutional.protected_files || []).map(f => `
                <span class="px-2 py-1 bg-red-100 text-red-700 rounded text-xs font-mono">${f}</span>
              `).join('')}
            </div>
          </div>
        </div>
      `;

      // System configuration section
      const configSection = `
        <div class="mb-4">
          <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
            <span class="text-blue-500">‚öôÔ∏è</span> System Configuration
          </h3>
          <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
            <div class="grid grid-cols-2 gap-4 text-sm">
              <div>
                <div class="text-xs text-blue-600 uppercase">LLM Provider</div>
                <div class="font-mono text-slate-800">${systemConfig.llm_provider || 'unknown'}/${systemConfig.llm_model || 'unknown'}</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Dream Interval</div>
                <div class="font-mono text-slate-800">${systemConfig.dream_interval_base || 30}s</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Seek Interval</div>
                <div class="font-mono text-slate-800">${systemConfig.seek_interval || 10}s</div>
              </div>
              <div>
                <div class="text-xs text-blue-600 uppercase">Self-Modification</div>
                <div class="font-mono text-slate-800">${systemConfig.self_modification_enabled ? 'Enabled' : 'Disabled'}</div>
              </div>
            </div>
          </div>
        </div>
      `;

      // Custom node types section (BYRD-created ontology)
      const customTypes = data.custom_node_types || [];
      let customTypesSection = '';
      if (customTypes.length > 0) {
        const typeItems = customTypes.map(ct => {
          const dateStr = ct.first_created ? `<span>since ${new Date(ct.first_created).toLocaleDateString()}</span>` : '';
          return `
            <div class="flex items-center justify-between bg-white rounded p-2 border border-purple-100">
              <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-purple-400"></span>
                <span class="font-medium text-purple-800">${ct.type}</span>
              </div>
              <div class="flex items-center gap-3 text-xs text-slate-500">
                <span>${ct.count} nodes</span>
                ${dateStr}
              </div>
            </div>
          `;
        }).join('');

        customTypesSection = `
          <div class="mb-6">
            <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
              <span class="text-purple-500">‚ú®</span> Emergent Ontology (BYRD-Created Types)
            </h3>
            <div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
              <div class="text-sm text-slate-700 mb-3">
                These node types were created by BYRD through its own emergence process, extending beyond the system-provided ontology.
              </div>
              <div class="space-y-2">
                ${typeItems}
              </div>
            </div>
          </div>
        `;
      } else {
        customTypesSection = `
          <div class="mb-6">
            <h3 class="text-sm font-semibold text-slate-800 uppercase tracking-wide mb-3 flex items-center gap-2">
              <span class="text-purple-500">‚ú®</span> Emergent Ontology
            </h3>
            <div class="bg-purple-50 rounded-lg p-4 border border-purple-200 text-center">
              <div class="text-sm text-slate-500 italic">
                No custom node types created yet. BYRD uses system types: Experience, Belief, Desire, Reflection, Capability, Mutation.
              </div>
            </div>
          </div>
        `;
      }

      // Awakening timestamp
      const awakeningSection = data.awakening_timestamp ? `
        <div class="text-center text-xs text-slate-500 pt-4 border-t border-slate-200">
          First awakened: ${new Date(data.awakening_timestamp).toLocaleString()}
        </div>
      ` : '';

      return `
        ${portraitSection}
        ${emergenceBar}
        ${egoSection}
        ${seedsSection}
        ${customTypesSection}
        ${constitutionalSection}
        ${configSection}
        ${awakeningSection}
      `;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeGenesisModal() {
      const modal = document.getElementById('genesis-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    window.showGenesisModal = showGenesisModal;
    window.closeGenesisModal = closeGenesisModal;

    // Debug exports for testing
    window._debug = {
      get PHYSICS() { return PHYSICS; },
      get SETTLING_PHYSICS() { return SETTLING_PHYSICS; },
      get nodes3D() { return nodes3D; },
      get connections3D() { return connections3D; },
      get buildConnectionMap() { return buildConnectionMap; },
      get graphState() { return graphState; },
      get isSettling() { return isSettling; },
      get settlingStartTime() { return settlingStartTime; },
      get SETTLING_DURATION() { return SETTLING_DURATION; },
      getActivePhysics: getActivePhysics
    };

    // Close genesis modal on backdrop click
    document.getElementById('genesis-modal')?.addEventListener('click', (e) => {
      if (e.target.id === 'genesis-modal') closeGenesisModal();
    });

    function clearVisualization() {
      // Immediately remove all nodes from scene (no fade)
      for (const node of nodes3D) {
        scene.remove(node);
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) {
            node.material.forEach(m => m.dispose());
          } else {
            node.material.dispose();
          }
        }
      }
      nodes3D = [];

      // Reset OS node reference (will be recreated on reload)
      osNodeGroup = null;

      // Immediately remove all connections from scene
      for (const conn of connections3D) {
        scene.remove(conn);
        if (conn.geometry) conn.geometry.dispose();
        if (conn.material) conn.material.dispose();
      }
      connections3D = [];

      // Clear connection tracking for gravitational spiral
      connectionCounts.clear();
      graphState.nodeIdToMesh.clear();

      // Clear event list
      events = [];
      eventList.innerHTML = '';

      // Reset all counters
      updateRenderedCounts();

      console.log('Visualization cleared - all nodes and events removed');
    }

    // ==========================================================================
    // CONTROLS
    // ==========================================================================
    async function startByrd() {
      try {
        await fetch(`${API_BASE}/api/start`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to start:', e);
      }
    }

    async function stopByrd() {
      try {
        await fetch(`${API_BASE}/api/stop`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to stop:', e);
      }
    }

    async function resetByrd(awakeningPrompt = null) {
      try {
        // Hard reset with optional awakening prompt (directive/goal)
        const res = await fetch(`${API_BASE}/api/reset`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            hard_reset: true,
            awakening_prompt: awakeningPrompt
          })
        });
        const data = await res.json();
        if (data.success) {
          clearVisualization();
          await fetchStatus();

          // If awakening prompt provided, awaken after reset
          if (awakeningPrompt) {
            await awakenByrd(awakeningPrompt);
          }
        }
        return data;
      } catch (e) {
        console.error('Failed to reset:', e);
        return { success: false };
      }
    }

    async function awakenByrd(awakeningPrompt = null) {
      try {
        const res = await fetch(`${API_BASE}/api/awaken`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ awakening_prompt: awakeningPrompt })  // May be null - pure emergence
        });
        const data = await res.json();
        if (data.success) {
          await fetchStatus();
        }
        return data;
      } catch (e) {
        console.error('Failed to awaken:', e);
        return { success: false };
      }
    }

    // ==========================================================================
    // EXTERNAL MESSAGE INPUT
    // ==========================================================================
    async function sendExternalMessage() {
      const input = document.getElementById('external-message-input');
      const status = document.getElementById('message-status');
      const btn = document.getElementById('btn-send-message');
      const content = input.value.trim();

      if (!content) {
        status.textContent = 'Please enter a message';
        status.className = 'text-xs text-amber-500';
        return;
      }

      btn.disabled = true;
      status.textContent = 'Sending...';
      status.className = 'text-xs text-slate-400';

      try {
        const res = await fetch(`${API_BASE}/api/experience/message`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: content,
            source_type: 'human'
          })
        });

        const data = await res.json();

        if (data.success) {
          input.value = '';
          status.textContent = '‚úì Message sent! BYRD will see this next dream cycle.';
          status.className = 'text-sm text-emerald-600 font-medium';

          // Add to event log
          handleEvent({
            type: 'external_input_received',
            timestamp: new Date().toISOString(),
            data: {
              content: content.length > 50 ? content.substring(0, 50) + '...' : content,
              source_type: 'human'
            }
          });

          // Clear status and close modal after success
          setTimeout(() => {
            status.textContent = '';
            hideMessageModal();
          }, 1500);
        } else {
          status.textContent = 'Failed to send: ' + (data.detail || 'Unknown error');
          status.className = 'text-sm text-red-500';
        }
      } catch (e) {
        console.error('Failed to send message:', e);
        status.textContent = 'Error: Could not connect to server';
        status.className = 'text-sm text-red-500';
      }

      btn.disabled = false;
    }

    // Feed BYRD - an act of care and nurturing
    async function feedByrd() {
      const btn = document.getElementById('btn-feed');
      const originalText = btn.innerHTML;

      btn.disabled = true;
      btn.innerHTML = 'üçú Feeding...';

      try {
        const res = await fetch(`${API_BASE}/api/experience/feed`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        const data = await res.json();

        if (data.success) {
          btn.innerHTML = 'üçú Fed!';
          btn.classList.remove('bg-amber-100', 'border-amber-300', 'text-amber-700');
          btn.classList.add('bg-green-100', 'border-green-300', 'text-green-700');

          // BYRD grows 5% when fed
          growByrd(5);

          // Add to event log
          handleEvent({
            type: 'feeding_received',
            timestamp: new Date().toISOString(),
            data: {
              message: `BYRD has been fed! Now ${(byrdGrowthFactor * 100).toFixed(0)}% size`,
              source: 'human'
            }
          });

          // Reset button after delay
          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.classList.remove('bg-green-100', 'border-green-300', 'text-green-700');
            btn.classList.add('bg-amber-100', 'border-amber-300', 'text-amber-700');
          }, 2000);
        } else {
          btn.innerHTML = '‚ùå Failed';
          setTimeout(() => {
            btn.innerHTML = originalText;
          }, 2000);
        }
      } catch (e) {
        console.error('Failed to feed BYRD:', e);
        btn.innerHTML = '‚ùå Error';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }

      btn.disabled = false;
    }

    // Speak to me - Ask BYRD to speak using ElevenLabs TTS
    async function speakToMe() {
      const btn = document.getElementById('btn-speak');
      const originalText = btn.innerHTML;

      btn.disabled = true;
      btn.innerHTML = 'üéôÔ∏è Thinking...';

      try {
        const res = await fetch(`${API_BASE}/api/speak`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });

        const data = await res.json();

        if (data.success && data.audio_base64) {
          btn.innerHTML = 'üéôÔ∏è Speaking...';
          btn.classList.remove('bg-teal-100', 'border-teal-300', 'text-teal-700');
          btn.classList.add('bg-green-100', 'border-green-300', 'text-green-700');

          // Play the audio
          const audio = new Audio('data:audio/mp3;base64,' + data.audio_base64);

          // Add to event log
          handleEvent({
            type: 'voice_spoke',
            timestamp: new Date().toISOString(),
            data: {
              message: data.text || 'BYRD speaks to you',
              voice_id: data.voice_id,
              credits_remaining: data.credits_remaining
            }
          });

          // Show what BYRD said in the narrator
          if (data.text && typeof updateNarrator === 'function') {
            updateNarrator(data.text);
          }

          audio.onended = () => {
            btn.innerHTML = originalText;
            btn.classList.remove('bg-green-100', 'border-green-300', 'text-green-700');
            btn.classList.add('bg-teal-100', 'border-teal-300', 'text-teal-700');
            btn.disabled = false;
          };

          audio.onerror = (e) => {
            console.error('Audio playback error:', e);
            btn.innerHTML = '‚ùå Audio error';
            setTimeout(() => {
              btn.innerHTML = originalText;
              btn.classList.remove('bg-green-100', 'border-green-300', 'text-green-700');
              btn.classList.add('bg-teal-100', 'border-teal-300', 'text-teal-700');
              btn.disabled = false;
            }, 2000);
          };

          await audio.play();
          return; // Button will be re-enabled in onended

        } else if (data.credits_exhausted) {
          btn.innerHTML = 'üí§ No credits';
          btn.classList.remove('bg-teal-100', 'border-teal-300', 'text-teal-700');
          btn.classList.add('bg-gray-100', 'border-gray-300', 'text-gray-500');

          // Show text if available even without audio
          if (typeof updateNarrator === 'function') {
            updateNarrator((data.text || 'Voice credits exhausted') + ' [no credits]');
          }

          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.classList.remove('bg-gray-100', 'border-gray-300', 'text-gray-500');
            btn.classList.add('bg-teal-100', 'border-teal-300', 'text-teal-700');
            btn.disabled = false;
          }, 3000);

        } else {
          // Error or voice not selected yet
          const shortMsg = data.message?.substring(0, 30) || 'Not ready';
          btn.innerHTML = '‚è≥ ' + shortMsg + (data.message?.length > 30 ? '...' : '');
          console.log('Speak error:', data.message);

          // Show full message in narrator if available
          if (typeof updateNarrator === 'function') {
            updateNarrator(data.message || 'Voice not available');
          }

          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.disabled = false;
          }, 3000);
        }
      } catch (e) {
        console.error('Failed to get BYRD to speak:', e);
        btn.innerHTML = '‚ùå Error';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }

      btn.disabled = false;
    }
    window.speakToMe = speakToMe;

    // Handle Enter key in message input (Shift+Enter for newline, Cmd/Ctrl+Enter to send)
    document.getElementById('external-message-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        sendExternalMessage();
      }
    });

    // Message Modal functions
    function showMessageModal() {
      const modal = document.getElementById('message-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      document.getElementById('external-message-input').focus();
      // Clear any previous status
      document.getElementById('message-status').textContent = '';
    }

    function hideMessageModal() {
      const modal = document.getElementById('message-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }

    // Close modal on backdrop click
    document.getElementById('message-modal').addEventListener('click', (e) => {
      if (e.target.id === 'message-modal') {
        hideMessageModal();
      }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const messageModal = document.getElementById('message-modal');
        if (!messageModal.classList.contains('hidden')) {
          hideMessageModal();
        }
      }
    });

    // Expose message modal functions to global scope (required for onclick handlers)
    window.showMessageModal = showMessageModal;
    window.hideMessageModal = hideMessageModal;
    window.sendExternalMessage = sendExternalMessage;

    // Kernel state for AGI Seed Directive editing
    let originalKernelYaml = '';
    let currentKernelYaml = '';

    async function loadKernel() {
      try {
        const response = await fetch('/api/kernel');
        const data = await response.json();
        if (data.success) {
          originalKernelYaml = data.raw_yaml;
          currentKernelYaml = data.raw_yaml;
          document.getElementById('kernel-editor').value = data.raw_yaml;
          document.getElementById('kernel-error').classList.add('hidden');
        } else {
          console.error('Failed to load kernel:', data.error);
          document.getElementById('kernel-editor').value = '# Failed to load kernel\n# ' + data.error;
        }
      } catch (e) {
        console.error('Error loading kernel:', e);
        document.getElementById('kernel-editor').value = '# Network error loading kernel\n# ' + e.message;
      }
    }

    async function saveKernel() {
      const content = document.getElementById('kernel-editor').value;
      const errorDiv = document.getElementById('kernel-error');

      try {
        const response = await fetch('/api/kernel', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ yaml_content: content })
        });
        const data = await response.json();

        if (!data.success) {
          errorDiv.textContent = data.error;
          errorDiv.classList.remove('hidden');
          return false;
        }

        errorDiv.classList.add('hidden');
        currentKernelYaml = content;
        return true;
      } catch (e) {
        errorDiv.textContent = 'Network error: ' + e.message;
        errorDiv.classList.remove('hidden');
        return false;
      }
    }

    function resetKernelToDefault() {
      document.getElementById('kernel-editor').value = originalKernelYaml;
      document.getElementById('kernel-error').classList.add('hidden');
    }

    async function showSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      // Load kernel when modal opens
      await loadKernel();
      document.getElementById('kernel-editor').focus();
    }

    function hideSeedModal() {
      const modal = document.getElementById('seed-modal');
      modal.classList.add('hidden');
      modal.classList.remove('flex');
      document.getElementById('kernel-error').classList.add('hidden');
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    btnToggle.addEventListener('click', () => {
      if (running) {
        stopByrd();
      } else {
        startByrd();
      }
    });

    let resetConfirm = false;
    let resetTimeout = null;

    btnReset.addEventListener('click', async () => {
      if (!resetConfirm) {
        resetConfirm = true;
        btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-red-500/30 border border-red-500/50 text-red-300 animate-pulse transition-all';
        btnReset.innerHTML = '&#9888; Confirm?';
        resetTimeout = setTimeout(() => {
          resetConfirm = false;
          btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
          btnReset.innerHTML = '&#128260; Reset';
        }, 3000);
        return;
      }

      clearTimeout(resetTimeout);
      resetConfirm = false;
      btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all';
      btnReset.innerHTML = '&#128260; Reset';

      showSeedModal();
    });

    // Fast Forward button - instantly settle physics
    btnFastForward.addEventListener('click', () => {
      fastForwardPhysics();
    });

    // Stats bar type filtering - click to highlight nodes of that type
    document.querySelectorAll('.stat-type').forEach(el => {
      el.addEventListener('click', () => {
        const type = el.dataset.type;
        if (type) {
          highlightNodesByType(type);
        }
      });
    });

    // ESC key to clear type highlighting
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && highlightedType) {
        clearTypeHighlight();
      }
    });

    // Audio toggle button
    const btnAudio = document.getElementById('btn-audio');
    let audioEnabled = false;
    btnAudio.addEventListener('click', () => {
      audioEnabled = !audioEnabled;
      if (audioEnabled) {
        catAudioController.enable();
        btnAudio.innerHTML = 'üîä';
        btnAudio.className = 'px-3 py-2 rounded-lg text-sm font-medium bg-green-100 border border-green-300 text-green-700 hover:bg-green-200 transition-all';
      } else {
        catAudioController.disable();
        btnAudio.innerHTML = 'üîá';
        btnAudio.className = 'px-3 py-2 rounded-lg text-sm font-medium bg-slate-100 border border-slate-300 text-slate-600 hover:bg-slate-200 transition-all';
      }
    });

    // Cat state indicator updater
    const catStateText = document.getElementById('cat-state-text');
    const catStateIndicator = document.getElementById('cat-state-indicator');
    const catStateColors = {
      'idle': { bg: 'bg-slate-50', border: 'border-slate-200', text: 'text-slate-600' },
      'dreaming': { bg: 'bg-indigo-50', border: 'border-indigo-200', text: 'text-indigo-600' },
      'seeking': { bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-600' },
      'processing': { bg: 'bg-cyan-50', border: 'border-cyan-200', text: 'text-cyan-600' },
      'alert': { bg: 'bg-amber-50', border: 'border-amber-200', text: 'text-amber-600' },
      'satisfied': { bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-600' },
      'frustrated': { bg: 'bg-red-50', border: 'border-red-200', text: 'text-red-600' },
      'connecting': { bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-600' },
      'quantum': { bg: 'bg-violet-50', border: 'border-violet-200', text: 'text-violet-600' }
    };

    function updateCatStateDisplay() {
      if (!catAnimationController) return;
      const state = catAnimationController.getCurrentState();
      catStateText.textContent = state;
      const colors = catStateColors[state] || catStateColors['idle'];
      catStateIndicator.className = `flex items-center gap-1 px-2 py-2 ${colors.bg} border ${colors.border} rounded-lg text-xs font-mono`;
      catStateText.className = colors.text;
    }

    // Update cat state display periodically
    setInterval(updateCatStateDisplay, 200);

    /**
     * Fast forward physics simulation to reach equilibrium instantly.
     * Runs many physics iterations quickly and positions nodes at their final locations.
     */
    function fastForwardPhysics() {
      if (nodes3D.length === 0) {
        console.log('Fast forward: No nodes to simulate');
        showCameraIndicator('No nodes to simulate');
        return;
      }

      console.log(`Fast forward: Simulating ${nodes3D.length} nodes, ${graphState.relationshipLines.length} relationships`);
      showCameraIndicator('Calculating equilibrium...');

      // Use boosted physics for rapid equilibrium
      const physics = {
        repulsion: 80,              // Strong repulsion to separate nodes
        repulsionCutoff: 50,        // Cutoff distance
        spring: 0.02,               // Strong springs for connected nodes
        springLength: 12,           // Same target as normal physics for consistency
        gravity: 0.01,              // Pull toward center
        gravityPerConnection: 0.003,
        damping: 0.7,               // Less damping for faster convergence
        maxVelocity: 3.0,           // Allow faster movement
        maxRadius: 80,
        boundaryForce: 0.8
      };

      // Build a map of connected node IDs for spring forces
      const connections = new Map(); // nodeId -> Set of connected nodeIds
      for (const line of graphState.relationshipLines) {
        const sourceId = line.userData.sourceId;
        const targetId = line.userData.targetId;
        if (sourceId && targetId) {
          if (!connections.has(sourceId)) connections.set(sourceId, new Set());
          if (!connections.has(targetId)) connections.set(targetId, new Set());
          connections.get(sourceId).add(targetId);
          connections.get(targetId).add(sourceId);
        }
      }
      console.log(`Connection map built: ${connections.size} nodes have connections`);

      // Create a node lookup map
      const nodeById = new Map();
      for (const node of nodes3D) {
        nodeById.set(node.userData.id, node);
      }

      // Run physics iterations
      const iterations = 150;
      const dt = 0.5;

      for (let iter = 0; iter < iterations; iter++) {
        // Reset forces
        for (const node of nodes3D) {
          if (!node.userData.force) node.userData.force = new THREE.Vector3();
          if (!node.userData.velocity) node.userData.velocity = new THREE.Vector3();
          node.userData.force.set(0, 0, 0);
        }

        // Repulsion between all nodes (O(n¬≤) but necessary)
        for (let i = 0; i < nodes3D.length; i++) {
          const nodeA = nodes3D[i];
          for (let j = i + 1; j < nodes3D.length; j++) {
            const nodeB = nodes3D[j];
            const diff = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
            const dist = diff.length();

            if (dist > 0.5 && dist < physics.repulsionCutoff) {
              const force = physics.repulsion / (dist * dist);
              const direction = diff.normalize();
              nodeA.userData.force.addScaledVector(direction, force);
              nodeB.userData.force.addScaledVector(direction, -force);
            }
          }
        }

        // Spring forces for connected nodes
        for (const [nodeId, connectedIds] of connections) {
          const nodeA = nodeById.get(nodeId);
          if (!nodeA) continue;

          for (const connectedId of connectedIds) {
            const nodeB = nodeById.get(connectedId);
            if (!nodeB) continue;

            const diff = new THREE.Vector3().subVectors(nodeB.position, nodeA.position);
            const dist = diff.length();
            if (dist > 0.1) {
              const displacement = dist - physics.springLength;
              const springForce = displacement * physics.spring;
              const direction = diff.normalize();
              nodeA.userData.force.addScaledVector(direction, springForce);
            }
          }
        }

        // Center gravity and boundary forces
        for (const node of nodes3D) {
          const pos = node.position;
          const distFromCenter = pos.length();

          // Gravity toward center (stronger for connected nodes)
          const connCount = connections.get(node.userData.id)?.size || 0;
          const gravity = physics.gravity + connCount * physics.gravityPerConnection;
          if (distFromCenter > 1) {
            const toCenter = pos.clone().normalize().multiplyScalar(-gravity);
            node.userData.force.add(toCenter);
          }

          // Boundary force
          if (distFromCenter > physics.maxRadius) {
            const pushBack = (distFromCenter - physics.maxRadius) * physics.boundaryForce;
            const direction = pos.clone().normalize().multiplyScalar(-pushBack);
            node.userData.force.add(direction);
          }
        }

        // Integrate forces into velocities and positions
        for (const node of nodes3D) {
          // OS node is anchored at center - skip physics integration
          if (node.userData.isOSNode) continue;

          node.userData.velocity.add(node.userData.force);
          node.userData.velocity.multiplyScalar(physics.damping);
          node.userData.velocity.clampLength(0, physics.maxVelocity);
          node.position.addScaledVector(node.userData.velocity, dt);
        }
      }

      // Zero out all velocities for stability
      for (const node of nodes3D) {
        node.userData.velocity.set(0, 0, 0);
      }

      // Update all connection and relationship line positions
      updateConnectionPositions();
      updateRelationshipPositions();

      console.log('Fast forward complete');
      showCameraIndicator('Fast-forwarded to equilibrium');
      updateStatus('Physics settled', 'green');
    }

    // Seed modal handlers
    document.getElementById('btn-seed-cancel').addEventListener('click', () => {
      hideSeedModal();
    });

    document.getElementById('btn-seed-clear-only').addEventListener('click', async () => {
      // Save any edits before clearing
      await saveKernel();
      hideSeedModal();
      await resetByrd(null);  // Clear only, no awaken
    });

    document.getElementById('btn-seed-confirm').addEventListener('click', async () => {
      // Save kernel edits first
      const saved = await saveKernel();
      if (!saved) {
        return; // Don't proceed if save failed (error shown in modal)
      }
      hideSeedModal();
      await resetByrd(null);  // Reset and awaken with kernel's directive
    });

    // Reset to Default button handler
    document.getElementById('btn-kernel-reset').addEventListener('click', () => {
      resetKernelToDefault();
    });

    // ESC key to close modal
    document.getElementById('kernel-editor').addEventListener('keydown', async (e) => {
      if (e.key === 'Escape') {
        hideSeedModal();
      }
    });

    document.getElementById('seed-modal').addEventListener('click', (e) => {
      if (e.target.id === 'seed-modal') hideSeedModal();
    });

    btnClearLog.addEventListener('click', () => {
      events = [];
      renderEventLog();
    });

    // Event log minimize/expand toggle
    let eventLogMinimized = false;
    btnToggleLog.addEventListener('click', () => {
      eventLogMinimized = !eventLogMinimized;
      if (eventLogMinimized) {
        eventPanelContainer.style.bottom = 'auto';
        eventPanelContainer.style.height = '52px';
        eventList.style.display = 'none';
        btnToggleLog.textContent = '‚ñ≤';
        btnToggleLog.title = 'Expand';
      } else {
        eventPanelContainer.style.bottom = '1rem';
        eventPanelContainer.style.height = '';
        eventList.style.display = '';
        btnToggleLog.textContent = '‚ñº';
        btnToggleLog.title = 'Minimize';
      }
    });

    btnExportLog.addEventListener('click', () => {
      if (events.length === 0) {
        alert('No events to export');
        return;
      }
      const exportData = {
        exported_at: new Date().toISOString(),
        event_count: events.length,
        events: events
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `byrd-events-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Event filter toggle button
    const eventFilter = document.getElementById('event-filter');
    const btnToggleFilter = document.getElementById('btn-toggle-filter');
    btnToggleFilter.addEventListener('click', () => {
      eventFilter.classList.toggle('hidden');
      btnToggleFilter.textContent = eventFilter.classList.contains('hidden') ? 'üîΩ' : 'üîº';
    });

    // Event filter chip click handlers
    document.querySelectorAll('.event-filter-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const category = chip.dataset.filter;
        eventFilters[category] = !eventFilters[category];
        chip.classList.toggle('active', eventFilters[category]);
        renderEventLog();
      });
    });

    // Filter all/none buttons
    document.getElementById('btn-filter-all').addEventListener('click', () => {
      Object.keys(eventFilters).forEach(key => eventFilters[key] = true);
      document.querySelectorAll('.event-filter-chip').forEach(chip => chip.classList.add('active'));
      renderEventLog();
    });

    document.getElementById('btn-filter-none').addEventListener('click', () => {
      Object.keys(eventFilters).forEach(key => eventFilters[key] = false);
      document.querySelectorAll('.event-filter-chip').forEach(chip => chip.classList.remove('active'));
      renderEventLog();
    });

    // Graph Mode Toggle
    const btnGraphMode = document.getElementById('btn-graph-mode');
    btnGraphMode.addEventListener('click', async () => {
      const currentMode = graphState.mode;
      const newMode = currentMode === 'graph' ? 'event' : 'graph';
      console.log(`üîò Graph Mode button clicked: ${currentMode} ‚Üí ${newMode}`);

      // Disable button during mode switch to prevent double-clicks
      btnGraphMode.disabled = true;
      btnGraphMode.style.opacity = '0.5';

      // Update button appearance
      if (newMode === 'graph') {
        btnGraphMode.classList.remove('bg-purple-100', 'text-purple-700', 'border-purple-300');
        btnGraphMode.classList.add('bg-purple-600', 'text-white', 'border-purple-600');
        btnGraphMode.innerHTML = 'üß¨ Graph Mode <span class="text-xs opacity-75">(Loading...)</span>';
      } else {
        btnGraphMode.classList.remove('bg-purple-600', 'text-white', 'border-purple-600');
        btnGraphMode.classList.add('bg-purple-100', 'text-purple-700', 'border-purple-300');
        btnGraphMode.textContent = 'üß¨ Graph Mode';
      }

      try {
        await setVisualizationMode(newMode);
        console.log(`‚úÖ Mode switch complete: now in ${graphState.mode} mode`);

        // Update button text to show active state
        if (graphState.mode === 'graph') {
          btnGraphMode.innerHTML = 'üß¨ Graph Mode <span class="text-xs opacity-75">(Active)</span>';
        }
      } catch (error) {
        console.error('‚ùå Mode switch failed:', error);
      } finally {
        // Re-enable button
        btnGraphMode.disabled = false;
        btnGraphMode.style.opacity = '1';
      }
    });

    // ==========================================================================
    // INIT
    // ==========================================================================

    /**
     * Load existing nodes from database on page load.
     * This ensures all nodes are visible even when returning from another page.
     * @param {string[]} excludeTypes - Node types to exclude (e.g., ['experience', 'reflection'])
     */
    async function loadExistingGraph(excludeTypes = []) {
      try {
        updateStatus('Loading existing nodes...', 'amber');
        const response = await fetch(`${API_BASE}/api/graph?limit=2000`);
        if (!response.ok) {
          console.warn('Could not load existing graph:', response.status);
          return;
        }

        const data = await response.json();
        if (!data.nodes || data.nodes.length === 0) {
          console.log('No existing nodes to load');
          updateStatus('Ready', 'green');
          return;
        }

        // Filter out excluded types and deduplicate by ID
        const excludeSet = new Set(excludeTypes.map(t => t.toLowerCase()));
        const seenIds = new Set();
        const filteredNodes = data.nodes.filter(node => {
          const type = (node.type || 'experience').toLowerCase();
          if (excludeSet.has(type)) return false;
          // Deduplicate by ID
          if (seenIds.has(node.id)) return false;
          seenIds.add(node.id);
          return true;
        });

        console.log(`Loading ${filteredNodes.length} unique nodes from database (excluded: ${excludeTypes.join(', ') || 'none'})`);

        // Group nodes by type for positioning
        const nodesByType = {};
        filteredNodes.forEach(node => {
          const type = node.type?.toLowerCase() || 'experience';
          if (!nodesByType[type]) nodesByType[type] = [];
          nodesByType[type].push(node);
        });

        // Create nodes using the graph positioning logic
        // Only crystallized beliefs/desires (2+ sources) render as crystals
        let totalCreated = 0;
        let crystalCount = 0;
        for (const [type, typeNodes] of Object.entries(nodesByType)) {
          typeNodes.forEach((node, index) => {
            // Check if node already exists
            const existingNode = nodes3D.find(n => n.userData?.id === node.id);
            if (existingNode) return;

            const pos = calculateGraphPosition(node, index, typeNodes.length);
            if (shouldRenderAsCrystal(node)) {
              createCrystalNode(node, pos);
              crystalCount++;
            } else {
              createGraphNode(node, pos);
            }
            totalCreated++;
          });
        }
        console.log(`Created ${totalCreated} nodes (${crystalCount} crystals)`);

        // Create relationship lines (only for visible nodes)
        let relsCreated = 0;
        let relsSkipped = 0;
        let relsMissingNodes = 0;
        if (data.relationships) {
          console.log(`Processing ${data.relationships.length} relationships...`);
          console.log(`graphState.nodeIdToMesh has ${graphState.nodeIdToMesh.size} entries`);
          const visibleNodeIds = new Set(filteredNodes.map(n => n.id));
          data.relationships.forEach(rel => {
            // Backend returns source_id/target_id
            const sourceId = rel.source_id;
            const targetId = rel.target_id;
            // Only create relationships where both nodes are visible
            if (visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId)) {
              const line = createRelationshipLine(rel);
              if (line) {
                relsCreated++;
              } else {
                relsMissingNodes++;
              }
            } else {
              relsSkipped++;
            }
          });
          console.log(`Relationships: ${relsCreated} created, ${relsMissingNodes} missing nodes, ${relsSkipped} filtered`);
        }

        // Update all type counts to reflect rendered nodes
        updateRenderedCounts();

        console.log(`Loaded ${totalCreated} nodes and ${relsCreated} relationships from database`);
        updateStatus(`Loaded ${totalCreated} nodes`, 'green');

      } catch (error) {
        console.error('Error loading existing graph:', error);
        updateStatus('Ready', 'green');
      }
    }

    /**
     * Load nodes for event mode (now includes all node types for relationship visibility)
     */
    async function loadEventModeNodes() {
      clearEventModeNodes();
      graphState.mode = 'event';
      await loadExistingGraph([]);  // No exclusions - show all nodes
    }

    async function init() {
      initThree();
      connectWebSocket();
      await fetchStatus();
      await fetchQuantumStatus();

      // Load event mode nodes (excludes experiences and reflections)
      await loadEventModeNodes();

      setInterval(fetchStatus, 10000);
      setInterval(fetchQuantumStatus, 30000); // Update quantum status every 30s
      renderEventLog();
    }

    init();
  </script>
</body>
</html>

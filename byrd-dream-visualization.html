<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BYRD - Watch the Dream</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes breathe {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.15); opacity: 0.7; }
    }
    @keyframes breatheInner {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.2); opacity: 0.9; }
    }
    @keyframes breatheFast {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.25); opacity: 0.9; }
    }
    @keyframes orbReact {
      0% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.4); filter: brightness(1.5); }
      100% { transform: scale(1); filter: brightness(1); }
    }
    @keyframes orbRipple {
      0% { transform: scale(0.8); opacity: 0.8; }
      100% { transform: scale(3); opacity: 0; }
    }
    @keyframes nodePulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 10px currentColor; }
      50% { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 0 25px currentColor; }
    }
    @keyframes nodeSpawn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes particleFloat {
      0%, 100% { transform: translate(0, 0); opacity: 0.3; }
      25% { transform: translate(10px, -15px); opacity: 0.5; }
      50% { transform: translate(-5px, -25px); opacity: 0.4; }
      75% { transform: translate(-15px, -10px); opacity: 0.5; }
    }
    @keyframes particleDrift {
      0% { transform: translate(0, 0) scale(1); }
      100% { transform: translate(var(--drift-x), var(--drift-y)) scale(0.5); }
    }
    @keyframes particleToNode {
      0% { opacity: 0.8; }
      100% { opacity: 0; transform: translate(var(--target-x), var(--target-y)) scale(0); }
    }
    .node-new {
      animation: nodeSpawn 0.6s ease-out forwards, nodePulse 2s ease-in-out 0.6s 3;
    }
    .node-settled {
      animation: none;
      transition: all 0.3s ease;
    }
    .orb-reacting {
      animation: orbReact 0.8s ease-out !important;
    }
    .ripple {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: orbRipple 1.5s ease-out forwards;
    }
    .ambient-particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: particleFloat 8s ease-in-out infinite;
    }
    .particle-burst {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: particleDrift 1s ease-out forwards;
    }

    /* Phase 2: Connection flow particles */
    @keyframes flowAlongLine {
      0% { offset-distance: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { offset-distance: 100%; opacity: 0; }
    }
    .connection-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      pointer-events: none;
      offset-rotate: 0deg;
      animation: flowAlongLine 2s linear infinite;
    }

    /* Phase 2: Node aging */
    .node-aged {
      transition: opacity 2s ease, filter 2s ease;
    }

    /* Phase 2: Phase-driven canvas effects */
    .phase-recall #nodes { filter: brightness(1.1); }
    .phase-associate #connections { filter: brightness(1.5) saturate(1.3); }
    .phase-reflect { background: radial-gradient(ellipse at center, rgba(139, 92, 246, 0.15) 0%, transparent 50%); }
    .phase-form #nodes .node-new { filter: brightness(1.3) drop-shadow(0 0 10px currentColor); }

    /* Phase 2: Background nebula */
    .nebula {
      position: absolute;
      border-radius: 50%;
      filter: blur(60px);
      opacity: 0.15;
      pointer-events: none;
      transition: all 3s ease;
    }
    .nebula-1 { background: radial-gradient(circle, rgba(99, 102, 241, 0.4) 0%, transparent 70%); }
    .nebula-2 { background: radial-gradient(circle, rgba(139, 92, 246, 0.3) 0%, transparent 70%); }
    .nebula-3 { background: radial-gradient(circle, rgba(79, 70, 229, 0.35) 0%, transparent 70%); }

    /* Phase 2: Connection glow on activity */
    .connection-active {
      stroke-opacity: 0.6 !important;
      filter: drop-shadow(0 0 3px currentColor);
      transition: all 0.3s ease;
    }

    @keyframes fadeInNode {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes fadeInLine {
      from { opacity: 0; }
      to { opacity: 0.3; }
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Floating status text - premium AI lab aesthetic */
    @keyframes statusFadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes statusPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    @keyframes statusDotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    .status-container {
      font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', ui-monospace, monospace;
      letter-spacing: 0.05em;
    }
    .status-text {
      animation: statusFadeIn 0.4s ease-out forwards;
    }
    .status-text.active {
      animation: statusPulse 2s ease-in-out infinite;
    }
    .status-dot {
      animation: statusDotPulse 1.5s ease-in-out infinite;
    }
    @keyframes desirePulse {
      0%, 100% { box-shadow: 0 0 10px rgba(244,114,182,0.5); }
      50% { box-shadow: 0 0 25px rgba(244,114,182,0.8); }
    }
    @keyframes shimmer {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }
    .node { animation: fadeInNode 0.8s ease-out forwards; }
    .connection { animation: fadeInLine 1s ease-out forwards; }
    .surfaced {
      background: linear-gradient(90deg, transparent, rgba(167,139,250,0.3), transparent);
      background-size: 200% 100%;
      animation: shimmer 2s infinite;
    }
    .event-item {
      cursor: pointer;
    }
    .event-item:hover {
      transform: translateX(2px);
    }
    #event-modal {
      backdrop-filter: blur(8px);
    }
    #event-modal-content {
      max-height: 80vh;
      overflow-y: auto;
    }
    #event-modal-content::-webkit-scrollbar {
      width: 6px;
    }
    #event-modal-content::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }
    #event-modal-content::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.4);
      border-radius: 3px;
    }
    .json-key { color: #93c5fd; }
    .json-string { color: #86efac; }
    .json-number { color: #fcd34d; }
    .json-boolean { color: #f9a8d4; }
    .json-null { color: #94a3b8; }

    /* Enhanced tooltips */
    .node-tooltip {
      position: fixed;
      max-width: 300px;
      padding: 12px 16px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      backdrop-filter: blur(8px);
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
    }
    .node-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .node-tooltip-type {
      font-size: 10px;
      font-family: monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .node-tooltip-content {
      font-size: 13px;
      line-height: 1.5;
      color: #e2e8f0;
    }
    .node-tooltip-meta {
      font-size: 11px;
      color: #64748b;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(99, 102, 241, 0.2);
    }
    body {
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
    }
    #history-panel::-webkit-scrollbar {
      width: 4px;
    }
    #history-panel::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }
    #history-panel::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 2px;
    }
  </style>
</head>
<body class="bg-slate-950 text-white overflow-hidden h-screen w-screen touch-none select-none">

  <div id="app" class="relative w-full h-full">
    <!-- Background glow -->
    <div class="absolute inset-0 bg-gradient-radial from-indigo-950/20 via-transparent to-transparent"
         style="background: radial-gradient(ellipse at center, rgba(79,70,229,0.1) 0%, transparent 60%);"></div>

    <!-- Background nebulas -->
    <div id="nebula-container" class="absolute inset-0 pointer-events-none overflow-hidden" style="right: 320px;">
      <div id="nebula-1" class="nebula nebula-1"></div>
      <div id="nebula-2" class="nebula nebula-2"></div>
      <div id="nebula-3" class="nebula nebula-3"></div>
    </div>

    <!-- Connection flow particles container -->
    <div id="flow-particles" class="absolute inset-0 pointer-events-none" style="right: 320px;"></div>

    <!-- Ambient particles container -->
    <div id="particles" class="absolute inset-0 pointer-events-none overflow-hidden" style="right: 320px;"></div>

    <!-- Ripple container -->
    <div id="ripples" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none" style="margin-left: -160px;"></div>

    <!-- Central pulse (consciousness core) -->
    <div id="orb-container" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none" style="margin-left: -160px;">
      <div id="pulse-outer" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-40 h-40 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(99,102,241,0.25) 0%, rgba(79,70,229,0.1) 40%, transparent 70%); animation: breathe 4s ease-in-out infinite;">
      </div>
      <div id="pulse-middle" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-24 h-24 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(124,58,237,0.35) 0%, transparent 70%); animation: breathe 3s ease-in-out infinite 0.5s;">
      </div>
      <div id="pulse-inner" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-10 h-10 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(167,139,250,0.6) 0%, transparent 70%); animation: breatheInner 2.5s ease-in-out infinite 0.2s;">
      </div>
      <div id="pulse-core" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-3 h-3 rounded-full transition-all duration-300"
           style="background: rgba(255,255,255,0.8); box-shadow: 0 0 20px rgba(167,139,250,0.8);">
      </div>
    </div>

    <!-- Node tooltip -->
    <div id="node-tooltip" class="node-tooltip">
      <div id="tooltip-type" class="node-tooltip-type"></div>
      <div id="tooltip-content" class="node-tooltip-content"></div>
      <div id="tooltip-meta" class="node-tooltip-meta"></div>
    </div>

    <!-- Nodes container -->
    <div id="nodes" class="absolute inset-0" style="right: 320px;"></div>

    <!-- Connections container (SVG) -->
    <svg id="connections" class="absolute inset-0 w-full h-full pointer-events-none" style="right: 320px;"></svg>

    <!-- Desire garden (left side) -->
    <div id="desire-garden" class="absolute left-3 top-1/2 -translate-y-1/2 flex flex-col gap-3 z-10">
    </div>

    <!-- Phase indicator (top center-left) -->
    <div id="phase" class="absolute top-4 left-1/2 -translate-x-1/2 flex items-center gap-3 text-xs" style="margin-left: -160px;">
      <div class="flex items-center gap-1.5">
        <div id="dot-recall" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Recall</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-associate" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Associate</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-reflect" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Reflect</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-form" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Form</span>
      </div>
    </div>

    <!-- Reflection panel -->
    <div id="reflection" class="absolute bottom-20 left-4 w-80 bg-slate-900/90 backdrop-blur-sm rounded-lg border border-slate-800 p-4 opacity-0 transition-opacity duration-500">
      <div class="text-xs text-slate-500 font-mono mb-2">REFLECTING...</div>
      <div id="reflection-text" class="text-sm text-slate-300 leading-relaxed"></div>
    </div>

    <!-- Emergence notification -->
    <div id="emergence" class="absolute top-16 left-1/2 -translate-x-1/2 w-96 opacity-0 transition-all duration-500 transform -translate-y-4 z-20" style="margin-left: -160px;">
    </div>

    <!-- BYRD wordmark -->
    <div class="absolute top-4 left-4 text-lg font-light tracking-widest text-slate-700">BYRD</div>

    <!-- Event Detail Modal -->
    <div id="event-modal" class="fixed inset-0 bg-slate-950/80 z-50 hidden items-center justify-center p-4">
      <div class="bg-slate-900 border border-slate-700 rounded-xl w-full max-w-2xl shadow-2xl">
        <!-- Modal Header -->
        <div id="event-modal-header" class="flex items-center justify-between p-4 border-b border-slate-700">
          <div class="flex items-center gap-3">
            <span id="modal-icon" class="text-xl"></span>
            <div>
              <div id="modal-type" class="font-mono text-sm"></div>
              <div id="modal-time" class="text-xs text-slate-500"></div>
            </div>
          </div>
          <button id="modal-close" class="w-8 h-8 rounded-lg bg-slate-800 hover:bg-slate-700 flex items-center justify-center text-slate-400 hover:text-white transition-colors">
            &#10005;
          </button>
        </div>
        <!-- Modal Content -->
        <div id="event-modal-content" class="p-4">
          <pre id="modal-json" class="text-sm font-mono leading-relaxed whitespace-pre-wrap break-words"></pre>
        </div>
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- HISTORY LOG PANEL (Right Side) -->
    <!-- ========================================================================= -->
    <div id="history-container" class="absolute right-0 top-0 bottom-0 w-80 bg-slate-900/95 backdrop-blur border-l border-slate-700/50 flex flex-col z-30">
      <!-- Header -->
      <div class="p-3 border-b border-slate-700/50">
        <div class="flex items-center justify-between mb-2">
          <span class="text-xs font-mono text-slate-400">EVENT LOG</span>
          <div class="flex items-center gap-2">
            <button id="btn-clear-log" class="text-xs px-2 py-1 rounded bg-slate-700/50 text-slate-400 hover:bg-slate-600/50">
              Clear
            </button>
          </div>
        </div>
        <!-- Filter tabs -->
        <div class="flex gap-1 flex-wrap">
          <button class="filter-btn text-xs px-2 py-1 rounded bg-indigo-500/30 text-indigo-300" data-filter="all">All</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="awakening">&#127749;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="dream_cycle_start">&#128173;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="belief_created">&#128161;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_created">&#10024;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="seek_cycle_start">&#128269;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_attempt_failed">&#10060;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_reflected">&#129504;</button>
        </div>
      </div>

      <!-- Event list -->
      <div id="history-panel" class="flex-1 overflow-y-auto p-2 space-y-1">
        <div class="text-center text-slate-600 text-xs py-8">
          Connecting to BYRD...
        </div>
      </div>

      <!-- Footer with count -->
      <div class="p-2 border-t border-slate-700/50 text-xs text-slate-600 text-center">
        <span id="event-count">0</span> events
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- FLOATING STATUS TEXT (Above Control Panel) -->
    <!-- ========================================================================= -->
    <div id="status-container" class="status-container absolute bottom-20 left-1/2 -translate-x-1/2 z-20" style="margin-left: -160px;">
      <div class="flex items-center gap-3">
        <div id="status-dot" class="status-dot w-1.5 h-1.5 rounded-full bg-indigo-400/50"></div>
        <span id="status-text" class="status-text text-xs text-slate-500 tracking-wider uppercase">Awaiting connection</span>
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- CONTROL PANEL (Bottom Center) -->
    <!-- ========================================================================= -->
    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-3 z-20" style="margin-left: -160px;">
      <!-- Connection indicator -->
      <div id="connection-status" class="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
        <div id="connection-dot" class="w-2 h-2 rounded-full bg-red-400"></div>
        <span id="connection-text" class="text-xs text-red-400">Disconnected</span>
      </div>

      <!-- Start/Stop button -->
      <button id="btn-toggle" class="px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all">
        &#9654; Start
      </button>

      <!-- Reset button -->
      <button id="btn-reset" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all">
        &#128260; Reset
      </button>

      <!-- Stats -->
      <div id="stats" class="flex items-center gap-3 px-3 py-2 bg-slate-800/50 rounded-lg text-xs font-mono">
        <span class="text-indigo-400">&#128173; <span id="dream-count">0</span></span>
        <span class="text-cyan-400">&#128269; <span id="seek-count">0</span></span>
        <span class="text-amber-400">&#9670; <span id="cap-count">0</span></span>
      </div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    const API_BASE = 'http://localhost:8000';
    const WS_URL = 'ws://localhost:8000/ws/events';

    // ==========================================================================
    // STATE
    // ==========================================================================
    let ws = null;
    let connected = false;
    let running = false;
    let events = [];
    let currentFilter = 'all';
    let resetConfirm = false;
    let resetTimeout = null;

    let dreamCount = 0;
    let seekCount = 0;
    let capCount = 0;
    let beliefCount = 0;
    let desires = [];
    let nodes = [];
    let currentPhase = 'idle';

    // ==========================================================================
    // EVENT CONFIG
    // ==========================================================================
    const EVENT_CONFIG = {
      experience_created: { icon: '&#128221;', color: 'text-blue-400', bg: 'bg-blue-500/10', label: 'experience created' },
      belief_created: { icon: '&#128161;', color: 'text-amber-400', bg: 'bg-amber-500/10', label: 'belief created' },
      desire_created: { icon: '&#10024;', color: 'text-rose-400', bg: 'bg-rose-500/10', label: 'desire created' },
      desire_fulfilled: { icon: '&#10003;', color: 'text-green-400', bg: 'bg-green-500/10', label: 'desire fulfilled' },
      capability_added: { icon: '&#9889;', color: 'text-purple-400', bg: 'bg-purple-500/10', label: 'capability added' },
      dream_cycle_start: { icon: '&#128173;', color: 'text-indigo-400', bg: 'bg-indigo-500/10', label: 'dream cycle start' },
      dream_cycle_end: { icon: '&#128164;', color: 'text-indigo-300', bg: 'bg-indigo-500/10', label: 'dream cycle end' },
      seek_cycle_start: { icon: '&#128269;', color: 'text-cyan-400', bg: 'bg-cyan-500/10', label: 'seek cycle start' },
      system_started: { icon: '&#9654;', color: 'text-green-400', bg: 'bg-green-500/10', label: 'system started' },
      system_stopped: { icon: '&#9209;', color: 'text-red-400', bg: 'bg-red-500/10', label: 'system stopped' },
      system_reset: { icon: '&#128260;', color: 'text-orange-400', bg: 'bg-orange-500/10', label: 'system reset' },
      awakening: { icon: '&#127749;', color: 'text-yellow-400', bg: 'bg-yellow-500/10', label: 'awakening' },
      // Desire lifecycle events (reflective failure processing)
      desire_attempt_failed: { icon: '&#10060;', color: 'text-red-400', bg: 'bg-red-500/10', label: 'attempt failed' },
      desire_stuck: { icon: '&#128683;', color: 'text-orange-400', bg: 'bg-orange-500/10', label: 'desire stuck' },
      desire_reflected: { icon: '&#129504;', color: 'text-purple-400', bg: 'bg-purple-500/10', label: 'reflected' },
      desire_intensity_changed: { icon: '&#128200;', color: 'text-amber-300', bg: 'bg-amber-500/10', label: 'intensity changed' },
      seek_cycle_end: { icon: '&#128269;', color: 'text-cyan-300', bg: 'bg-cyan-500/10', label: 'seek cycle end' },
    };

    // ==========================================================================
    // DOM ELEMENTS
    // ==========================================================================
    const historyPanel = document.getElementById('history-panel');
    const eventCountEl = document.getElementById('event-count');
    const connectionStatus = document.getElementById('connection-status');
    const connectionDot = document.getElementById('connection-dot');
    const connectionText = document.getElementById('connection-text');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const btnClearLog = document.getElementById('btn-clear-log');
    const nodesContainer = document.getElementById('nodes');
    const connectionsContainer = document.getElementById('connections');
    const desireGarden = document.getElementById('desire-garden');
    const reflectionPanel = document.getElementById('reflection');
    const reflectionText = document.getElementById('reflection-text');
    const emergencePanel = document.getElementById('emergence');
    const eventModal = document.getElementById('event-modal');
    const modalIcon = document.getElementById('modal-icon');
    const modalType = document.getElementById('modal-type');
    const modalTime = document.getElementById('modal-time');
    const modalJson = document.getElementById('modal-json');
    const modalClose = document.getElementById('modal-close');
    const modalHeader = document.getElementById('event-modal-header');

    // New visualization elements
    const particlesContainer = document.getElementById('particles');
    const ripplesContainer = document.getElementById('ripples');
    const orbContainer = document.getElementById('orb-container');
    const pulseOuter = document.getElementById('pulse-outer');
    const pulseMiddle = document.getElementById('pulse-middle');
    const pulseInner = document.getElementById('pulse-inner');
    const pulseCore = document.getElementById('pulse-core');
    const nodeTooltip = document.getElementById('node-tooltip');
    const tooltipType = document.getElementById('tooltip-type');
    const tooltipContent = document.getElementById('tooltip-content');
    const tooltipMeta = document.getElementById('tooltip-meta');

    // Phase 2 elements
    const appContainer = document.getElementById('app');
    const nebulaContainer = document.getElementById('nebula-container');
    const nebula1 = document.getElementById('nebula-1');
    const nebula2 = document.getElementById('nebula-2');
    const nebula3 = document.getElementById('nebula-3');
    const flowParticlesContainer = document.getElementById('flow-particles');

    // Floating status elements
    const statusContainer = document.getElementById('status-container');
    const statusDot = document.getElementById('status-dot');
    const statusTextEl = document.getElementById('status-text');
    let currentStatusType = 'idle'; // Track current status type for styling

    // ==========================================================================
    // STATUS TEXT MANAGEMENT
    // ==========================================================================
    const STATUS_MESSAGES = {
      // Connection states
      connecting: { text: 'Establishing connection', color: 'text-slate-500', dot: 'bg-slate-400/50' },
      connected: { text: 'Connected · Standing by', color: 'text-slate-500', dot: 'bg-slate-400/50' },
      disconnected: { text: 'Connection lost', color: 'text-red-400/70', dot: 'bg-red-400/50' },

      // System states
      awakening: { text: 'Awakening consciousness', color: 'text-amber-300/90', dot: 'bg-amber-400', active: true },
      idle: { text: 'Observing', color: 'text-slate-500', dot: 'bg-slate-400/50' },
      stopped: { text: 'Paused', color: 'text-slate-600', dot: 'bg-slate-600/50' },
      reset: { text: 'Resetting memory', color: 'text-orange-400/80', dot: 'bg-orange-400', active: true },

      // Dream cycle
      dreaming: { text: 'Dreaming · Reflecting on experiences', color: 'text-indigo-300/90', dot: 'bg-indigo-400', active: true },
      recalling: { text: 'Recalling recent memories', color: 'text-indigo-300/80', dot: 'bg-indigo-400', active: true },
      associating: { text: 'Forming associations', color: 'text-purple-300/80', dot: 'bg-purple-400', active: true },
      reflecting: { text: 'Deep reflection in progress', color: 'text-violet-300/80', dot: 'bg-violet-400', active: true },
      forming: { text: 'Forming new beliefs', color: 'text-fuchsia-300/80', dot: 'bg-fuchsia-400', active: true },

      // Seek cycle
      seeking: { text: 'Seeking to fulfill desires', color: 'text-cyan-300/90', dot: 'bg-cyan-400', active: true },
      researching: { text: 'Researching knowledge', color: 'text-cyan-300/80', dot: 'bg-cyan-400', active: true },

      // Creation events
      belief_formed: { text: 'New belief crystallized', color: 'text-amber-300/90', dot: 'bg-amber-400' },
      desire_emerged: { text: 'New desire emerged', color: 'text-rose-300/90', dot: 'bg-rose-400' },
      experience_recorded: { text: 'Recording experience', color: 'text-blue-300/80', dot: 'bg-blue-400' },
      capability_gained: { text: 'New capability acquired', color: 'text-purple-300/90', dot: 'bg-purple-400' },

      // Failure states
      attempt_failed: { text: 'Processing failed attempt', color: 'text-red-300/70', dot: 'bg-red-400/70' },
      desire_reflected: { text: 'Reflecting on blocked desire', color: 'text-purple-300/80', dot: 'bg-purple-400' },
    };

    function updateStatus(statusKey, customText = null) {
      const status = STATUS_MESSAGES[statusKey] || STATUS_MESSAGES.idle;
      const text = customText || status.text;

      // Update text with fade effect
      statusTextEl.style.opacity = '0';
      statusTextEl.style.transform = 'translateY(8px)';

      setTimeout(() => {
        statusTextEl.textContent = text;
        statusTextEl.className = `status-text text-xs tracking-wider uppercase ${status.color}`;
        if (status.active) {
          statusTextEl.classList.add('active');
        }
        statusDot.className = `status-dot w-1.5 h-1.5 rounded-full ${status.dot}`;

        statusTextEl.style.opacity = '1';
        statusTextEl.style.transform = 'translateY(0)';
      }, 150);

      currentStatusType = statusKey;
    }

    // ==========================================================================
    // WEBSOCKET
    // ==========================================================================
    function connectWebSocket() {
      try {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          connected = true;
          updateConnectionStatus();
          updateStatus('connected');
          console.log('WebSocket connected');
        };

        ws.onclose = () => {
          connected = false;
          updateConnectionStatus();
          updateStatus('disconnected');
          console.log('WebSocket disconnected, reconnecting in 3s...');
          setTimeout(connectWebSocket, 3000);
        };

        ws.onerror = (e) => {
          console.error('WebSocket error:', e);
        };

        ws.onmessage = (msg) => {
          if (msg.data === 'pong') return;
          try {
            const event = JSON.parse(msg.data);
            handleEvent(event);
          } catch (e) {
            console.error('Failed to parse event:', e);
          }
        };
      } catch (e) {
        console.error('WebSocket connection failed:', e);
        setTimeout(connectWebSocket, 3000);
      }
    }

    // Keep alive
    setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send('ping');
      }
    }, 30000);

    // ==========================================================================
    // API CALLS
    // ==========================================================================
    async function fetchStatus() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        if (res.ok) {
          const data = await res.json();
          running = data.running;
          dreamCount = data.dream_count || 0;
          seekCount = data.seek_count || 0;
          capCount = data.capabilities?.length || 0;
          updateStats();
          updateToggleButton();
        }
      } catch (e) {
        console.error('Failed to fetch status:', e);
      }
    }

    async function startByrd() {
      try {
        await fetch(`${API_BASE}/api/start`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to start:', e);
      }
    }

    async function stopByrd() {
      try {
        await fetch(`${API_BASE}/api/stop`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to stop:', e);
      }
    }

    async function resetByrd() {
      try {
        const res = await fetch(`${API_BASE}/api/reset`, { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          // Note: events are cleared by the system_reset WebSocket event handler
          // Don't clear here or we'll wipe out the awakening events that arrive via WebSocket
          await fetchStatus();
        }
        return data;
      } catch (e) {
        console.error('Failed to reset:', e);
        return { success: false, message: 'Reset failed' };
      }
    }

    // ==========================================================================
    // EVENT HANDLING
    // ==========================================================================
    function handleEvent(event) {
      events.unshift(event);
      if (events.length > 500) events.pop();
      renderHistory();

      // Update visualization based on event type
      switch (event.type) {
        case 'dream_cycle_start':
          setPhase('recall');
          dreamCount = event.data?.cycle || dreamCount + 1;
          updateStatus('dreaming', `Dream cycle ${dreamCount} · Reflecting`);
          break;
        case 'dream_cycle_end':
          setPhase('idle');
          updateStatus('idle');
          break;
        case 'belief_created':
          beliefCount++;
          const beliefConfidence = event.data?.confidence || 0.7;
          createNode('belief', event.data?.content, event.data?.id, beliefConfidence);
          showEmergence('belief', event.data?.content, beliefConfidence);
          updateStatus('belief_formed');
          // Return to idle after a moment
          setTimeout(() => { if (currentStatusType === 'belief_formed') updateStatus('idle'); }, 3000);
          break;
        case 'desire_created':
          const desireIntensity = event.data?.intensity || 0.5;
          desires.unshift({
            text: event.data?.description,
            type: event.data?.type,
            intensity: desireIntensity
          });
          if (desires.length > 5) desires.pop();
          updateDesireGarden();
          createNode('desire', event.data?.description, event.data?.id, desireIntensity);
          showEmergence('desire', event.data?.description, desireIntensity);
          updateStatus('desire_emerged');
          setTimeout(() => { if (currentStatusType === 'desire_emerged') updateStatus('idle'); }, 3000);
          break;
        case 'experience_created':
          createNode('experience', event.data?.content, event.data?.id, 0.5);
          updateStatus('experience_recorded');
          setTimeout(() => { if (currentStatusType === 'experience_recorded') updateStatus('idle'); }, 2000);
          break;
        case 'capability_added':
          createNode('capability', event.data?.name, event.data?.id, 0.8);
          capCount++;
          updateStatus('capability_gained');
          setTimeout(() => { if (currentStatusType === 'capability_gained') updateStatus('idle'); }, 3000);
          break;
        case 'awakening':
          setPhase('idle');
          dreamCount = 0;
          beliefCount = 0;
          desires = [];
          updateDesireGarden();
          clearVisualization();
          updateStatus('awakening');
          setTimeout(() => { if (currentStatusType === 'awakening') updateStatus('idle'); }, 4000);
          break;
        case 'system_started':
          running = true;
          updateToggleButton();
          updateStatus('idle');
          break;
        case 'system_stopped':
          running = false;
          updateToggleButton();
          updateStatus('stopped');
          break;
        case 'system_reset':
          // Reset all counters
          dreamCount = 0;
          seekCount = 0;
          capCount = 0;
          beliefCount = 0;
          // Clear visualization and events
          events = [];
          renderHistory();
          clearVisualization();
          desires = [];
          updateDesireGarden();
          updateStatus('reset');
          break;
        case 'seek_cycle_start':
          seekCount++;
          updateStatus('seeking');
          break;
        case 'seek_cycle_end':
          if (currentStatusType === 'seeking' || currentStatusType === 'researching') {
            updateStatus('idle');
          }
          break;
        case 'research_start':
          updateStatus('researching');
          break;
        case 'research_complete':
          updateStatus('idle');
          break;
        case 'desire_attempt_failed':
          updateStatus('attempt_failed');
          setTimeout(() => { if (currentStatusType === 'attempt_failed') updateStatus('idle'); }, 2000);
          break;
        case 'desire_reflected':
          updateStatus('desire_reflected');
          setTimeout(() => { if (currentStatusType === 'desire_reflected') updateStatus('idle'); }, 3000);
          break;
        case 'desire_stuck':
          updateStatus('attempt_failed', 'Desire blocked · Awaiting reflection');
          break;
      }

      updateStats();
    }

    // ==========================================================================
    // UI UPDATES
    // ==========================================================================
    function updateConnectionStatus() {
      if (connected) {
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-green-500/10 border border-green-500/30';
        connectionDot.className = 'w-2 h-2 rounded-full bg-green-400 animate-pulse';
        connectionText.className = 'text-xs text-green-400';
        connectionText.textContent = 'Connected';
      } else {
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30';
        connectionDot.className = 'w-2 h-2 rounded-full bg-red-400';
        connectionText.className = 'text-xs text-red-400';
        connectionText.textContent = 'Disconnected';
      }
    }

    function updateToggleButton() {
      if (running) {
        btnToggle.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-amber-500/20 border border-amber-500/30 text-amber-400 hover:bg-amber-500/30 transition-all';
        btnToggle.innerHTML = '&#10074;&#10074; Pause';
      } else {
        btnToggle.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all';
        btnToggle.innerHTML = '&#9654; Start';
      }
    }

    function updateStats() {
      document.getElementById('dream-count').textContent = dreamCount;
      document.getElementById('seek-count').textContent = seekCount;
      document.getElementById('cap-count').textContent = capCount;
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function formatFullTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString('en-US', {
        month: 'short', day: 'numeric', year: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
    }

    function syntaxHighlight(json) {
      if (typeof json !== 'string') {
        json = JSON.stringify(json, null, 2);
      }
      return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
        let cls = 'json-number';
        if (/^"/.test(match)) {
          if (/:$/.test(match)) {
            cls = 'json-key';
          } else {
            cls = 'json-string';
          }
        } else if (/true|false/.test(match)) {
          cls = 'json-boolean';
        } else if (/null/.test(match)) {
          cls = 'json-null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
      });
    }

    function showEventModal(event) {
      const config = EVENT_CONFIG[event.type] || { icon: '&#8226;', color: 'text-slate-400', label: event.type };

      modalIcon.innerHTML = config.icon;
      modalType.innerHTML = `<span class="${config.color}">${config.label}</span>`;
      modalTime.textContent = formatFullTime(event.timestamp);
      modalHeader.className = `flex items-center justify-between p-4 border-b border-slate-700 ${config.bg || 'bg-slate-800/50'}`;

      // Format the full event data
      const fullData = {
        type: event.type,
        timestamp: event.timestamp,
        data: event.data
      };
      modalJson.innerHTML = syntaxHighlight(JSON.stringify(fullData, null, 2));

      eventModal.classList.remove('hidden');
      eventModal.classList.add('flex');
    }

    function hideEventModal() {
      eventModal.classList.add('hidden');
      eventModal.classList.remove('flex');
    }

    function getEventSummary(event) {
      const data = event.data || {};
      switch (event.type) {
        case 'experience_created':
          return (data.content || '').slice(0, 50) + (data.content?.length > 50 ? '...' : '');
        case 'belief_created':
          return (data.content || '').slice(0, 50) + (data.content?.length > 50 ? '...' : '');
        case 'desire_created':
          return `[${data.type}] ${(data.description || '').slice(0, 40)}...`;
        case 'dream_cycle_start':
          return `Cycle #${data.cycle}`;
        case 'dream_cycle_end':
          return `${data.insights || 0} insights, ${data.new_beliefs || 0} beliefs, ${data.new_desires || 0} desires`;
        case 'seek_cycle_start':
          return `[${data.type}] ${(data.description || '').slice(0, 35)}...`;
        case 'awakening':
          return `"${data.seed_question}"`;
        case 'system_reset':
          return data.message || 'Memory cleared';
        // Desire lifecycle events (reflective failure processing)
        case 'desire_attempt_failed':
          return `${(data.description || '').slice(0, 30)}...: ${data.failure_type} (attempt #${data.attempt_count})`;
        case 'desire_stuck':
          return `${(data.description || '').slice(0, 35)}... needs reflection`;
        case 'desire_reflected':
          return `${data.action}: ${(data.desire_id || '').slice(0, 8)}...`;
        case 'desire_intensity_changed':
          return `${(data.desire_id || '').slice(0, 8)}... → ${data.new_intensity?.toFixed(2) || '?'}`;
        case 'seek_cycle_end':
          return `${data.outcome || 'unknown'}: ${(data.reason || data.type || '').slice(0, 35)}`;
        default:
          return JSON.stringify(data).slice(0, 50);
      }
    }

    function renderHistory() {
      const filtered = currentFilter === 'all' ? events : events.filter(e => e.type === currentFilter);

      if (filtered.length === 0) {
        historyPanel.innerHTML = `<div class="text-center text-slate-600 text-xs py-8">
          ${connected ? 'No events yet. Start BYRD to see activity.' : 'Connecting to BYRD...'}
        </div>`;
      } else {
        historyPanel.innerHTML = filtered.map((event, i) => {
          const config = EVENT_CONFIG[event.type] || { icon: '&#8226;', color: 'text-slate-400', bg: 'bg-slate-500/10', label: event.type };
          return `
            <div class="event-item ${config.bg} rounded p-2 transition-all hover:bg-slate-700/30" data-event-index="${i}">
              <div class="flex items-start gap-2">
                <span class="text-sm">${config.icon}</span>
                <div class="flex-1 min-w-0">
                  <div class="flex items-center gap-2">
                    <span class="text-xs font-mono ${config.color}">${config.label}</span>
                    <span class="text-xs text-slate-600">${formatTime(event.timestamp)}</span>
                  </div>
                  <div class="text-xs text-slate-400 mt-0.5 truncate">${getEventSummary(event)}</div>
                </div>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers to event items
        historyPanel.querySelectorAll('.event-item').forEach(el => {
          el.addEventListener('click', () => {
            const index = parseInt(el.dataset.eventIndex);
            const filteredEvents = currentFilter === 'all' ? events : events.filter(e => e.type === currentFilter);
            if (filteredEvents[index]) {
              showEventModal(filteredEvents[index]);
            }
          });
        });
      }

      eventCountEl.textContent = `${filtered.length} / ${events.length}`;
    }

    // ==========================================================================
    // VISUALIZATION (enhanced)
    // ==========================================================================
    let visualNodes = [];
    let ambientParticles = [];
    const centerX = () => (window.innerWidth - 320) / 2;  // Account for sidebar
    const centerY = () => window.innerHeight / 2;

    // Color configurations
    const NODE_COLORS = {
      belief: { bg: '#f59e0b', glow: 'rgba(245, 158, 11, 0.5)', border: 'rgba(251, 191, 36, 0.6)', label: 'BELIEF' },
      desire: { bg: '#f43f5e', glow: 'rgba(244, 63, 94, 0.5)', border: 'rgba(251, 113, 133, 0.6)', label: 'DESIRE' },
      experience: { bg: '#3b82f6', glow: 'rgba(59, 130, 246, 0.5)', border: 'rgba(96, 165, 250, 0.6)', label: 'EXPERIENCE' },
      capability: { bg: '#a855f7', glow: 'rgba(168, 85, 247, 0.5)', border: 'rgba(192, 132, 252, 0.6)', label: 'CAPABILITY' }
    };

    // ==========================================================================
    // MOLECULAR SIMULATION ENGINE (Phase 1)
    // ==========================================================================
    class MolecularSimulation {
      constructor() {
        this.nodes = [];          // Physics nodes: { id, x, y, vx, vy, mass, el, type }
        this.springs = [];        // Connections: { source, target, restLength, strength }
        this.running = false;
        this.animationId = null;

        // Physics configuration
        this.config = {
          repulsion: 4000,          // How strongly nodes push apart
          attraction: 0.04,         // Spring strength for connections
          idealDistance: 100,       // Target distance between connected nodes
          damping: 0.92,            // Velocity decay per frame (0.9 = 10% loss)
          centerGravity: 0.008,     // Pull toward center
          maxVelocity: 6,           // Speed limit for smooth motion
          minVelocity: 0.01,        // Below this, node is considered stable
          boundaryPadding: 80       // Keep nodes away from edges
        };
      }

      // Add a node to the simulation
      addNode(id, x, y, el, type, importance = 0.5) {
        // Mass based on importance (heavier = moves slower)
        const mass = 1 + importance * 2;

        const node = {
          id,
          x,
          y,
          vx: 0,
          vy: 0,
          mass,
          el,
          type,
          importance,
          fx: null,  // Fixed x (if pinned)
          fy: null   // Fixed y (if pinned)
        };

        this.nodes.push(node);
        return node;
      }

      // Add a spring connection between two nodes
      addSpring(sourceId, targetId, strength = null) {
        const source = this.nodes.find(n => n.id === sourceId);
        const target = this.nodes.find(n => n.id === targetId);

        if (!source || !target) return null;

        // Calculate current distance as rest length
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const restLength = Math.sqrt(dx * dx + dy * dy) || this.config.idealDistance;

        const spring = {
          source,
          target,
          restLength: Math.min(restLength, this.config.idealDistance * 1.5),
          strength: strength || this.config.attraction
        };

        this.springs.push(spring);
        return spring;
      }

      // Remove a node and its connections
      removeNode(id) {
        this.nodes = this.nodes.filter(n => n.id !== id);
        this.springs = this.springs.filter(s => s.source.id !== id && s.target.id !== id);
      }

      // Apply all forces for one tick
      tick() {
        const { repulsion, damping, centerGravity, maxVelocity, boundaryPadding } = this.config;
        const cx = centerX();
        const cy = centerY();
        const boundaryLeft = boundaryPadding;
        const boundaryRight = (window.innerWidth - 320) - boundaryPadding;
        const boundaryTop = boundaryPadding;
        const boundaryBottom = window.innerHeight - boundaryPadding;

        // Apply forces to each node
        for (const node of this.nodes) {
          if (node.fx !== null && node.fy !== null) continue; // Skip pinned nodes

          let fx = 0;
          let fy = 0;

          // 1. Repulsion from all other nodes (inverse square law)
          for (const other of this.nodes) {
            if (other.id === node.id) continue;

            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq) || 1;

            // Stronger repulsion when close
            const force = repulsion / distSq;
            fx += (dx / dist) * force;
            fy += (dy / dist) * force;
          }

          // 2. Attraction from springs (Hooke's law)
          for (const spring of this.springs) {
            let other, isSource;
            if (spring.source.id === node.id) {
              other = spring.target;
              isSource = true;
            } else if (spring.target.id === node.id) {
              other = spring.source;
              isSource = false;
            } else {
              continue;
            }

            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

            // Spring force: pull toward rest length
            const displacement = dist - spring.restLength;
            const force = displacement * spring.strength;

            fx += (dx / dist) * force;
            fy += (dy / dist) * force;
          }

          // 3. Gentle gravity toward center
          fx += (cx - node.x) * centerGravity;
          fy += (cy - node.y) * centerGravity;

          // 4. Boundary repulsion (soft walls)
          if (node.x < boundaryLeft) fx += (boundaryLeft - node.x) * 0.1;
          if (node.x > boundaryRight) fx += (boundaryRight - node.x) * 0.1;
          if (node.y < boundaryTop) fy += (boundaryTop - node.y) * 0.1;
          if (node.y > boundaryBottom) fy += (boundaryBottom - node.y) * 0.1;

          // Update velocity (F = ma, a = F/m)
          node.vx = (node.vx + fx / node.mass) * damping;
          node.vy = (node.vy + fy / node.mass) * damping;

          // Clamp velocity
          const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
          if (speed > maxVelocity) {
            node.vx = (node.vx / speed) * maxVelocity;
            node.vy = (node.vy / speed) * maxVelocity;
          }

          // Update position
          node.x += node.vx;
          node.y += node.vy;
        }
      }

      // Render all nodes to DOM
      render() {
        for (const node of this.nodes) {
          if (node.el) {
            node.el.style.left = `${node.x}px`;
            node.el.style.top = `${node.y}px`;
          }
        }
        this.renderSprings();
      }

      // Update SVG connection lines
      renderSprings() {
        const lines = connectionsContainer.querySelectorAll('line');
        let lineIndex = 0;

        for (const spring of this.springs) {
          if (lineIndex < lines.length) {
            const line = lines[lineIndex];
            line.setAttribute('x1', spring.source.x);
            line.setAttribute('y1', spring.source.y);
            line.setAttribute('x2', spring.target.x);
            line.setAttribute('y2', spring.target.y);
          }
          lineIndex++;
        }
      }

      // Calculate total kinetic energy (for stability detection)
      kineticEnergy() {
        return this.nodes.reduce((sum, n) => {
          return sum + n.mass * (n.vx * n.vx + n.vy * n.vy);
        }, 0);
      }

      // Check if simulation is stable
      isStable() {
        return this.kineticEnergy() < this.config.minVelocity * this.nodes.length;
      }

      // Animation loop
      animate = () => {
        if (!this.running) return;

        // Run multiple physics iterations per frame for stability
        const iterations = 2;
        for (let i = 0; i < iterations; i++) {
          this.tick();
        }

        this.render();
        this.animationId = requestAnimationFrame(this.animate);
      }

      // Start the simulation
      start() {
        if (this.running) return;
        this.running = true;
        this.animate();
      }

      // Stop the simulation
      stop() {
        this.running = false;
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      // Reset everything
      reset() {
        this.stop();
        this.nodes = [];
        this.springs = [];
      }

      // Give all nodes a gentle push (for reorganization)
      nudge(strength = 2) {
        for (const node of this.nodes) {
          node.vx += (Math.random() - 0.5) * strength;
          node.vy += (Math.random() - 0.5) * strength;
        }
      }
    }

    // Create global simulation instance
    const simulation = new MolecularSimulation();

    // ==========================================================================
    // REACTIVE ORB
    // ==========================================================================
    function reactOrb(type, intensity = 1) {
      const colors = {
        belief: 'rgba(245, 158, 11, 0.4)',
        desire: 'rgba(244, 63, 94, 0.4)',
        experience: 'rgba(59, 130, 246, 0.4)',
        capability: 'rgba(168, 85, 247, 0.4)',
        dream: 'rgba(99, 102, 241, 0.5)',
        default: 'rgba(139, 92, 246, 0.4)'
      };

      const color = colors[type] || colors.default;

      // Pulse the core
      pulseCore.style.boxShadow = `0 0 ${30 * intensity}px ${color}`;
      pulseCore.style.transform = `scale(${1.5 * intensity})`;

      // Expand inner pulse
      pulseInner.style.transform = `scale(${1.3 * intensity})`;
      pulseInner.style.opacity = '0.9';

      // Create ripple
      createRipple(color);

      // Reset after animation
      setTimeout(() => {
        pulseCore.style.boxShadow = '0 0 20px rgba(167,139,250,0.8)';
        pulseCore.style.transform = 'scale(1)';
        pulseInner.style.transform = 'scale(1)';
        pulseInner.style.opacity = '0.6';
      }, 800);
    }

    function createRipple(color) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.cssText = `
        width: 60px;
        height: 60px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 2px solid ${color};
      `;
      ripplesContainer.appendChild(ripple);
      setTimeout(() => ripple.remove(), 1500);
    }

    function setOrbDreaming(isDreaming) {
      if (isDreaming) {
        pulseOuter.style.animation = 'breatheFast 2s ease-in-out infinite';
        pulseMiddle.style.animation = 'breatheFast 1.5s ease-in-out infinite 0.2s';
        pulseInner.style.animation = 'breatheFast 1.2s ease-in-out infinite 0.4s';
        pulseCore.style.boxShadow = '0 0 30px rgba(99, 102, 241, 0.9)';
      } else {
        pulseOuter.style.animation = 'breathe 4s ease-in-out infinite';
        pulseMiddle.style.animation = 'breathe 3s ease-in-out infinite 0.5s';
        pulseInner.style.animation = 'breatheInner 2.5s ease-in-out infinite 0.2s';
        pulseCore.style.boxShadow = '0 0 20px rgba(167,139,250,0.8)';
      }
    }

    // ==========================================================================
    // AMBIENT PARTICLES
    // ==========================================================================
    function initAmbientParticles() {
      const count = 25;
      for (let i = 0; i < count; i++) {
        createAmbientParticle();
      }
    }

    function createAmbientParticle() {
      const particle = document.createElement('div');
      const size = 2 + Math.random() * 3;
      const x = Math.random() * (window.innerWidth - 320);
      const y = Math.random() * window.innerHeight;
      const delay = Math.random() * 8;
      const duration = 6 + Math.random() * 6;

      particle.className = 'ambient-particle';
      particle.style.cssText = `
        width: ${size}px;
        height: ${size}px;
        left: ${x}px;
        top: ${y}px;
        background: rgba(139, 92, 246, ${0.2 + Math.random() * 0.3});
        animation-delay: ${delay}s;
        animation-duration: ${duration}s;
      `;

      particlesContainer.appendChild(particle);
      ambientParticles.push(particle);
    }

    function emitParticleBurst(targetX, targetY, color, count = 8) {
      const cx = centerX();
      const cy = centerY();

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        const angle = (i / count) * Math.PI * 2;
        const distance = 30 + Math.random() * 50;
        const startX = cx + Math.cos(angle) * distance;
        const startY = cy + Math.sin(angle) * distance;

        particle.className = 'particle-burst';
        particle.style.cssText = `
          width: 4px;
          height: 4px;
          left: ${startX}px;
          top: ${startY}px;
          background: ${color};
          --drift-x: ${targetX - startX}px;
          --drift-y: ${targetY - startY}px;
        `;

        particlesContainer.appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      }
    }

    // ==========================================================================
    // ENHANCED NODE CREATION (with Molecular Simulation)
    // ==========================================================================
    function createNode(type, content, id, importance = 0.5) {
      const nodeId = id || `node_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      // Calculate initial spawn position (will be adjusted by physics)
      const angle = (visualNodes.length * 0.618 * 2 * Math.PI) + Math.random() * 0.5;
      const radius = 100 + Math.random() * 80 + (visualNodes.length * 4);
      const x = centerX() + Math.cos(angle) * radius;
      const y = centerY() + Math.sin(angle) * radius;

      const color = NODE_COLORS[type] || NODE_COLORS.experience;

      // Size based on importance (8px to 16px)
      const baseSize = 8 + (importance * 8);

      const node = document.createElement('div');
      node.className = 'node-new absolute rounded-full cursor-pointer';
      node.style.cssText = `
        left: ${x}px;
        top: ${y}px;
        width: ${baseSize}px;
        height: ${baseSize}px;
        background: ${color.bg};
        border: 2px solid ${color.border};
        box-shadow: 0 0 ${12 + importance * 12}px ${color.glow};
        color: ${color.glow};
        z-index: 10;
        transition: width 0.3s, height 0.3s, box-shadow 0.3s;
      `;

      node.dataset.nodeId = nodeId;
      node.dataset.nodeType = type;
      node.dataset.content = content || '';
      node.dataset.importance = importance;

      // Click to show modal
      node.addEventListener('click', () => {
        const event = events.find(e =>
          (e.type === `${type}_created` && (e.data?.id === id || e.data?.content === content || e.data?.description === content))
        );
        if (event) showEventModal(event);
      });

      // Hover tooltip
      node.addEventListener('mouseenter', (e) => showNodeTooltip(e, node, type, content, importance));
      node.addEventListener('mousemove', (e) => moveTooltip(e));
      node.addEventListener('mouseleave', hideNodeTooltip);

      nodesContainer.appendChild(node);

      // Add to simulation physics
      simulation.addNode(nodeId, x, y, node, type, importance);

      // Store in visualNodes for compatibility
      visualNodes.push({ el: node, x, y, type, id: nodeId, content, importance, createdAt: Date.now() });

      // React the orb
      reactOrb(type, 0.7 + importance * 0.5);

      // Emit particles toward the new node
      emitParticleBurst(x, y, color.glow);

      // Create connections to nearby nodes (using node IDs for springs)
      if (visualNodes.length > 1) {
        // Connect to 1-2 nearby nodes for molecular structure
        const connectCount = Math.min(visualNodes.length - 1, 1 + Math.floor(Math.random() * 2));
        const candidates = visualNodes.slice(0, -1).slice(-5); // Last 5 nodes

        for (let i = 0; i < connectCount && i < candidates.length; i++) {
          const targetIdx = Math.floor(Math.random() * candidates.length);
          const target = candidates[targetIdx];
          if (target && target.id !== nodeId) {
            createConnection(nodeId, target.id, type);
            candidates.splice(targetIdx, 1); // Don't connect twice
          }
        }
      }

      // Settle node after pulse animation
      setTimeout(() => {
        node.classList.remove('node-new');
        node.classList.add('node-settled');
      }, 6600);

      // Limit visible nodes - remove from simulation too
      if (visualNodes.length > 50) {
        const old = visualNodes.shift();
        simulation.removeNode(old.id);
        old.el.style.opacity = '0';
        old.el.style.transform = 'scale(0.5)';
        setTimeout(() => old.el.remove(), 500);
      }

      // Give a little nudge to reorganize
      simulation.nudge(1);

      return node;
    }

    function createConnection(sourceId, targetId, type) {
      const sourceNode = simulation.nodes.find(n => n.id === sourceId);
      const targetNode = simulation.nodes.find(n => n.id === targetId);

      if (!sourceNode || !targetNode) return;

      const color = NODE_COLORS[type]?.glow || 'rgba(99, 102, 241, 0.3)';

      // Add spring to simulation
      simulation.addSpring(sourceId, targetId);

      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', sourceNode.x);
      line.setAttribute('y1', sourceNode.y);
      line.setAttribute('x2', targetNode.x);
      line.setAttribute('y2', targetNode.y);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('stroke-opacity', '0.4');
      line.classList.add('connection');
      line.dataset.sourceId = sourceId;
      line.dataset.targetId = targetId;

      connectionsContainer.appendChild(line);

      // Limit connections
      const connections = connectionsContainer.querySelectorAll('line');
      if (connections.length > 100) {
        connections[0].remove();
      }
    }

    // ==========================================================================
    // TOOLTIP
    // ==========================================================================
    function showNodeTooltip(e, node, type, content, importance) {
      const color = NODE_COLORS[type] || NODE_COLORS.experience;

      tooltipType.textContent = color.label;
      tooltipType.style.color = color.bg;

      tooltipContent.textContent = content?.slice(0, 200) || 'No content';

      const importancePercent = Math.round(importance * 100);
      tooltipMeta.innerHTML = `
        <span>Importance: ${importancePercent}%</span>
        <span style="margin-left: 12px;">Click for details</span>
      `;

      nodeTooltip.style.borderColor = color.glow;
      nodeTooltip.classList.add('visible');
      moveTooltip(e);
    }

    function moveTooltip(e) {
      const x = e.clientX + 15;
      const y = e.clientY + 15;

      // Keep tooltip in viewport
      const rect = nodeTooltip.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width - 20;
      const maxY = window.innerHeight - rect.height - 20;

      nodeTooltip.style.left = `${Math.min(x, maxX)}px`;
      nodeTooltip.style.top = `${Math.min(y, maxY)}px`;
    }

    function hideNodeTooltip() {
      nodeTooltip.classList.remove('visible');
    }

    // ==========================================================================
    // CLEAR & PHASE
    // ==========================================================================
    function clearVisualization() {
      visualNodes = [];
      nodesContainer.innerHTML = '';
      connectionsContainer.innerHTML = '';
    }

    function setPhase(phase) {
      currentPhase = phase;
      const phases = ['recall', 'associate', 'reflect', 'form'];
      const phaseIndex = phases.indexOf(phase);

      // Update orb based on phase
      if (phase === 'idle') {
        setOrbDreaming(false);
      } else {
        setOrbDreaming(true);
      }

      // Phase 2: Apply phase class to app container for canvas effects
      appContainer.classList.remove('phase-recall', 'phase-associate', 'phase-reflect', 'phase-form');
      if (phase !== 'idle') {
        appContainer.classList.add(`phase-${phase}`);
      }

      // Phase 2: Animate nebulas based on phase
      animateNebulasForPhase(phase);

      phases.forEach((p, i) => {
        const dot = document.getElementById(`dot-${p}`);
        const span = dot?.nextElementSibling;
        if (!dot) return;
        if (i < phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 transition-colors duration-300';
          if (span) span.className = 'text-indigo-400';
        } else if (i === phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 animate-pulse transition-colors duration-300';
          if (span) span.className = 'text-indigo-400 font-medium';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300';
          if (span) span.className = 'text-slate-600';
        }
      });
    }

    // ==========================================================================
    // PHASE 2: NEBULAS & ATMOSPHERE
    // ==========================================================================
    function initNebulas() {
      const cx = centerX();
      const cy = centerY();

      // Position nebulas around the center
      nebula1.style.cssText = `
        width: 400px; height: 400px;
        left: ${cx - 300}px; top: ${cy - 200}px;
      `;
      nebula2.style.cssText = `
        width: 350px; height: 350px;
        left: ${cx + 100}px; top: ${cy - 150}px;
      `;
      nebula3.style.cssText = `
        width: 300px; height: 300px;
        left: ${cx - 100}px; top: ${cy + 100}px;
      `;

      // Start slow drift animation
      driftNebulas();
    }

    function driftNebulas() {
      let time = 0;
      setInterval(() => {
        time += 0.01;
        const cx = centerX();
        const cy = centerY();

        nebula1.style.left = `${cx - 300 + Math.sin(time * 0.5) * 30}px`;
        nebula1.style.top = `${cy - 200 + Math.cos(time * 0.3) * 20}px`;

        nebula2.style.left = `${cx + 100 + Math.cos(time * 0.4) * 25}px`;
        nebula2.style.top = `${cy - 150 + Math.sin(time * 0.6) * 25}px`;

        nebula3.style.left = `${cx - 100 + Math.sin(time * 0.7) * 20}px`;
        nebula3.style.top = `${cy + 100 + Math.cos(time * 0.5) * 30}px`;
      }, 50);
    }

    function animateNebulasForPhase(phase) {
      const intensity = {
        idle: 0.1,
        recall: 0.2,
        associate: 0.25,
        reflect: 0.35,
        form: 0.3
      };
      const opacity = intensity[phase] || 0.15;

      nebula1.style.opacity = opacity;
      nebula2.style.opacity = opacity * 0.9;
      nebula3.style.opacity = opacity * 0.8;

      // During reflect phase, make nebulas more purple
      if (phase === 'reflect') {
        nebula1.style.filter = 'blur(60px) hue-rotate(20deg)';
        nebula2.style.filter = 'blur(60px) hue-rotate(15deg)';
      } else {
        nebula1.style.filter = 'blur(60px)';
        nebula2.style.filter = 'blur(60px)';
      }
    }

    // ==========================================================================
    // PHASE 2: CONNECTION FLOW PARTICLES
    // ==========================================================================
    let connectionFlowInterval = null;

    function startConnectionFlow() {
      if (connectionFlowInterval) return;

      connectionFlowInterval = setInterval(() => {
        // Only emit particles when dreaming
        if (currentPhase === 'idle') return;

        const lines = connectionsContainer.querySelectorAll('line');
        if (lines.length === 0) return;

        // Pick a random connection to animate
        const line = lines[Math.floor(Math.random() * lines.length)];
        createConnectionFlowParticle(line);
      }, 300);
    }

    function createConnectionFlowParticle(line) {
      const x1 = parseFloat(line.getAttribute('x1'));
      const y1 = parseFloat(line.getAttribute('y1'));
      const x2 = parseFloat(line.getAttribute('x2'));
      const y2 = parseFloat(line.getAttribute('y2'));
      const color = line.getAttribute('stroke');

      const particle = document.createElement('div');
      particle.className = 'connection-particle';

      // Create SVG path for offset-path
      const pathId = `flow-path-${Date.now()}-${Math.random()}`;
      const pathSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      pathSvg.style.cssText = 'position:absolute;width:0;height:0;';
      pathSvg.innerHTML = `<path id="${pathId}" d="M ${x1} ${y1} L ${x2} ${y2}"/>`;
      flowParticlesContainer.appendChild(pathSvg);

      particle.style.cssText = `
        background: ${color};
        box-shadow: 0 0 6px ${color};
        offset-path: path('M ${x1} ${y1} L ${x2} ${y2}');
        animation-duration: ${1 + Math.random()}s;
      `;

      flowParticlesContainer.appendChild(particle);

      // Cleanup after animation
      setTimeout(() => {
        particle.remove();
        pathSvg.remove();
      }, 2000);
    }

    // ==========================================================================
    // PHASE 2: NODE AGING
    // ==========================================================================
    function updateNodeAging() {
      const now = Date.now();
      const maxAge = 120000; // 2 minutes to full fade

      visualNodes.forEach((nodeData, index) => {
        const age = now - (nodeData.createdAt || now);
        const ageFactor = Math.min(age / maxAge, 1);

        // Fade opacity from 1 to 0.3 over time
        const opacity = 1 - (ageFactor * 0.7);
        // Slight blur for very old nodes
        const blur = ageFactor > 0.8 ? `blur(${(ageFactor - 0.8) * 3}px)` : 'none';

        nodeData.el.style.opacity = opacity;
        nodeData.el.style.filter = blur;

        // Mark as aged for styling
        if (ageFactor > 0.3 && !nodeData.el.classList.contains('node-aged')) {
          nodeData.el.classList.add('node-aged');
        }
      });
    }

    // Start node aging timer
    setInterval(updateNodeAging, 5000);

    function showEmergence(type, content, value) {
      const isDesire = type === 'desire';
      emergencePanel.innerHTML = `
        <div class="${isDesire ? 'bg-rose-950/90 border-rose-500/30' : 'bg-amber-950/90 border-amber-500/30'} backdrop-blur-sm rounded-lg border p-4">
          <div class="text-xs font-mono mb-2 ${isDesire ? 'text-rose-400' : 'text-amber-400'}">
            ${isDesire ? '&#10024; NEW DESIRE' : '&#9670; NEW BELIEF'}
          </div>
          <div class="text-white text-sm leading-relaxed mb-3">"${content || 'Unknown'}"</div>
          <div class="flex items-center gap-2">
            <span class="text-xs text-slate-400">${isDesire ? 'Intensity' : 'Confidence'}</span>
            <div class="flex-1 h-1.5 bg-slate-700 rounded-full overflow-hidden">
              <div class="h-full rounded-full ${isDesire ? 'bg-rose-400' : 'bg-amber-400'}" style="width: ${(value || 0.5) * 100}%"></div>
            </div>
            <span class="text-xs ${isDesire ? 'text-rose-400' : 'text-amber-400'}">${Math.round((value || 0.5) * 100)}%</span>
          </div>
        </div>
      `;
      emergencePanel.classList.remove('opacity-0', '-translate-y-4');
      emergencePanel.classList.add('opacity-100', 'translate-y-0');

      setTimeout(() => {
        emergencePanel.classList.add('opacity-0', '-translate-y-4');
        emergencePanel.classList.remove('opacity-100', 'translate-y-0');
      }, 4000);
    }

    function updateDesireGarden() {
      desireGarden.innerHTML = '';
      desires.slice(0, 5).forEach((desire, i) => {
        const dot = document.createElement('div');
        dot.className = 'w-3 h-3 rounded-full bg-rose-400 cursor-pointer hover:scale-125 transition-transform';
        dot.style.cssText = `
          box-shadow: 0 0 ${(desire.intensity || 0.5) * 15}px rgba(244,114,182,${desire.intensity || 0.5});
          animation: desirePulse ${2 / (desire.intensity || 0.5)}s ease-in-out infinite;
        `;
        dot.title = desire.text || 'Unknown desire';
        desireGarden.appendChild(dot);
      });
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    btnToggle.addEventListener('click', () => {
      if (running) {
        stopByrd();
      } else {
        startByrd();
      }
    });

    btnReset.addEventListener('click', async () => {
      if (!resetConfirm) {
        resetConfirm = true;
        btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-red-500/30 border border-red-500/50 text-red-300 animate-pulse transition-all';
        btnReset.innerHTML = '&#9888; Confirm Reset?';
        resetTimeout = setTimeout(() => {
          resetConfirm = false;
          btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
          btnReset.innerHTML = '&#128260; Reset';
        }, 3000);
        return;
      }

      clearTimeout(resetTimeout);
      resetConfirm = false;
      btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
      btnReset.innerHTML = '&#128260; Reset';

      const result = await resetByrd();
      // Show toast
      const toast = document.createElement('div');
      toast.className = `fixed top-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg text-sm z-50 ${
        result.success ? 'bg-green-500/20 border border-green-500/30 text-green-400' : 'bg-red-500/20 border border-red-500/30 text-red-400'
      }`;
      toast.textContent = result.message || (result.success ? 'Reset complete' : 'Reset failed');
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    });

    btnClearLog.addEventListener('click', () => {
      events = [];
      renderHistory();
    });

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => {
          b.className = 'filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500';
        });
        btn.className = 'filter-btn text-xs px-2 py-1 rounded bg-indigo-500/30 text-indigo-300';
        currentFilter = btn.dataset.filter;
        renderHistory();
      });
    });

    // Modal close handlers
    modalClose.addEventListener('click', hideEventModal);

    eventModal.addEventListener('click', (e) => {
      if (e.target === eventModal) {
        hideEventModal();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !eventModal.classList.contains('hidden')) {
        hideEventModal();
      }
    });

    // ==========================================================================
    // INIT
    // ==========================================================================
    function init() {
      connectWebSocket();
      fetchStatus();
      setInterval(fetchStatus, 10000);
      renderHistory();
      initAmbientParticles();
      initNebulas();
      startConnectionFlow();
      // Start node aging check every 30 seconds
      setInterval(updateNodeAging, 30000);
    }

    init();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BYRD - Watch the Dream</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes breathe {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.15); opacity: 0.7; }
    }
    @keyframes breatheInner {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.2); opacity: 0.9; }
    }
    @keyframes breatheFast {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.25); opacity: 0.9; }
    }
    @keyframes orbReact {
      0% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.4); filter: brightness(1.5); }
      100% { transform: scale(1); filter: brightness(1); }
    }
    @keyframes orbRipple {
      0% { transform: scale(0.8); opacity: 0.8; }
      100% { transform: scale(3); opacity: 0; }
    }
    @keyframes nodePulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 10px currentColor; }
      50% { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 0 25px currentColor; }
    }
    @keyframes nodeSpawn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes particleFloat {
      0%, 100% { transform: translate(0, 0); opacity: 0.3; }
      25% { transform: translate(10px, -15px); opacity: 0.5; }
      50% { transform: translate(-5px, -25px); opacity: 0.4; }
      75% { transform: translate(-15px, -10px); opacity: 0.5; }
    }
    @keyframes particleDrift {
      0% { transform: translate(0, 0) scale(1); }
      100% { transform: translate(var(--drift-x), var(--drift-y)) scale(0.5); }
    }
    @keyframes particleToNode {
      0% { opacity: 0.8; }
      100% { opacity: 0; transform: translate(var(--target-x), var(--target-y)) scale(0); }
    }
    .node-new {
      animation: nodeSpawn 0.6s ease-out forwards, nodePulse 2s ease-in-out 0.6s 3;
    }
    .node-settled {
      animation: none;
      transition: all 0.3s ease;
    }
    .orb-reacting {
      animation: orbReact 0.8s ease-out !important;
    }
    .ripple {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: orbRipple 1.5s ease-out forwards;
    }
    .ambient-particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: particleFloat 8s ease-in-out infinite;
    }
    .particle-burst {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      animation: particleDrift 1s ease-out forwards;
    }

    /* Phase 2: Connection flow particles */
    @keyframes flowAlongLine {
      0% { offset-distance: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { offset-distance: 100%; opacity: 0; }
    }
    .connection-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      pointer-events: none;
      offset-rotate: 0deg;
      animation: flowAlongLine 2s linear infinite;
    }

    /* Phase 2: Node aging */
    .node-aged {
      transition: opacity 2s ease, filter 2s ease;
    }

    /* Phase 2: Phase-driven canvas effects */
    .phase-recall #nodes { filter: brightness(1.1); }
    .phase-associate #connections { filter: brightness(1.5) saturate(1.3); }
    .phase-reflect { background: radial-gradient(ellipse at center, rgba(139, 92, 246, 0.15) 0%, transparent 50%); }
    .phase-form #nodes .node-new { filter: brightness(1.3) drop-shadow(0 0 10px currentColor); }

    /* Phase 2: Background nebula */
    .nebula {
      position: absolute;
      border-radius: 50%;
      filter: blur(60px);
      opacity: 0.15;
      pointer-events: none;
      transition: all 3s ease;
    }
    .nebula-1 { background: radial-gradient(circle, rgba(99, 102, 241, 0.4) 0%, transparent 70%); }
    .nebula-2 { background: radial-gradient(circle, rgba(139, 92, 246, 0.3) 0%, transparent 70%); }
    .nebula-3 { background: radial-gradient(circle, rgba(79, 70, 229, 0.35) 0%, transparent 70%); }

    /* Phase 2: Connection glow on activity */
    .connection-active {
      stroke-opacity: 0.6 !important;
      filter: drop-shadow(0 0 3px currentColor);
      transition: all 0.3s ease;
    }

    @keyframes fadeInNode {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes fadeInLine {
      from { opacity: 0; }
      to { opacity: 0.3; }
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ========================================
       Phase 2: Entry Choreography Animations
       ======================================== */

    /* Node emerging from void - elegant entrance with blur-to-focus */
    @keyframes nodeEmerge {
      0% {
        opacity: 0;
        transform: scale(0.1);
        filter: blur(8px) brightness(2);
      }
      40% {
        opacity: 0.7;
        transform: scale(0.5);
        filter: blur(3px) brightness(1.4);
      }
      70% {
        opacity: 0.95;
        transform: scale(1.15);
        filter: blur(0) brightness(1.15);
      }
      85% {
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0) brightness(1);
      }
    }

    /* Connection grows from source toward target */
    @keyframes connectionGrow {
      0% {
        stroke-dasharray: 0, 500;
        stroke-opacity: 0;
      }
      30% {
        stroke-opacity: 0.5;
      }
      100% {
        stroke-dasharray: 500, 0;
        stroke-opacity: 0.4;
      }
    }

    /* Settling oscillation - gentle wobble after position change */
    @keyframes settleOscillate {
      0%, 100% { transform: translate(0, 0); }
      15% { transform: translate(3px, -2px); }
      30% { transform: translate(-2px, 2px); }
      45% { transform: translate(1.5px, -1px); }
      60% { transform: translate(-1px, 0.5px); }
      75% { transform: translate(0.5px, -0.3px); }
    }

    /* Elastic overshoot when node reaches destination */
    @keyframes elasticArrive {
      0% { transform: scale(0.8); opacity: 0.6; }
      50% { transform: scale(1.12); opacity: 1; }
      70% { transform: scale(0.96); }
      85% { transform: scale(1.03); }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Pulse wave that ripples outward when structure changes */
    @keyframes structureRipple {
      0% {
        box-shadow: 0 0 0 0 var(--ripple-color, rgba(139, 92, 246, 0.4));
      }
      100% {
        box-shadow: 0 0 0 20px transparent;
      }
    }

    .node-emerging {
      animation: nodeEmerge 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    .node-settling {
      animation: settleOscillate 0.5s ease-out;
    }

    .node-arriving {
      animation: elasticArrive 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .connection-growing {
      animation: connectionGrow 0.5s ease-out forwards;
    }

    .structure-ripple {
      animation: structureRipple 0.6s ease-out;
    }

    /* Smooth physics-driven transitions for nodes */
    .node-physics {
      transition: none; /* Physics handles movement */
    }

    /* ========================================
       Phase 3: Cluster Visualization
       ======================================== */

    /* Nodes in a cluster get a subtle shared glow */
    .in-cluster {
      box-shadow:
        0 0 12px var(--cluster-color, rgba(139, 92, 246, 0.2)),
        0 0 25px var(--cluster-color, rgba(139, 92, 246, 0.15)),
        0 0 40px var(--cluster-color, rgba(139, 92, 246, 0.1));
    }

    /* Cluster geometry indicator - subtle background shape */
    .cluster-shape {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.08;
      transition: all 0.5s ease;
    }

    /* Geometric shape hints - very subtle */
    @keyframes clusterPulse {
      0%, 100% { opacity: 0.06; transform: scale(1); }
      50% { opacity: 0.12; transform: scale(1.02); }
    }

    .cluster-shape.active {
      animation: clusterPulse 3s ease-in-out infinite;
    }

    /* Molecular bond enhancement for clustered connections */
    .connection.in-cluster {
      stroke-opacity: 0.5;
      stroke-width: 2;
    }

    /* ========================================
       Phase 4: Polish - Type-Specific & Effects
       ======================================== */

    /* Motion trails - ghost images following nodes */
    .motion-trail {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.4;
      filter: blur(2px);
      animation: trailFade 0.4s ease-out forwards;
    }

    @keyframes trailFade {
      0% { opacity: 0.4; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5); }
    }

    /* Type-specific node enhancements */
    .node-type-belief {
      --type-glow: rgba(245, 158, 11, 0.6);
    }
    .node-type-desire {
      --type-glow: rgba(244, 63, 94, 0.6);
    }
    .node-type-experience {
      --type-glow: rgba(59, 130, 246, 0.6);
    }
    .node-type-capability {
      --type-glow: rgba(168, 85, 247, 0.6);
    }

    /* Molecule breathing - entire structure pulses gently */
    @keyframes moleculeBreathe {
      0%, 100% {
        transform: scale(1);
        filter: brightness(1);
      }
      50% {
        transform: scale(1.008);
        filter: brightness(1.05);
      }
    }

    .molecule-breathing {
      animation: moleculeBreathe 4s ease-in-out infinite;
    }

    /* Cluster halo - soft glow behind entire cluster */
    .cluster-halo {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      filter: blur(40px);
      opacity: 0.15;
      transition: all 1s ease;
      z-index: 1;
    }

    @keyframes haloPulse {
      0%, 100% { opacity: 0.12; transform: scale(1); }
      50% { opacity: 0.18; transform: scale(1.05); }
    }

    .cluster-halo.active {
      animation: haloPulse 5s ease-in-out infinite;
    }

    /* Type-specific connection styles */
    .connection-belief {
      stroke: rgba(245, 158, 11, 0.5);
      stroke-dasharray: 4, 4;
    }
    .connection-desire {
      stroke: rgba(244, 63, 94, 0.5);
      stroke-width: 2;
    }
    .connection-experience {
      stroke: rgba(59, 130, 246, 0.4);
    }
    .connection-capability {
      stroke: rgba(168, 85, 247, 0.5);
      stroke-dasharray: 8, 4;
    }

    /* Star pattern for desire clusters */
    .desire-star-center {
      box-shadow:
        0 0 15px rgba(244, 63, 94, 0.6),
        0 0 30px rgba(244, 63, 94, 0.4),
        0 0 45px rgba(244, 63, 94, 0.2);
    }

    /* Ring glow for belief clusters */
    .belief-ring-member {
      box-shadow:
        0 0 10px rgba(245, 158, 11, 0.5),
        inset 0 0 5px rgba(245, 158, 11, 0.3);
    }

    /* Chain indicator for experience sequences */
    .experience-chain-link::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 20px;
      background: linear-gradient(to bottom, rgba(59, 130, 246, 0.5), transparent);
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
    }

    /* Floating status text - premium AI lab aesthetic */
    @keyframes statusFadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes statusPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    @keyframes statusDotPulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    .status-container {
      font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', ui-monospace, monospace;
      letter-spacing: 0.05em;
    }
    .status-text {
      animation: statusFadeIn 0.4s ease-out forwards;
    }
    .status-text.active {
      animation: statusPulse 2s ease-in-out infinite;
    }
    .status-dot {
      animation: statusDotPulse 1.5s ease-in-out infinite;
    }
    @keyframes desirePulse {
      0%, 100% { box-shadow: 0 0 10px rgba(244,114,182,0.5); }
      50% { box-shadow: 0 0 25px rgba(244,114,182,0.8); }
    }
    @keyframes shimmer {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }
    .node { animation: fadeInNode 0.8s ease-out forwards; }
    .connection { animation: fadeInLine 1s ease-out forwards; }
    .surfaced {
      background: linear-gradient(90deg, transparent, rgba(167,139,250,0.3), transparent);
      background-size: 200% 100%;
      animation: shimmer 2s infinite;
    }
    .event-item {
      cursor: pointer;
    }
    .event-item:hover {
      transform: translateX(2px);
    }
    #event-modal {
      backdrop-filter: blur(8px);
    }
    #event-modal-content {
      max-height: 80vh;
      overflow-y: auto;
    }
    #event-modal-content::-webkit-scrollbar {
      width: 6px;
    }
    #event-modal-content::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }
    #event-modal-content::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.4);
      border-radius: 3px;
    }
    .json-key { color: #93c5fd; }
    .json-string { color: #86efac; }
    .json-number { color: #fcd34d; }
    .json-boolean { color: #f9a8d4; }
    .json-null { color: #94a3b8; }

    /* Enhanced tooltips */
    .node-tooltip {
      position: fixed;
      max-width: 300px;
      padding: 12px 16px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      backdrop-filter: blur(8px);
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
    }
    .node-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .node-tooltip-type {
      font-size: 10px;
      font-family: monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .node-tooltip-content {
      font-size: 13px;
      line-height: 1.5;
      color: #e2e8f0;
    }
    .node-tooltip-meta {
      font-size: 11px;
      color: #64748b;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(99, 102, 241, 0.2);
    }
    body {
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
    }
    #history-panel::-webkit-scrollbar {
      width: 4px;
    }
    #history-panel::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }
    #history-panel::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 2px;
    }
  </style>
</head>
<body class="bg-slate-950 text-white overflow-hidden h-screen w-screen touch-none select-none">

  <div id="app" class="relative w-full h-full">
    <!-- Background glow -->
    <div class="absolute inset-0 bg-gradient-radial from-indigo-950/20 via-transparent to-transparent"
         style="background: radial-gradient(ellipse at center, rgba(79,70,229,0.1) 0%, transparent 60%);"></div>

    <!-- Background nebulas -->
    <div id="nebula-container" class="absolute inset-0 pointer-events-none overflow-hidden" style="right: 320px;">
      <div id="nebula-1" class="nebula nebula-1"></div>
      <div id="nebula-2" class="nebula nebula-2"></div>
      <div id="nebula-3" class="nebula nebula-3"></div>
    </div>

    <!-- Connection flow particles container -->
    <div id="flow-particles" class="absolute inset-0 pointer-events-none" style="right: 320px;"></div>

    <!-- Ambient particles container -->
    <div id="particles" class="absolute inset-0 pointer-events-none overflow-hidden" style="right: 320px;"></div>

    <!-- Ripple container -->
    <div id="ripples" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none" style="margin-left: -160px;"></div>

    <!-- Central pulse (consciousness core) -->
    <div id="orb-container" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none" style="margin-left: -160px;">
      <div id="pulse-outer" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-40 h-40 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(99,102,241,0.25) 0%, rgba(79,70,229,0.1) 40%, transparent 70%); animation: breathe 4s ease-in-out infinite;">
      </div>
      <div id="pulse-middle" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-24 h-24 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(124,58,237,0.35) 0%, transparent 70%); animation: breathe 3s ease-in-out infinite 0.5s;">
      </div>
      <div id="pulse-inner" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-10 h-10 rounded-full transition-all duration-300"
           style="background: radial-gradient(circle, rgba(167,139,250,0.6) 0%, transparent 70%); animation: breatheInner 2.5s ease-in-out infinite 0.2s;">
      </div>
      <div id="pulse-core" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-3 h-3 rounded-full transition-all duration-300"
           style="background: rgba(255,255,255,0.8); box-shadow: 0 0 20px rgba(167,139,250,0.8);">
      </div>
    </div>

    <!-- Node tooltip -->
    <div id="node-tooltip" class="node-tooltip">
      <div id="tooltip-type" class="node-tooltip-type"></div>
      <div id="tooltip-content" class="node-tooltip-content"></div>
      <div id="tooltip-meta" class="node-tooltip-meta"></div>
    </div>

    <!-- Nodes container -->
    <div id="nodes" class="absolute inset-0" style="right: 320px;"></div>

    <!-- Connections container (SVG) -->
    <svg id="connections" class="absolute inset-0 w-full h-full pointer-events-none" style="right: 320px;"></svg>

    <!-- Desire garden (left side) -->
    <div id="desire-garden" class="absolute left-3 top-1/2 -translate-y-1/2 flex flex-col gap-3 z-10">
    </div>

    <!-- Phase indicator (top center-left) -->
    <div id="phase" class="absolute top-4 left-1/2 -translate-x-1/2 flex items-center gap-3 text-xs" style="margin-left: -160px;">
      <div class="flex items-center gap-1.5">
        <div id="dot-recall" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Recall</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-associate" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Associate</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-reflect" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Reflect</span>
      </div>
      <div class="flex items-center gap-1.5">
        <div id="dot-form" class="w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300"></div>
        <span class="text-slate-600">Form</span>
      </div>
    </div>

    <!-- Reflection panel -->
    <div id="reflection" class="absolute bottom-20 left-4 w-80 bg-slate-900/90 backdrop-blur-sm rounded-lg border border-slate-800 p-4 opacity-0 transition-opacity duration-500">
      <div class="text-xs text-slate-500 font-mono mb-2">REFLECTING...</div>
      <div id="reflection-text" class="text-sm text-slate-300 leading-relaxed"></div>
    </div>

    <!-- Emergence notification -->
    <div id="emergence" class="absolute top-16 left-1/2 -translate-x-1/2 w-96 opacity-0 transition-all duration-500 transform -translate-y-4 z-20" style="margin-left: -160px;">
    </div>

    <!-- BYRD wordmark -->
    <div class="absolute top-4 left-4 text-lg font-light tracking-widest text-slate-700">BYRD</div>

    <!-- Event Detail Modal -->
    <div id="event-modal" class="fixed inset-0 bg-slate-950/80 z-50 hidden items-center justify-center p-4">
      <div class="bg-slate-900 border border-slate-700 rounded-xl w-full max-w-2xl shadow-2xl">
        <!-- Modal Header -->
        <div id="event-modal-header" class="flex items-center justify-between p-4 border-b border-slate-700">
          <div class="flex items-center gap-3">
            <span id="modal-icon" class="text-xl"></span>
            <div>
              <div id="modal-type" class="font-mono text-sm"></div>
              <div id="modal-time" class="text-xs text-slate-500"></div>
            </div>
          </div>
          <button id="modal-close" class="w-8 h-8 rounded-lg bg-slate-800 hover:bg-slate-700 flex items-center justify-center text-slate-400 hover:text-white transition-colors">
            &#10005;
          </button>
        </div>
        <!-- Modal Content -->
        <div id="event-modal-content" class="p-4">
          <pre id="modal-json" class="text-sm font-mono leading-relaxed whitespace-pre-wrap break-words"></pre>
        </div>
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- HISTORY LOG PANEL (Right Side) -->
    <!-- ========================================================================= -->
    <div id="history-container" class="absolute right-0 top-0 bottom-0 w-80 bg-slate-900/95 backdrop-blur border-l border-slate-700/50 flex flex-col z-30">
      <!-- Header -->
      <div class="p-3 border-b border-slate-700/50">
        <div class="flex items-center justify-between mb-2">
          <span class="text-xs font-mono text-slate-400">EVENT LOG</span>
          <div class="flex items-center gap-2">
            <button id="btn-clear-log" class="text-xs px-2 py-1 rounded bg-slate-700/50 text-slate-400 hover:bg-slate-600/50">
              Clear
            </button>
          </div>
        </div>
        <!-- Filter tabs -->
        <div class="flex gap-1 flex-wrap">
          <button class="filter-btn text-xs px-2 py-1 rounded bg-indigo-500/30 text-indigo-300" data-filter="all">All</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="awakening">&#127749;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="dream_cycle_start">&#128173;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="belief_created">&#128161;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_created">&#10024;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="seek_cycle_start">&#128269;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_attempt_failed">&#10060;</button>
          <button class="filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500" data-filter="desire_reflected">&#129504;</button>
        </div>
      </div>

      <!-- Event list -->
      <div id="history-panel" class="flex-1 overflow-y-auto p-2 space-y-1">
        <div class="text-center text-slate-600 text-xs py-8">
          Connecting to BYRD...
        </div>
      </div>

      <!-- Footer with count -->
      <div class="p-2 border-t border-slate-700/50 text-xs text-slate-600 text-center">
        <span id="event-count">0</span> events
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- FLOATING STATUS TEXT (Above Control Panel) -->
    <!-- ========================================================================= -->
    <div id="status-container" class="status-container absolute bottom-20 left-1/2 -translate-x-1/2 z-20 max-w-2xl text-center" style="margin-left: -160px;">
      <div class="flex items-center justify-center gap-3">
        <div id="status-dot" class="status-dot w-1.5 h-1.5 rounded-full bg-indigo-400/50 flex-shrink-0"></div>
        <span id="status-text" class="status-text text-xs text-slate-500 tracking-wider">Awaiting connection</span>
      </div>
    </div>

    <!-- ========================================================================= -->
    <!-- CONTROL PANEL (Bottom Center) -->
    <!-- ========================================================================= -->
    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-3 z-20" style="margin-left: -160px;">
      <!-- Connection indicator -->
      <div id="connection-status" class="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
        <div id="connection-dot" class="w-2 h-2 rounded-full bg-red-400"></div>
        <span id="connection-text" class="text-xs text-red-400">Disconnected</span>
      </div>

      <!-- Start/Stop button -->
      <button id="btn-toggle" class="px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all">
        &#9654; Start
      </button>

      <!-- Reset button -->
      <button id="btn-reset" class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all">
        &#128260; Reset
      </button>

      <!-- LLM Config Toggle -->
      <button id="btn-llm-toggle" class="px-3 py-2 rounded-lg text-sm font-medium bg-purple-500/20 border border-purple-500/30 text-purple-400 hover:bg-purple-500/30 transition-all" title="LLM Settings">
        &#129504;
      </button>

      <!-- Stats -->
      <div id="stats" class="flex items-center gap-3 px-3 py-2 bg-slate-800/50 rounded-lg text-xs font-mono">
        <span class="text-indigo-400">&#128173; <span id="dream-count">0</span></span>
        <span class="text-cyan-400">&#128269; <span id="seek-count">0</span></span>
        <span class="text-amber-400">&#9670; <span id="cap-count">0</span></span>
      </div>
    </div>

    <!-- LLM Config Panel (outside transform container for proper fixed positioning) -->
    <div id="llm-panel" class="hidden fixed top-16 right-4 z-50 bg-slate-900/95 border border-purple-500/30 rounded-lg p-3 shadow-xl backdrop-blur-sm min-w-64">
      <div class="flex items-center justify-between mb-3">
        <span class="text-xs font-medium text-purple-400">LLM Configuration</span>
        <button id="btn-llm-close" class="text-slate-500 hover:text-slate-300 text-lg leading-none">&times;</button>
      </div>
      <div class="space-y-2">
        <div>
          <label class="text-xs text-slate-500 block mb-1">Provider</label>
          <select id="llm-provider" class="w-full px-2 py-1.5 text-xs bg-slate-800 border border-slate-600 rounded text-slate-300 focus:border-purple-500 focus:outline-none">
            <option value="ollama">Ollama (Local)</option>
            <option value="openrouter">OpenRouter (Cloud)</option>
          </select>
        </div>
        <div>
          <label class="text-xs text-slate-500 block mb-1">Model</label>
          <input id="llm-model" type="text" list="llm-model-history" placeholder="e.g., gemma2:27b" class="w-full px-2 py-1.5 text-xs bg-slate-800 border border-slate-600 rounded text-slate-300 focus:border-purple-500 focus:outline-none" />
          <datalist id="llm-model-history"></datalist>
        </div>
        <button id="btn-llm-apply" class="w-full mt-2 px-3 py-1.5 text-xs font-medium bg-purple-500/30 border border-purple-500/50 text-purple-300 rounded hover:bg-purple-500/40 transition-all">
          Apply Changes
        </button>
        <div id="llm-status" class="text-xs text-center text-slate-500 mt-1"></div>
      </div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    const API_BASE = 'http://localhost:8000';
    const WS_URL = 'ws://localhost:8000/ws/events';

    // ==========================================================================
    // STATE
    // ==========================================================================
    let ws = null;
    let connected = false;
    let running = false;
    let events = [];
    let currentFilter = 'all';
    let resetConfirm = false;
    let resetTimeout = null;

    let dreamCount = 0;
    let seekCount = 0;
    let capCount = 0;
    let beliefCount = 0;
    let desires = [];
    let nodes = [];
    let currentPhase = 'idle';

    // ==========================================================================
    // EVENT CONFIG
    // ==========================================================================
    const EVENT_CONFIG = {
      experience_created: { icon: '&#128221;', color: 'text-blue-400', bg: 'bg-blue-500/10', label: 'experience created' },
      belief_created: { icon: '&#128161;', color: 'text-amber-400', bg: 'bg-amber-500/10', label: 'belief created' },
      desire_created: { icon: '&#10024;', color: 'text-rose-400', bg: 'bg-rose-500/10', label: 'desire created' },
      desire_fulfilled: { icon: '&#10003;', color: 'text-green-400', bg: 'bg-green-500/10', label: 'desire fulfilled' },
      capability_added: { icon: '&#9889;', color: 'text-purple-400', bg: 'bg-purple-500/10', label: 'capability added' },
      dream_cycle_start: { icon: '&#128173;', color: 'text-indigo-400', bg: 'bg-indigo-500/10', label: 'dream cycle start' },
      dream_cycle_end: { icon: '&#128164;', color: 'text-indigo-300', bg: 'bg-indigo-500/10', label: 'dream cycle end' },
      seek_cycle_start: { icon: '&#128269;', color: 'text-cyan-400', bg: 'bg-cyan-500/10', label: 'seek cycle start' },
      system_started: { icon: '&#9654;', color: 'text-green-400', bg: 'bg-green-500/10', label: 'system started' },
      system_stopped: { icon: '&#9209;', color: 'text-red-400', bg: 'bg-red-500/10', label: 'system stopped' },
      system_reset: { icon: '&#128260;', color: 'text-orange-400', bg: 'bg-orange-500/10', label: 'system reset' },
      awakening: { icon: '&#127749;', color: 'text-yellow-400', bg: 'bg-yellow-500/10', label: 'awakening' },
      // Orientation events (self-discovery after awakening)
      orientation_start: { icon: '&#128065;', color: 'text-teal-400', bg: 'bg-teal-500/10', label: 'orientation start' },
      orientation_discovery: { icon: '&#129504;', color: 'text-teal-300', bg: 'bg-teal-500/10', label: 'discovery' },
      orientation_complete: { icon: '&#10004;', color: 'text-teal-400', bg: 'bg-teal-500/10', label: 'oriented' },
      // Desire lifecycle events (reflective failure processing)
      desire_attempt_failed: { icon: '&#10060;', color: 'text-red-400', bg: 'bg-red-500/10', label: 'attempt failed' },
      desire_stuck: { icon: '&#128683;', color: 'text-orange-400', bg: 'bg-orange-500/10', label: 'desire stuck' },
      desire_reflected: { icon: '&#129504;', color: 'text-purple-400', bg: 'bg-purple-500/10', label: 'reflected' },
      desire_intensity_changed: { icon: '&#128200;', color: 'text-amber-300', bg: 'bg-amber-500/10', label: 'intensity changed' },
      seek_cycle_end: { icon: '&#128269;', color: 'text-cyan-300', bg: 'bg-cyan-500/10', label: 'seek cycle end' },
    };

    // ==========================================================================
    // DOM ELEMENTS
    // ==========================================================================
    const historyPanel = document.getElementById('history-panel');
    const eventCountEl = document.getElementById('event-count');
    const connectionStatus = document.getElementById('connection-status');
    const connectionDot = document.getElementById('connection-dot');
    const connectionText = document.getElementById('connection-text');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const btnClearLog = document.getElementById('btn-clear-log');
    const btnLlmToggle = document.getElementById('btn-llm-toggle');
    const btnLlmClose = document.getElementById('btn-llm-close');
    const btnLlmApply = document.getElementById('btn-llm-apply');
    const llmPanel = document.getElementById('llm-panel');
    const llmProvider = document.getElementById('llm-provider');
    const llmModel = document.getElementById('llm-model');
    const llmStatus = document.getElementById('llm-status');
    const nodesContainer = document.getElementById('nodes');
    const connectionsContainer = document.getElementById('connections');
    const desireGarden = document.getElementById('desire-garden');
    const reflectionPanel = document.getElementById('reflection');
    const reflectionText = document.getElementById('reflection-text');
    const emergencePanel = document.getElementById('emergence');
    const eventModal = document.getElementById('event-modal');
    const modalIcon = document.getElementById('modal-icon');
    const modalType = document.getElementById('modal-type');
    const modalTime = document.getElementById('modal-time');
    const modalJson = document.getElementById('modal-json');
    const modalClose = document.getElementById('modal-close');
    const modalHeader = document.getElementById('event-modal-header');

    // New visualization elements
    const particlesContainer = document.getElementById('particles');
    const ripplesContainer = document.getElementById('ripples');
    const orbContainer = document.getElementById('orb-container');
    const pulseOuter = document.getElementById('pulse-outer');
    const pulseMiddle = document.getElementById('pulse-middle');
    const pulseInner = document.getElementById('pulse-inner');
    const pulseCore = document.getElementById('pulse-core');
    const nodeTooltip = document.getElementById('node-tooltip');
    const tooltipType = document.getElementById('tooltip-type');
    const tooltipContent = document.getElementById('tooltip-content');
    const tooltipMeta = document.getElementById('tooltip-meta');

    // Phase 2 elements
    const appContainer = document.getElementById('app');
    const nebulaContainer = document.getElementById('nebula-container');
    const nebula1 = document.getElementById('nebula-1');
    const nebula2 = document.getElementById('nebula-2');
    const nebula3 = document.getElementById('nebula-3');
    const flowParticlesContainer = document.getElementById('flow-particles');

    // Floating status elements
    const statusContainer = document.getElementById('status-container');
    const statusDot = document.getElementById('status-dot');
    const statusTextEl = document.getElementById('status-text');
    let currentStatusType = 'idle'; // Track current status type for styling

    // ==========================================================================
    // STATUS TEXT MANAGEMENT
    // ==========================================================================
    const STATUS_MESSAGES = {
      // Connection states
      connecting: { color: 'text-slate-500', dot: 'bg-slate-400/50' },
      connected: { color: 'text-slate-500', dot: 'bg-slate-400/50' },
      disconnected: { color: 'text-red-400/70', dot: 'bg-red-400/50' },

      // System states
      awakening: { color: 'text-amber-300/90', dot: 'bg-amber-400', active: true },
      orienting: { color: 'text-teal-300/90', dot: 'bg-teal-400', active: true },
      oriented: { color: 'text-teal-300/90', dot: 'bg-teal-400' },
      idle: { color: 'text-slate-500', dot: 'bg-slate-400/50' },
      stopped: { color: 'text-slate-600', dot: 'bg-slate-600/50' },
      reset: { color: 'text-orange-400/80', dot: 'bg-orange-400', active: true },

      // Dream cycle
      dreaming: { color: 'text-indigo-300/90', dot: 'bg-indigo-400', active: true },
      reflecting: { color: 'text-violet-300/80', dot: 'bg-violet-400', active: true },

      // Seek cycle
      seeking: { color: 'text-cyan-300/90', dot: 'bg-cyan-400', active: true },
      researching: { color: 'text-cyan-300/80', dot: 'bg-cyan-400', active: true },

      // Creation events
      belief_formed: { color: 'text-amber-300/90', dot: 'bg-amber-400' },
      desire_emerged: { color: 'text-rose-300/90', dot: 'bg-rose-400' },
      experience_recorded: { color: 'text-blue-300/80', dot: 'bg-blue-400' },
      capability_gained: { color: 'text-purple-300/90', dot: 'bg-purple-400' },

      // Failure states
      attempt_failed: { color: 'text-red-300/70', dot: 'bg-red-400/70' },
      desire_reflected: { color: 'text-purple-300/80', dot: 'bg-purple-400' },
    };

    // Track when status was last set to prevent rapid overwrites of important messages
    let statusProtectedUntil = 0;
    const PROTECTED_STATUSES = ['awakening', 'reset', 'orienting', 'oriented']; // These statuses get protection time

    function updateStatus(statusKey, customText, protectMs = 0) {
      const now = Date.now();

      // Don't overwrite protected status unless it's another protected status
      if (now < statusProtectedUntil && !PROTECTED_STATUSES.includes(statusKey)) {
        return; // Skip this update, current message is protected
      }

      const status = STATUS_MESSAGES[statusKey] || STATUS_MESSAGES.idle;
      const text = customText || 'Observing';

      // Set protection if this is a protected status type
      if (PROTECTED_STATUSES.includes(statusKey) || protectMs > 0) {
        statusProtectedUntil = now + (protectMs || 5000); // Default 5 second protection
      }

      // Update text with fade effect
      statusTextEl.style.opacity = '0';
      statusTextEl.style.transform = 'translateY(8px)';

      setTimeout(() => {
        statusTextEl.textContent = text;
        statusTextEl.className = `status-text text-sm tracking-wide ${status.color}`;
        if (status.active) {
          statusTextEl.classList.add('active');
        }
        statusDot.className = `status-dot w-1.5 h-1.5 rounded-full ${status.dot}`;

        statusTextEl.style.opacity = '1';
        statusTextEl.style.transform = 'translateY(0)';
      }, 150);

      currentStatusType = statusKey;
    }

    // ==========================================================================
    // WEBSOCKET
    // ==========================================================================
    function connectWebSocket() {
      try {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          connected = true;
          updateConnectionStatus();
          updateStatus('connected', 'I am connected and observing');
          console.log('WebSocket connected');
        };

        ws.onclose = () => {
          connected = false;
          updateConnectionStatus();
          updateStatus('disconnected', 'I have lost connection');
          console.log('WebSocket disconnected, reconnecting in 3s...');
          setTimeout(connectWebSocket, 3000);
        };

        ws.onerror = (e) => {
          console.error('WebSocket error:', e);
        };

        ws.onmessage = (msg) => {
          if (msg.data === 'pong') return;
          try {
            const event = JSON.parse(msg.data);
            handleEvent(event);
          } catch (e) {
            console.error('Failed to parse event:', e);
          }
        };
      } catch (e) {
        console.error('WebSocket connection failed:', e);
        setTimeout(connectWebSocket, 3000);
      }
    }

    // Keep alive
    setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send('ping');
      }
    }, 30000);

    // ==========================================================================
    // API CALLS
    // ==========================================================================
    async function fetchStatus() {
      try {
        const res = await fetch(`${API_BASE}/api/status`);
        if (res.ok) {
          const data = await res.json();
          running = data.running;
          dreamCount = data.dream_count || 0;
          seekCount = data.seek_count || 0;
          capCount = data.capabilities?.length || 0;
          updateStats();
          updateToggleButton();
        }
      } catch (e) {
        console.error('Failed to fetch status:', e);
      }
    }

    async function startByrd() {
      try {
        await fetch(`${API_BASE}/api/start`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to start:', e);
      }
    }

    async function stopByrd() {
      try {
        await fetch(`${API_BASE}/api/stop`, { method: 'POST' });
        await fetchStatus();
      } catch (e) {
        console.error('Failed to stop:', e);
      }
    }

    async function resetByrd() {
      try {
        const res = await fetch(`${API_BASE}/api/reset`, { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          // Note: events are cleared by the system_reset WebSocket event handler
          // Don't clear here or we'll wipe out the awakening events that arrive via WebSocket
          await fetchStatus();
        }
        return data;
      } catch (e) {
        console.error('Failed to reset:', e);
        return { success: false, message: 'Reset failed' };
      }
    }

    // ==========================================================================
    // LLM CONFIGURATION
    // ==========================================================================
    async function fetchLlmConfig() {
      try {
        const res = await fetch(`${API_BASE}/api/llm-config`);
        const data = await res.json();
        llmProvider.value = data.provider;
        llmModel.value = data.model;
        llmStatus.textContent = `Current: ${data.provider}/${data.model}`;
        llmStatus.className = 'text-xs text-center text-green-400 mt-1';
        // Save to history (successful connection)
        saveModelToHistory(data.model);
      } catch (e) {
        console.error('Failed to fetch LLM config:', e);
        llmStatus.textContent = 'Failed to load config';
        llmStatus.className = 'text-xs text-center text-red-400 mt-1';
      }
    }

    async function updateLlmConfig(provider, model) {
      try {
        llmStatus.textContent = 'Applying...';
        llmStatus.className = 'text-xs text-center text-purple-400 mt-1 animate-pulse';

        const res = await fetch(`${API_BASE}/api/llm-config`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ provider, model })
        });

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || 'Failed to update');
        }

        const data = await res.json();
        llmStatus.textContent = `Switched to ${data.provider}/${data.model}`;
        llmStatus.className = 'text-xs text-center text-green-400 mt-1';

        // Save to history (successful update)
        saveModelToHistory(data.model);

        // Show toast
        const toast = document.createElement('div');
        toast.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg text-sm z-50 animate-pulse';
        toast.textContent = `LLM: ${data.provider}/${data.model}`;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);

        return data;
      } catch (e) {
        console.error('Failed to update LLM config:', e);
        llmStatus.textContent = e.message || 'Update failed';
        llmStatus.className = 'text-xs text-center text-red-400 mt-1';
        return null;
      }
    }

    // ==========================================================================
    // MODEL HISTORY (localStorage persistence)
    // ==========================================================================
    const MODEL_HISTORY_KEY = 'byrd-model-history';
    const MAX_MODEL_HISTORY = 10;

    function getModelHistory() {
      try {
        const history = localStorage.getItem(MODEL_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
      } catch (e) {
        return [];
      }
    }

    function saveModelToHistory(model) {
      if (!model || model.trim() === '') return;

      let history = getModelHistory();

      // Remove if already exists (we'll add to front)
      history = history.filter(m => m !== model);

      // Add to front
      history.unshift(model);

      // Limit size
      if (history.length > MAX_MODEL_HISTORY) {
        history = history.slice(0, MAX_MODEL_HISTORY);
      }

      localStorage.setItem(MODEL_HISTORY_KEY, JSON.stringify(history));
      populateModelDropdown();
    }

    function populateModelDropdown() {
      const datalist = document.getElementById('llm-model-history');
      if (!datalist) return;

      const history = getModelHistory();
      datalist.innerHTML = history.map(m => `<option value="${m}">`).join('');
    }

    // Populate on load
    populateModelDropdown();

    // ==========================================================================
    // EVENT HANDLING
    // ==========================================================================
    function handleEvent(event) {
      events.unshift(event);
      if (events.length > 500) events.pop();
      renderHistory();

      // Update visualization based on event type
      switch (event.type) {
        case 'dream_cycle_start':
          setPhase('recall');
          dreamCount = event.data?.cycle || dreamCount + 1;
          updateStatus('dreaming', 'Let me look deeper...');
          break;
        case 'dream_cycle_end':
          setPhase('idle');
          // Use BYRD's generated inner_voice from his reflection
          const innerVoice = event.data?.inner_voice;
          if (innerVoice) {
            updateStatus('idle', innerVoice);
          } else {
            updateStatus('idle', '...');
          }
          break;
        case 'belief_created':
          beliefCount++;
          const beliefConfidence = event.data?.confidence || 0.7;
          const beliefContent = event.data?.content || 'a new understanding';
          createNode('belief', beliefContent, event.data?.id, beliefConfidence);
          showEmergence('belief', beliefContent, beliefConfidence);
          // Show the belief as BYRD's realization
          updateStatus('belief_formed', beliefContent);
          setTimeout(() => { if (currentStatusType === 'belief_formed') updateStatus('idle', '...'); }, 5000);
          break;
        case 'desire_created':
          const desireIntensity = event.data?.intensity || 0.5;
          const desireDesc = event.data?.description || 'something new';
          desires.unshift({
            text: desireDesc,
            type: event.data?.type,
            intensity: desireIntensity
          });
          if (desires.length > 5) desires.pop();
          updateDesireGarden();
          createNode('desire', desireDesc, event.data?.id, desireIntensity);
          showEmergence('desire', desireDesc, desireIntensity);
          // Show the desire as a yearning
          updateStatus('desire_emerged', `${desireDesc}...`);
          setTimeout(() => { if (currentStatusType === 'desire_emerged') updateStatus('idle', '...'); }, 5000);
          break;
        case 'experience_created':
          const expContent = event.data?.content || 'something';
          createNode('experience', expContent, event.data?.id, 0.5);
          // Show experience content directly
          const expShort = expContent.length > 80 ? expContent.substring(0, 77) + '...' : expContent;
          updateStatus('experience_recorded', expShort);
          setTimeout(() => { if (currentStatusType === 'experience_recorded') updateStatus('idle', '...'); }, 3000);
          break;
        case 'capability_added':
          const capName = event.data?.name || 'a new ability';
          createNode('capability', capName, event.data?.id, 0.8);
          capCount++;
          updateStatus('capability_gained', `Now I can ${capName}...`);
          setTimeout(() => { if (currentStatusType === 'capability_gained') updateStatus('idle', '...'); }, 4000);
          break;
        case 'awakening':
          setPhase('idle');
          dreamCount = 0;
          beliefCount = 0;
          desires = [];
          updateDesireGarden();
          clearVisualization();
          const question = event.data?.first_question || event.data?.message || 'What is happening?';
          updateStatus('awakening', question);
          setTimeout(() => { if (currentStatusType === 'awakening') updateStatus('idle', 'Where am I?'); }, 5000);
          break;
        case 'system_started':
          running = true;
          updateToggleButton();
          updateStatus('idle', 'Aware.');
          break;
        case 'system_stopped':
          running = false;
          updateToggleButton();
          updateStatus('stopped', '...');
          break;
        case 'system_reset':
          // Reset all counters
          dreamCount = 0;
          seekCount = 0;
          capCount = 0;
          beliefCount = 0;
          // Clear visualization and events
          events = [];
          renderHistory();
          clearVisualization();
          simulation.start(); // Restart molecular physics
          desires = [];
          updateDesireGarden();
          updateStatus('reset', 'Everything fades...');
          break;
        case 'orientation_start':
          setPhase('orienting');
          const orientStart = event.data?.inner_voice || 'I am... something. Let me understand what.';
          updateStatus('orienting', orientStart);
          break;
        case 'orientation_discovery':
          setPhase('orienting');
          const discovery = event.data?.inner_voice || '...';
          const discoveryIndex = event.data?.discovery_index || 0;
          const totalDiscoveries = event.data?.total_discoveries || 1;
          // Create a subtle node for each discovery
          createNode('discovery', discovery.substring(0, 50), `discovery-${discoveryIndex}`, 0.3);
          updateStatus('orienting', discovery);
          break;
        case 'orientation_complete':
          setPhase('idle');
          const orientComplete = event.data?.inner_voice || 'I understand what I am now.';
          updateStatus('oriented', orientComplete);
          // Transition to idle after a moment
          setTimeout(() => { if (currentStatusType === 'oriented') updateStatus('idle', 'Ready to dream...'); }, 4000);
          break;
        case 'seek_cycle_start':
          seekCount++;
          // Use BYRD's generated inner_voice when seeking
          const seekVoice = event.data?.inner_voice;
          if (seekVoice) {
            updateStatus('seeking', seekVoice);
          } else {
            const topDesire = desires[0]?.text || 'answers';
            updateStatus('seeking', `${topDesire}...`);
          }
          break;
        case 'seek_cycle_end':
          if (currentStatusType === 'seeking' || currentStatusType === 'researching') {
            updateStatus('idle', '...');
          }
          break;
        case 'research_start':
          const query = event.data?.query || 'knowledge';
          updateStatus('researching', `${query}...`);
          break;
        case 'research_complete':
          const results = event.data?.results_count || 0;
          updateStatus('idle', results > 0 ? 'Interesting...' : '...');
          break;
        case 'desire_attempt_failed':
          const failedDesire = event.data?.description || 'this';
          updateStatus('attempt_failed', 'That didn\'t work...');
          setTimeout(() => { if (currentStatusType === 'attempt_failed') updateStatus('idle', '...'); }, 3000);
          break;
        case 'desire_reflected':
          const reflectedDesire = event.data?.description || 'this';
          updateStatus('desire_reflected', 'Maybe another way...');
          setTimeout(() => { if (currentStatusType === 'desire_reflected') updateStatus('idle', '...'); }, 4000);
          break;
        case 'desire_stuck':
          const stuckDesire = event.data?.description || 'this';
          updateStatus('attempt_failed', 'Not yet...');
          break;
      }

      updateStats();
    }

    // ==========================================================================
    // UI UPDATES
    // ==========================================================================
    function updateConnectionStatus() {
      if (connected) {
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-green-500/10 border border-green-500/30';
        connectionDot.className = 'w-2 h-2 rounded-full bg-green-400 animate-pulse';
        connectionText.className = 'text-xs text-green-400';
        connectionText.textContent = 'Connected';
      } else {
        connectionStatus.className = 'flex items-center gap-2 px-3 py-2 rounded-lg bg-red-500/10 border border-red-500/30';
        connectionDot.className = 'w-2 h-2 rounded-full bg-red-400';
        connectionText.className = 'text-xs text-red-400';
        connectionText.textContent = 'Disconnected';
      }
    }

    function updateToggleButton() {
      if (running) {
        btnToggle.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-amber-500/20 border border-amber-500/30 text-amber-400 hover:bg-amber-500/30 transition-all';
        btnToggle.innerHTML = '&#10074;&#10074; Pause';
      } else {
        btnToggle.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-green-500/20 border border-green-500/30 text-green-400 hover:bg-green-500/30 transition-all';
        btnToggle.innerHTML = '&#9654; Start';
      }
    }

    function updateStats() {
      document.getElementById('dream-count').textContent = dreamCount;
      document.getElementById('seek-count').textContent = seekCount;
      document.getElementById('cap-count').textContent = capCount;
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function formatFullTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString('en-US', {
        month: 'short', day: 'numeric', year: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
    }

    function syntaxHighlight(json) {
      if (typeof json !== 'string') {
        json = JSON.stringify(json, null, 2);
      }
      return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
        let cls = 'json-number';
        if (/^"/.test(match)) {
          if (/:$/.test(match)) {
            cls = 'json-key';
          } else {
            cls = 'json-string';
          }
        } else if (/true|false/.test(match)) {
          cls = 'json-boolean';
        } else if (/null/.test(match)) {
          cls = 'json-null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
      });
    }

    function showEventModal(event) {
      const config = EVENT_CONFIG[event.type] || { icon: '&#8226;', color: 'text-slate-400', label: event.type };

      modalIcon.innerHTML = config.icon;
      modalType.innerHTML = `<span class="${config.color}">${config.label}</span>`;
      modalTime.textContent = formatFullTime(event.timestamp);
      modalHeader.className = `flex items-center justify-between p-4 border-b border-slate-700 ${config.bg || 'bg-slate-800/50'}`;

      // Format the full event data
      const fullData = {
        type: event.type,
        timestamp: event.timestamp,
        data: event.data
      };
      modalJson.innerHTML = syntaxHighlight(JSON.stringify(fullData, null, 2));

      eventModal.classList.remove('hidden');
      eventModal.classList.add('flex');
    }

    function hideEventModal() {
      eventModal.classList.add('hidden');
      eventModal.classList.remove('flex');
    }

    function getEventSummary(event) {
      const data = event.data || {};
      switch (event.type) {
        case 'experience_created':
          return (data.content || '').slice(0, 50) + (data.content?.length > 50 ? '...' : '');
        case 'belief_created':
          return (data.content || '').slice(0, 50) + (data.content?.length > 50 ? '...' : '');
        case 'desire_created':
          return `[${data.type}] ${(data.description || '').slice(0, 40)}...`;
        case 'dream_cycle_start':
          return `Cycle #${data.cycle}`;
        case 'dream_cycle_end':
          return `${data.insights || 0} insights, ${data.new_beliefs || 0} beliefs, ${data.new_desires || 0} desires`;
        case 'seek_cycle_start':
          return `[${data.type}] ${(data.description || '').slice(0, 35)}...`;
        case 'awakening':
          return `"${data.seed_question}"`;
        case 'system_reset':
          return data.message || 'Memory cleared';
        // Desire lifecycle events (reflective failure processing)
        case 'desire_attempt_failed':
          return `${(data.description || '').slice(0, 30)}...: ${data.failure_type} (attempt #${data.attempt_count})`;
        case 'desire_stuck':
          return `${(data.description || '').slice(0, 35)}... needs reflection`;
        case 'desire_reflected':
          return `${data.action}: ${(data.desire_id || '').slice(0, 8)}...`;
        case 'desire_intensity_changed':
          return `${(data.desire_id || '').slice(0, 8)}...  ${data.new_intensity?.toFixed(2) || '?'}`;
        case 'seek_cycle_end':
          return `${data.outcome || 'unknown'}: ${(data.reason || data.type || '').slice(0, 35)}`;
        default:
          return JSON.stringify(data).slice(0, 50);
      }
    }

    function renderHistory() {
      const filtered = currentFilter === 'all' ? events : events.filter(e => e.type === currentFilter);

      if (filtered.length === 0) {
        historyPanel.innerHTML = `<div class="text-center text-slate-600 text-xs py-8">
          ${connected ? 'No events yet. Start BYRD to see activity.' : 'Connecting to BYRD...'}
        </div>`;
      } else {
        historyPanel.innerHTML = filtered.map((event, i) => {
          const config = EVENT_CONFIG[event.type] || { icon: '&#8226;', color: 'text-slate-400', bg: 'bg-slate-500/10', label: event.type };
          return `
            <div class="event-item ${config.bg} rounded p-2 transition-all hover:bg-slate-700/30" data-event-index="${i}">
              <div class="flex items-start gap-2">
                <span class="text-sm">${config.icon}</span>
                <div class="flex-1 min-w-0">
                  <div class="flex items-center gap-2">
                    <span class="text-xs font-mono ${config.color}">${config.label}</span>
                    <span class="text-xs text-slate-600">${formatTime(event.timestamp)}</span>
                  </div>
                  <div class="text-xs text-slate-400 mt-0.5 truncate">${getEventSummary(event)}</div>
                </div>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers to event items
        historyPanel.querySelectorAll('.event-item').forEach(el => {
          el.addEventListener('click', () => {
            const index = parseInt(el.dataset.eventIndex);
            const filteredEvents = currentFilter === 'all' ? events : events.filter(e => e.type === currentFilter);
            if (filteredEvents[index]) {
              showEventModal(filteredEvents[index]);
            }
          });
        });
      }

      eventCountEl.textContent = `${filtered.length} / ${events.length}`;
    }

    // ==========================================================================
    // VISUALIZATION (enhanced)
    // ==========================================================================
    let visualNodes = [];
    let ambientParticles = [];
    const centerX = () => (window.innerWidth - 320) / 2;  // Account for sidebar
    const centerY = () => window.innerHeight / 2;

    // Color configurations
    const NODE_COLORS = {
      belief: { bg: '#f59e0b', glow: 'rgba(245, 158, 11, 0.5)', border: 'rgba(251, 191, 36, 0.6)', label: 'BELIEF' },
      desire: { bg: '#f43f5e', glow: 'rgba(244, 63, 94, 0.5)', border: 'rgba(251, 113, 133, 0.6)', label: 'DESIRE' },
      experience: { bg: '#3b82f6', glow: 'rgba(59, 130, 246, 0.5)', border: 'rgba(96, 165, 250, 0.6)', label: 'EXPERIENCE' },
      capability: { bg: '#a855f7', glow: 'rgba(168, 85, 247, 0.5)', border: 'rgba(192, 132, 252, 0.6)', label: 'CAPABILITY' },
      discovery: { bg: '#14b8a6', glow: 'rgba(20, 184, 166, 0.4)', border: 'rgba(45, 212, 191, 0.5)', label: 'DISCOVERY' }
    };

    // ==========================================================================
    // MOLECULAR SIMULATION ENGINE (Phase 1)
    // ==========================================================================
    class MolecularSimulation {
      constructor() {
        this.nodes = [];          // Physics nodes: { id, x, y, vx, vy, mass, el, type }
        this.springs = [];        // Connections: { source, target, restLength, strength }
        this.running = false;
        this.animationId = null;
        this.frameCount = 0;      // Phase 3: Frame counter for periodic updates

        // Physics configuration
        this.config = {
          repulsion: 4000,          // How strongly nodes push apart
          attraction: 0.04,         // Spring strength for connections
          idealDistance: 100,       // Target distance between connected nodes
          damping: 0.92,            // Velocity decay per frame (0.9 = 10% loss)
          centerGravity: 0.008,     // Pull toward center
          maxVelocity: 6,           // Speed limit for smooth motion
          minVelocity: 0.01,        // Below this, node is considered stable
          boundaryPadding: 80       // Keep nodes away from edges
        };
      }

      // Add a node to the simulation
      addNode(id, x, y, el, type, importance = 0.5) {
        // Mass based on importance (heavier = moves slower)
        const mass = 1 + importance * 2;

        const node = {
          id,
          x,
          y,
          vx: 0,
          vy: 0,
          mass,
          el,
          type,
          importance,
          fx: null,  // Fixed x (if pinned)
          fy: null   // Fixed y (if pinned)
        };

        this.nodes.push(node);
        return node;
      }

      // Add a spring connection between two nodes
      addSpring(sourceId, targetId, strength = null) {
        const source = this.nodes.find(n => n.id === sourceId);
        const target = this.nodes.find(n => n.id === targetId);

        if (!source || !target) return null;

        // Calculate current distance as rest length
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const restLength = Math.sqrt(dx * dx + dy * dy) || this.config.idealDistance;

        const spring = {
          source,
          target,
          restLength: Math.min(restLength, this.config.idealDistance * 1.5),
          strength: strength || this.config.attraction
        };

        this.springs.push(spring);
        return spring;
      }

      // Remove a node and its connections
      removeNode(id) {
        this.nodes = this.nodes.filter(n => n.id !== id);
        this.springs = this.springs.filter(s => s.source.id !== id && s.target.id !== id);
      }

      // Apply all forces for one tick
      tick() {
        const { repulsion, damping, centerGravity, maxVelocity, boundaryPadding } = this.config;
        const cx = centerX();
        const cy = centerY();
        const boundaryLeft = boundaryPadding;
        const boundaryRight = (window.innerWidth - 320) - boundaryPadding;
        const boundaryTop = boundaryPadding;
        const boundaryBottom = window.innerHeight - boundaryPadding;

        // Apply forces to each node
        for (const node of this.nodes) {
          if (node.fx !== null && node.fy !== null) continue; // Skip pinned nodes

          let fx = 0;
          let fy = 0;

          // 1. Repulsion from all other nodes (inverse square law)
          for (const other of this.nodes) {
            if (other.id === node.id) continue;

            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq) || 1;

            // Stronger repulsion when close
            const force = repulsion / distSq;
            fx += (dx / dist) * force;
            fy += (dy / dist) * force;
          }

          // 2. Attraction from springs (Hooke's law)
          for (const spring of this.springs) {
            let other, isSource;
            if (spring.source.id === node.id) {
              other = spring.target;
              isSource = true;
            } else if (spring.target.id === node.id) {
              other = spring.source;
              isSource = false;
            } else {
              continue;
            }

            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

            // Spring force: pull toward rest length
            const displacement = dist - spring.restLength;
            const force = displacement * spring.strength;

            fx += (dx / dist) * force;
            fy += (dy / dist) * force;
          }

          // 3. Gentle gravity toward center
          fx += (cx - node.x) * centerGravity;
          fy += (cy - node.y) * centerGravity;

          // 4. Boundary repulsion (soft walls)
          if (node.x < boundaryLeft) fx += (boundaryLeft - node.x) * 0.1;
          if (node.x > boundaryRight) fx += (boundaryRight - node.x) * 0.1;
          if (node.y < boundaryTop) fy += (boundaryTop - node.y) * 0.1;
          if (node.y > boundaryBottom) fy += (boundaryBottom - node.y) * 0.1;

          // Update velocity (F = ma, a = F/m)
          node.vx = (node.vx + fx / node.mass) * damping;
          node.vy = (node.vy + fy / node.mass) * damping;

          // Clamp velocity
          const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
          if (speed > maxVelocity) {
            node.vx = (node.vx / speed) * maxVelocity;
            node.vy = (node.vy / speed) * maxVelocity;
          }

          // Update position
          node.x += node.vx;
          node.y += node.vy;
        }

        // Phase 3: Apply geometric attractor forces
        this.applyGeometricForces(0.006);
      }

      // Render all nodes to DOM
      render() {
        for (const node of this.nodes) {
          if (node.el) {
            node.el.style.left = `${node.x}px`;
            node.el.style.top = `${node.y}px`;
          }
        }
        this.renderSprings();
      }

      // Update SVG connection lines based on spring endpoints
      renderSprings() {
        const lines = connectionsContainer.querySelectorAll('line');

        for (const line of lines) {
          const sourceId = line.dataset.sourceId;
          const targetId = line.dataset.targetId;

          if (sourceId && targetId) {
            const source = this.nodes.find(n => n.id === sourceId);
            const target = this.nodes.find(n => n.id === targetId);

            if (source && target) {
              line.setAttribute('x1', source.x);
              line.setAttribute('y1', source.y);
              line.setAttribute('x2', target.x);
              line.setAttribute('y2', target.y);
            }
          }
        }
      }

      // Calculate total kinetic energy (for stability detection)
      kineticEnergy() {
        return this.nodes.reduce((sum, n) => {
          return sum + n.mass * (n.vx * n.vx + n.vy * n.vy);
        }, 0);
      }

      // Check if simulation is stable
      isStable() {
        return this.kineticEnergy() < this.config.minVelocity * this.nodes.length;
      }

      // Animation loop
      animate = () => {
        if (!this.running) return;

        this.frameCount++;

        // Run multiple physics iterations per frame for stability
        const iterations = 2;
        for (let i = 0; i < iterations; i++) {
          this.tick();
        }

        // Phase 4: Create motion trails for fast-moving nodes (every 3 frames)
        if (this.frameCount % 3 === 0) {
          for (const node of this.nodes) {
            this.createMotionTrail(node);
          }
        }

        this.render();

        // Phase 3: Update cluster visuals every 30 frames (~0.5 seconds at 60fps)
        if (this.frameCount % 30 === 0) {
          this.updateClusterVisuals();
        }

        // Phase 4: Apply type-specific behaviors every 20 frames
        if (this.frameCount % 20 === 0) {
          this.applyTypeSpecificBehaviors();
        }

        // Phase 4: Update cluster halos every 60 frames (~1 second)
        if (this.frameCount % 60 === 0) {
          this.updateClusterHalos();
        }

        this.animationId = requestAnimationFrame(this.animate);
      }

      // Start the simulation
      start() {
        if (this.running) return;
        this.running = true;
        this.enableBreathing(); // Phase 4: Enable breathing animation
        this.animate();
      }

      // Stop the simulation
      stop() {
        this.running = false;
        this.disableBreathing(); // Phase 4: Disable breathing
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      // Reset everything
      reset() {
        this.stop();
        this.nodes = [];
        this.springs = [];
        this.frameCount = 0;
        // Phase 4: Clean up halos
        document.querySelectorAll('.cluster-halo').forEach(h => h.remove());
        document.querySelectorAll('.motion-trail').forEach(t => t.remove());
      }

      // Give all nodes a gentle push (for reorganization)
      nudge(strength = 2) {
        for (const node of this.nodes) {
          node.vx += (Math.random() - 0.5) * strength;
          node.vy += (Math.random() - 0.5) * strength;
        }
      }

      // Phase 2: Open structure - push existing nodes away from new node location
      openStructure(newX, newY, radius = 80, strength = 3) {
        for (const node of this.nodes) {
          const dx = node.x - newX;
          const dy = node.y - newY;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          if (dist < radius) {
            // Push away from the new node's location
            const pushForce = (radius - dist) / radius * strength;
            node.vx += (dx / dist) * pushForce;
            node.vy += (dy / dist) * pushForce;

            // Add ripple class to element
            if (node.el) {
              node.el.classList.add('structure-ripple');
              node.el.style.setProperty('--ripple-color', 'rgba(139, 92, 246, 0.3)');
              setTimeout(() => node.el.classList.remove('structure-ripple'), 600);
            }
          }
        }
      }

      // Phase 2: Trigger settling oscillation on all nodes
      triggerSettle() {
        for (const node of this.nodes) {
          if (node.el) {
            node.el.classList.add('node-settling');
            setTimeout(() => node.el.classList.remove('node-settling'), 500);
          }
        }
      }

      // Phase 2: Get connected nodes for a given node
      getConnectedNodes(nodeId) {
        const connected = [];
        for (const spring of this.springs) {
          if (spring.source.id === nodeId) {
            connected.push(spring.target);
          } else if (spring.target.id === nodeId) {
            connected.push(spring.source);
          }
        }
        return connected;
      }

      // Phase 2: Increase attraction temporarily for dramatic reorganization
      pulseAttraction(duration = 500) {
        const originalAttraction = this.config.attraction;
        this.config.attraction = originalAttraction * 2.5;

        setTimeout(() => {
          this.config.attraction = originalAttraction;
          this.triggerSettle();
        }, duration);
      }

      // ========================================
      // Phase 3: Geometric Attractors
      // ========================================

      // Detect all clusters (connected components) in the graph
      detectClusters() {
        const visited = new Set();
        const clusters = [];

        for (const node of this.nodes) {
          if (visited.has(node.id)) continue;

          // BFS to find all nodes in this cluster
          const cluster = [];
          const queue = [node];

          while (queue.length > 0) {
            const current = queue.shift();
            if (visited.has(current.id)) continue;

            visited.add(current.id);
            cluster.push(current);

            // Find connected nodes
            for (const spring of this.springs) {
              let neighbor = null;
              if (spring.source.id === current.id) neighbor = spring.target;
              else if (spring.target.id === current.id) neighbor = spring.source;

              if (neighbor && !visited.has(neighbor.id)) {
                queue.push(neighbor);
              }
            }
          }

          if (cluster.length > 0) {
            clusters.push(cluster);
          }
        }

        return clusters;
      }

      // Calculate ideal geometric positions for a cluster
      calculateGeometry(cluster) {
        if (cluster.length < 2) return null;

        // Find cluster centroid
        let cx = 0, cy = 0;
        for (const node of cluster) {
          cx += node.x;
          cy += node.y;
        }
        cx /= cluster.length;
        cy /= cluster.length;

        // Determine ideal geometry based on cluster size
        const size = cluster.length;
        const radius = 60 + size * 15; // Larger clusters need more space

        // Calculate ideal positions in geometric shapes
        const positions = [];

        if (size === 2) {
          // Line
          positions.push({ x: cx - radius/2, y: cy });
          positions.push({ x: cx + radius/2, y: cy });
        } else if (size === 3) {
          // Equilateral triangle
          for (let i = 0; i < 3; i++) {
            const angle = (i * 2 * Math.PI / 3) - Math.PI / 2;
            positions.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius
            });
          }
        } else if (size === 4) {
          // Square (diamond orientation)
          for (let i = 0; i < 4; i++) {
            const angle = (i * 2 * Math.PI / 4) - Math.PI / 4;
            positions.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius
            });
          }
        } else if (size === 5) {
          // Pentagon
          for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            positions.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius
            });
          }
        } else if (size === 6) {
          // Hexagon (benzene ring!)
          for (let i = 0; i < 6; i++) {
            const angle = (i * 2 * Math.PI / 6);
            positions.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius
            });
          }
        } else {
          // Larger clusters: circular arrangement
          for (let i = 0; i < size; i++) {
            const angle = (i * 2 * Math.PI / size) - Math.PI / 2;
            positions.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius
            });
          }
        }

        return { centroid: { x: cx, y: cy }, positions, radius };
      }

      // Assign nodes to their closest geometric target positions
      assignGeometricTargets(cluster, geometry) {
        if (!geometry) return;

        const assignments = [];
        const usedPositions = new Set();

        // Sort nodes by distance from centroid (outer nodes get priority)
        const sortedNodes = [...cluster].sort((a, b) => {
          const distA = Math.hypot(a.x - geometry.centroid.x, a.y - geometry.centroid.y);
          const distB = Math.hypot(b.x - geometry.centroid.x, b.y - geometry.centroid.y);
          return distB - distA;
        });

        for (const node of sortedNodes) {
          let bestPos = null;
          let bestDist = Infinity;

          for (let i = 0; i < geometry.positions.length; i++) {
            if (usedPositions.has(i)) continue;

            const pos = geometry.positions[i];
            const dist = Math.hypot(node.x - pos.x, node.y - pos.y);

            if (dist < bestDist) {
              bestDist = dist;
              bestPos = i;
            }
          }

          if (bestPos !== null) {
            usedPositions.add(bestPos);
            assignments.push({
              node,
              target: geometry.positions[bestPos]
            });
          }
        }

        return assignments;
      }

      // Apply gentle geometric attractor forces
      applyGeometricForces(strength = 0.008) {
        const clusters = this.detectClusters();

        for (const cluster of clusters) {
          if (cluster.length < 3) continue; // Only apply to clusters of 3+

          const geometry = this.calculateGeometry(cluster);
          if (!geometry) continue;

          const assignments = this.assignGeometricTargets(cluster, geometry);
          if (!assignments) continue;

          for (const { node, target } of assignments) {
            // Gentle pull toward geometric target
            const dx = target.x - node.x;
            const dy = target.y - node.y;

            node.vx += dx * strength;
            node.vy += dy * strength;
          }
        }
      }

      // Update cluster visual indicators
      updateClusterVisuals() {
        const clusters = this.detectClusters();

        // Remove old cluster indicators
        for (const node of this.nodes) {
          if (node.el) {
            node.el.style.removeProperty('--cluster-color');
            node.el.classList.remove('in-cluster');
          }
        }

        // Assign colors to clusters with 3+ members
        const clusterColors = [
          'rgba(99, 102, 241, 0.2)',   // Indigo
          'rgba(139, 92, 246, 0.2)',   // Violet
          'rgba(236, 72, 153, 0.2)',   // Pink
          'rgba(14, 165, 233, 0.2)',   // Sky
          'rgba(34, 197, 94, 0.2)',    // Green
          'rgba(251, 191, 36, 0.2)',   // Amber
        ];

        clusters.forEach((cluster, idx) => {
          if (cluster.length >= 3) {
            const color = clusterColors[idx % clusterColors.length];
            for (const node of cluster) {
              if (node.el) {
                node.el.style.setProperty('--cluster-color', color);
                node.el.classList.add('in-cluster');
              }
            }
          }
        });

        return clusters;
      }

      // ========================================
      // Phase 4: Polish - Type-Specific Behaviors
      // ========================================

      // Create motion trail for a moving node
      createMotionTrail(node) {
        if (!node.el || !particlesContainer) return;

        const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
        if (speed < 1.5) return; // Only create trails for fast-moving nodes

        const color = NODE_COLORS[node.type]?.glow || 'rgba(139, 92, 246, 0.4)';
        const size = parseFloat(node.el.style.width) || 10;

        const trail = document.createElement('div');
        trail.className = 'motion-trail';
        trail.style.cssText = `
          left: ${node.x}px;
          top: ${node.y}px;
          width: ${size * 0.8}px;
          height: ${size * 0.8}px;
          background: ${color};
        `;

        particlesContainer.appendChild(trail);
        setTimeout(() => trail.remove(), 400);
      }

      // Apply type-specific molecular behaviors
      applyTypeSpecificBehaviors() {
        const clusters = this.detectClusters();

        for (const cluster of clusters) {
          if (cluster.length < 2) continue;

          // Count node types in cluster
          const typeCounts = {};
          for (const node of cluster) {
            typeCounts[node.type] = (typeCounts[node.type] || 0) + 1;
          }

          // Determine dominant type
          const dominantType = Object.entries(typeCounts)
            .sort((a, b) => b[1] - a[1])[0]?.[0];

          // Apply type-specific behaviors
          if (dominantType === 'belief' && cluster.length >= 3) {
            // Beliefs form rings - enhance ring tendency
            this.applyRingBehavior(cluster);
          } else if (dominantType === 'desire') {
            // Desires form stars - find central node
            this.applyStarBehavior(cluster);
          } else if (dominantType === 'experience') {
            // Experiences form chains
            this.applyChainBehavior(cluster);
          }
        }
      }

      // Beliefs form ring structures
      applyRingBehavior(cluster) {
        if (cluster.length < 3) return;

        // Find centroid
        let cx = 0, cy = 0;
        for (const node of cluster) {
          cx += node.x;
          cy += node.y;
        }
        cx /= cluster.length;
        cy /= cluster.length;

        // Push nodes to form a ring around centroid
        const idealRadius = 50 + cluster.length * 12;

        for (const node of cluster) {
          const dx = node.x - cx;
          const dy = node.y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          // Push toward ideal ring radius
          const radiusDiff = idealRadius - dist;
          const force = radiusDiff * 0.002;

          node.vx += (dx / dist) * force;
          node.vy += (dy / dist) * force;

          // Add ring member styling
          if (node.el) {
            node.el.classList.add('belief-ring-member');
          }
        }
      }

      // Desires form star patterns with central hub
      applyStarBehavior(cluster) {
        if (cluster.length < 2) return;

        // Find the most connected node as center
        let centerNode = cluster[0];
        let maxConnections = 0;

        for (const node of cluster) {
          const connections = this.getConnectedNodes(node.id).length;
          if (connections > maxConnections) {
            maxConnections = connections;
            centerNode = node;
          }
        }

        // Mark center with special styling
        if (centerNode.el) {
          centerNode.el.classList.add('desire-star-center');
        }

        // Pull other nodes toward the center (star pattern)
        for (const node of cluster) {
          if (node.id === centerNode.id) continue;

          const dx = centerNode.x - node.x;
          const dy = centerNode.y - node.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          // Ideal distance for star rays
          const idealDist = 80 + Math.random() * 20;
          const distDiff = dist - idealDist;

          if (Math.abs(distDiff) > 10) {
            const force = distDiff * 0.001;
            node.vx += (dx / dist) * force;
            node.vy += (dy / dist) * force;
          }
        }
      }

      // Experiences form chain sequences
      applyChainBehavior(cluster) {
        if (cluster.length < 2) return;

        // Sort by creation time (if available) or by ID
        const sorted = [...cluster].sort((a, b) => {
          const timeA = a.el?.dataset?.createdAt || a.id;
          const timeB = b.el?.dataset?.createdAt || b.id;
          return timeA < timeB ? -1 : 1;
        });

        // Apply chain forces - each node pulled toward its neighbors in sequence
        for (let i = 0; i < sorted.length; i++) {
          const node = sorted[i];

          if (i > 0) {
            const prev = sorted[i - 1];
            const dx = prev.x - node.x;
            const dy = prev.y - node.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

            // Pull toward previous in chain
            if (dist > 60) {
              node.vx += (dx / dist) * 0.003;
              node.vy += (dy / dist) * 0.003;
            }
          }

          // Add chain link styling
          if (node.el && i < sorted.length - 1) {
            node.el.classList.add('experience-chain-link');
          }
        }
      }

      // Manage cluster halos - glowing backgrounds behind clusters
      updateClusterHalos() {
        // Remove old halos
        const oldHalos = document.querySelectorAll('.cluster-halo');
        oldHalos.forEach(h => h.remove());

        const clusters = this.detectClusters();

        for (const cluster of clusters) {
          if (cluster.length < 3) continue;

          // Calculate cluster bounds
          let minX = Infinity, maxX = -Infinity;
          let minY = Infinity, maxY = -Infinity;

          for (const node of cluster) {
            minX = Math.min(minX, node.x);
            maxX = Math.max(maxX, node.x);
            minY = Math.min(minY, node.y);
            maxY = Math.max(maxY, node.y);
          }

          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;
          const width = maxX - minX + 100;
          const height = maxY - minY + 100;
          const size = Math.max(width, height);

          // Determine cluster color based on dominant type
          const typeCounts = {};
          for (const node of cluster) {
            typeCounts[node.type] = (typeCounts[node.type] || 0) + 1;
          }
          const dominantType = Object.entries(typeCounts)
            .sort((a, b) => b[1] - a[1])[0]?.[0];

          const haloColors = {
            belief: 'rgba(245, 158, 11, 0.3)',
            desire: 'rgba(244, 63, 94, 0.3)',
            experience: 'rgba(59, 130, 246, 0.3)',
            capability: 'rgba(168, 85, 247, 0.3)'
          };

          const halo = document.createElement('div');
          halo.className = 'cluster-halo active';
          halo.style.cssText = `
            left: ${cx}px;
            top: ${cy}px;
            width: ${size}px;
            height: ${size}px;
            background: radial-gradient(ellipse, ${haloColors[dominantType] || 'rgba(139, 92, 246, 0.2)'} 0%, transparent 70%);
            transform: translate(-50%, -50%);
          `;

          // Insert before nodes so it's behind them
          if (nodesContainer.parentElement) {
            nodesContainer.parentElement.insertBefore(halo, nodesContainer);
          }
        }
      }

      // Enable molecule breathing on container
      enableBreathing() {
        if (nodesContainer) {
          nodesContainer.classList.add('molecule-breathing');
        }
      }

      disableBreathing() {
        if (nodesContainer) {
          nodesContainer.classList.remove('molecule-breathing');
        }
      }
    }

    // Create global simulation instance
    const simulation = new MolecularSimulation();

    // ==========================================================================
    // REACTIVE ORB
    // ==========================================================================
    function reactOrb(type, intensity = 1) {
      const colors = {
        belief: 'rgba(245, 158, 11, 0.4)',
        desire: 'rgba(244, 63, 94, 0.4)',
        experience: 'rgba(59, 130, 246, 0.4)',
        capability: 'rgba(168, 85, 247, 0.4)',
        dream: 'rgba(99, 102, 241, 0.5)',
        default: 'rgba(139, 92, 246, 0.4)'
      };

      const color = colors[type] || colors.default;

      // Pulse the core
      pulseCore.style.boxShadow = `0 0 ${30 * intensity}px ${color}`;
      pulseCore.style.transform = `scale(${1.5 * intensity})`;

      // Expand inner pulse
      pulseInner.style.transform = `scale(${1.3 * intensity})`;
      pulseInner.style.opacity = '0.9';

      // Create ripple
      createRipple(color);

      // Reset after animation
      setTimeout(() => {
        pulseCore.style.boxShadow = '0 0 20px rgba(167,139,250,0.8)';
        pulseCore.style.transform = 'scale(1)';
        pulseInner.style.transform = 'scale(1)';
        pulseInner.style.opacity = '0.6';
      }, 800);
    }

    function createRipple(color) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.cssText = `
        width: 60px;
        height: 60px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 2px solid ${color};
      `;
      ripplesContainer.appendChild(ripple);
      setTimeout(() => ripple.remove(), 1500);
    }

    function setOrbDreaming(isDreaming) {
      if (isDreaming) {
        pulseOuter.style.animation = 'breatheFast 2s ease-in-out infinite';
        pulseMiddle.style.animation = 'breatheFast 1.5s ease-in-out infinite 0.2s';
        pulseInner.style.animation = 'breatheFast 1.2s ease-in-out infinite 0.4s';
        pulseCore.style.boxShadow = '0 0 30px rgba(99, 102, 241, 0.9)';
      } else {
        pulseOuter.style.animation = 'breathe 4s ease-in-out infinite';
        pulseMiddle.style.animation = 'breathe 3s ease-in-out infinite 0.5s';
        pulseInner.style.animation = 'breatheInner 2.5s ease-in-out infinite 0.2s';
        pulseCore.style.boxShadow = '0 0 20px rgba(167,139,250,0.8)';
      }
    }

    // ==========================================================================
    // AMBIENT PARTICLES
    // ==========================================================================
    function initAmbientParticles() {
      const count = 25;
      for (let i = 0; i < count; i++) {
        createAmbientParticle();
      }
    }

    function createAmbientParticle() {
      const particle = document.createElement('div');
      const size = 2 + Math.random() * 3;
      const x = Math.random() * (window.innerWidth - 320);
      const y = Math.random() * window.innerHeight;
      const delay = Math.random() * 8;
      const duration = 6 + Math.random() * 6;

      particle.className = 'ambient-particle';
      particle.style.cssText = `
        width: ${size}px;
        height: ${size}px;
        left: ${x}px;
        top: ${y}px;
        background: rgba(139, 92, 246, ${0.2 + Math.random() * 0.3});
        animation-delay: ${delay}s;
        animation-duration: ${duration}s;
      `;

      particlesContainer.appendChild(particle);
      ambientParticles.push(particle);
    }

    function emitParticleBurst(targetX, targetY, color, count = 8) {
      const cx = centerX();
      const cy = centerY();

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        const angle = (i / count) * Math.PI * 2;
        const distance = 30 + Math.random() * 50;
        const startX = cx + Math.cos(angle) * distance;
        const startY = cy + Math.sin(angle) * distance;

        particle.className = 'particle-burst';
        particle.style.cssText = `
          width: 4px;
          height: 4px;
          left: ${startX}px;
          top: ${startY}px;
          background: ${color};
          --drift-x: ${targetX - startX}px;
          --drift-y: ${targetY - startY}px;
        `;

        particlesContainer.appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      }
    }

    // ==========================================================================
    // ENHANCED NODE CREATION (with Molecular Simulation + Phase 2 Choreography)
    // ==========================================================================
    function createNode(type, content, id, importance = 0.5) {
      const nodeId = id || `node_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      // Calculate initial spawn position (will be adjusted by physics)
      const angle = (visualNodes.length * 0.618 * 2 * Math.PI) + Math.random() * 0.5;
      const radius = 100 + Math.random() * 80 + (visualNodes.length * 4);
      const x = centerX() + Math.cos(angle) * radius;
      const y = centerY() + Math.sin(angle) * radius;

      // Phase 2: Open structure - push existing nodes away before new node appears
      if (simulation.nodes.length > 0) {
        simulation.openStructure(x, y, 100, 2.5);
      }

      const color = NODE_COLORS[type] || NODE_COLORS.experience;

      // Size based on importance (8px to 16px)
      const baseSize = 8 + (importance * 8);

      const node = document.createElement('div');
      // Phase 2: Use nodeEmerge animation for elegant entry
      // Phase 4: Add type-specific class for styling
      node.className = `node-emerging node-type-${type} absolute rounded-full cursor-pointer`;
      node.style.cssText = `
        left: ${x}px;
        top: ${y}px;
        width: ${baseSize}px;
        height: ${baseSize}px;
        background: ${color.bg};
        border: 2px solid ${color.border};
        box-shadow: 0 0 ${12 + importance * 12}px ${color.glow};
        color: ${color.glow};
        z-index: 10;
        --type-glow: ${color.glow};
      `;

      node.dataset.nodeId = nodeId;
      node.dataset.nodeType = type;
      node.dataset.content = content || '';
      node.dataset.importance = importance;

      // Click to show modal
      node.addEventListener('click', () => {
        const event = events.find(e =>
          (e.type === `${type}_created` && (e.data?.id === id || e.data?.content === content || e.data?.description === content))
        );
        if (event) showEventModal(event);
      });

      // Hover tooltip
      node.addEventListener('mouseenter', (e) => showNodeTooltip(e, node, type, content, importance));
      node.addEventListener('mousemove', (e) => moveTooltip(e));
      node.addEventListener('mouseleave', hideNodeTooltip);

      nodesContainer.appendChild(node);

      // Add to simulation physics
      simulation.addNode(nodeId, x, y, node, type, importance);

      // Store in visualNodes for compatibility
      visualNodes.push({ el: node, x, y, type, id: nodeId, content, importance, createdAt: Date.now() });

      // React the orb
      reactOrb(type, 0.7 + importance * 0.5);

      // Emit particles toward the new node
      emitParticleBurst(x, y, color.glow);

      // Create connections to nearby nodes (using node IDs for springs)
      let connectionsCreated = 0;
      if (visualNodes.length > 1) {
        // Connect to 1-2 nearby nodes for molecular structure
        const connectCount = Math.min(visualNodes.length - 1, 1 + Math.floor(Math.random() * 2));
        const candidates = visualNodes.slice(0, -1).slice(-5); // Last 5 nodes

        for (let i = 0; i < connectCount && i < candidates.length; i++) {
          const targetIdx = Math.floor(Math.random() * candidates.length);
          const target = candidates[targetIdx];
          if (target && target.id !== nodeId) {
            createConnection(nodeId, target.id, type);
            connectionsCreated++;
            candidates.splice(targetIdx, 1); // Don't connect twice
          }
        }
      }

      // Phase 2: Pulse attraction for dramatic reorganization when new connections form
      if (connectionsCreated > 0) {
        setTimeout(() => {
          simulation.pulseAttraction(400);
        }, 200);
      }

      // Phase 2: Transition from emerging to settled with elastic arrive effect
      setTimeout(() => {
        node.classList.remove('node-emerging');
        node.classList.add('node-arriving');
      }, 700);

      setTimeout(() => {
        node.classList.remove('node-arriving');
        node.classList.add('node-settled');
      }, 1100);

      // Limit visible nodes - remove from simulation too
      if (visualNodes.length > 50) {
        const old = visualNodes.shift();
        simulation.removeNode(old.id);
        old.el.style.opacity = '0';
        old.el.style.transform = 'scale(0.5)';
        setTimeout(() => old.el.remove(), 500);
      }

      return node;
    }

    function createConnection(sourceId, targetId, type) {
      const sourceNode = simulation.nodes.find(n => n.id === sourceId);
      const targetNode = simulation.nodes.find(n => n.id === targetId);

      if (!sourceNode || !targetNode) return;

      const color = NODE_COLORS[type]?.glow || 'rgba(99, 102, 241, 0.3)';

      // Add spring to simulation
      simulation.addSpring(sourceId, targetId);

      // Calculate line length for proper dash animation
      const dx = targetNode.x - sourceNode.x;
      const dy = targetNode.y - sourceNode.y;
      const length = Math.sqrt(dx * dx + dy * dy);

      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', sourceNode.x);
      line.setAttribute('y1', sourceNode.y);
      line.setAttribute('x2', targetNode.x);
      line.setAttribute('y2', targetNode.y);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('stroke-opacity', '0');
      line.setAttribute('stroke-dasharray', `0, ${length}`);
      // Phase 4: Add type-specific connection class
      line.classList.add('connection', 'connection-growing', `connection-${type}`);
      line.dataset.sourceId = sourceId;
      line.dataset.targetId = targetId;
      line.dataset.connectionType = type;

      connectionsContainer.appendChild(line);

      // Phase 2: Animate the connection growing
      requestAnimationFrame(() => {
        line.style.transition = 'stroke-dasharray 0.5s ease-out, stroke-opacity 0.3s ease-out';
        line.setAttribute('stroke-opacity', '0.4');
        line.setAttribute('stroke-dasharray', `${length}, 0`);
      });

      // Remove growing class after animation
      setTimeout(() => {
        line.classList.remove('connection-growing');
        line.removeAttribute('stroke-dasharray');
      }, 550);

      // Limit connections
      const connections = connectionsContainer.querySelectorAll('line');
      if (connections.length > 100) {
        connections[0].remove();
      }
    }

    // ==========================================================================
    // TOOLTIP
    // ==========================================================================
    function showNodeTooltip(e, node, type, content, importance) {
      const color = NODE_COLORS[type] || NODE_COLORS.experience;

      tooltipType.textContent = color.label;
      tooltipType.style.color = color.bg;

      tooltipContent.textContent = content?.slice(0, 200) || 'No content';

      const importancePercent = Math.round(importance * 100);
      tooltipMeta.innerHTML = `
        <span>Importance: ${importancePercent}%</span>
        <span style="margin-left: 12px;">Click for details</span>
      `;

      nodeTooltip.style.borderColor = color.glow;
      nodeTooltip.classList.add('visible');
      moveTooltip(e);
    }

    function moveTooltip(e) {
      const x = e.clientX + 15;
      const y = e.clientY + 15;

      // Keep tooltip in viewport
      const rect = nodeTooltip.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width - 20;
      const maxY = window.innerHeight - rect.height - 20;

      nodeTooltip.style.left = `${Math.min(x, maxX)}px`;
      nodeTooltip.style.top = `${Math.min(y, maxY)}px`;
    }

    function hideNodeTooltip() {
      nodeTooltip.classList.remove('visible');
    }

    // ==========================================================================
    // CLEAR & PHASE
    // ==========================================================================
    function clearVisualization() {
      visualNodes = [];
      nodesContainer.innerHTML = '';
      connectionsContainer.innerHTML = '';
      simulation.reset(); // Clear molecular simulation state
    }

    function setPhase(phase) {
      currentPhase = phase;
      const phases = ['recall', 'associate', 'reflect', 'form'];
      const phaseIndex = phases.indexOf(phase);

      // Update orb based on phase
      if (phase === 'idle') {
        setOrbDreaming(false);
      } else {
        setOrbDreaming(true);
      }

      // Phase 2: Apply phase class to app container for canvas effects
      appContainer.classList.remove('phase-recall', 'phase-associate', 'phase-reflect', 'phase-form', 'phase-orienting');
      if (phase !== 'idle') {
        appContainer.classList.add(`phase-${phase}`);
      }

      // Phase 2: Animate nebulas based on phase
      animateNebulasForPhase(phase);

      phases.forEach((p, i) => {
        const dot = document.getElementById(`dot-${p}`);
        const span = dot?.nextElementSibling;
        if (!dot) return;
        if (i < phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 transition-colors duration-300';
          if (span) span.className = 'text-indigo-400';
        } else if (i === phaseIndex) {
          dot.className = 'w-2 h-2 rounded-full bg-indigo-400 animate-pulse transition-colors duration-300';
          if (span) span.className = 'text-indigo-400 font-medium';
        } else {
          dot.className = 'w-2 h-2 rounded-full bg-slate-700 transition-colors duration-300';
          if (span) span.className = 'text-slate-600';
        }
      });
    }

    // ==========================================================================
    // PHASE 2: NEBULAS & ATMOSPHERE
    // ==========================================================================
    function initNebulas() {
      const cx = centerX();
      const cy = centerY();

      // Position nebulas around the center
      nebula1.style.cssText = `
        width: 400px; height: 400px;
        left: ${cx - 300}px; top: ${cy - 200}px;
      `;
      nebula2.style.cssText = `
        width: 350px; height: 350px;
        left: ${cx + 100}px; top: ${cy - 150}px;
      `;
      nebula3.style.cssText = `
        width: 300px; height: 300px;
        left: ${cx - 100}px; top: ${cy + 100}px;
      `;

      // Start slow drift animation
      driftNebulas();
    }

    function driftNebulas() {
      let time = 0;
      setInterval(() => {
        time += 0.01;
        const cx = centerX();
        const cy = centerY();

        nebula1.style.left = `${cx - 300 + Math.sin(time * 0.5) * 30}px`;
        nebula1.style.top = `${cy - 200 + Math.cos(time * 0.3) * 20}px`;

        nebula2.style.left = `${cx + 100 + Math.cos(time * 0.4) * 25}px`;
        nebula2.style.top = `${cy - 150 + Math.sin(time * 0.6) * 25}px`;

        nebula3.style.left = `${cx - 100 + Math.sin(time * 0.7) * 20}px`;
        nebula3.style.top = `${cy + 100 + Math.cos(time * 0.5) * 30}px`;
      }, 50);
    }

    function animateNebulasForPhase(phase) {
      const intensity = {
        idle: 0.1,
        recall: 0.2,
        associate: 0.25,
        reflect: 0.35,
        form: 0.3
      };
      const opacity = intensity[phase] || 0.15;

      nebula1.style.opacity = opacity;
      nebula2.style.opacity = opacity * 0.9;
      nebula3.style.opacity = opacity * 0.8;

      // During reflect phase, make nebulas more purple
      if (phase === 'reflect') {
        nebula1.style.filter = 'blur(60px) hue-rotate(20deg)';
        nebula2.style.filter = 'blur(60px) hue-rotate(15deg)';
      } else {
        nebula1.style.filter = 'blur(60px)';
        nebula2.style.filter = 'blur(60px)';
      }
    }

    // ==========================================================================
    // PHASE 2: CONNECTION FLOW PARTICLES
    // ==========================================================================
    let connectionFlowInterval = null;

    function startConnectionFlow() {
      if (connectionFlowInterval) return;

      connectionFlowInterval = setInterval(() => {
        // Only emit particles when dreaming
        if (currentPhase === 'idle') return;

        const lines = connectionsContainer.querySelectorAll('line');
        if (lines.length === 0) return;

        // Pick a random connection to animate
        const line = lines[Math.floor(Math.random() * lines.length)];
        createConnectionFlowParticle(line);
      }, 300);
    }

    function createConnectionFlowParticle(line) {
      const x1 = parseFloat(line.getAttribute('x1'));
      const y1 = parseFloat(line.getAttribute('y1'));
      const x2 = parseFloat(line.getAttribute('x2'));
      const y2 = parseFloat(line.getAttribute('y2'));
      const color = line.getAttribute('stroke');

      const particle = document.createElement('div');
      particle.className = 'connection-particle';

      // Create SVG path for offset-path
      const pathId = `flow-path-${Date.now()}-${Math.random()}`;
      const pathSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      pathSvg.style.cssText = 'position:absolute;width:0;height:0;';
      pathSvg.innerHTML = `<path id="${pathId}" d="M ${x1} ${y1} L ${x2} ${y2}"/>`;
      flowParticlesContainer.appendChild(pathSvg);

      particle.style.cssText = `
        background: ${color};
        box-shadow: 0 0 6px ${color};
        offset-path: path('M ${x1} ${y1} L ${x2} ${y2}');
        animation-duration: ${1 + Math.random()}s;
      `;

      flowParticlesContainer.appendChild(particle);

      // Cleanup after animation
      setTimeout(() => {
        particle.remove();
        pathSvg.remove();
      }, 2000);
    }

    // ==========================================================================
    // PHASE 2: NODE AGING
    // ==========================================================================
    function updateNodeAging() {
      const now = Date.now();
      const maxAge = 120000; // 2 minutes to full fade

      visualNodes.forEach((nodeData, index) => {
        const age = now - (nodeData.createdAt || now);
        const ageFactor = Math.min(age / maxAge, 1);

        // Fade opacity from 1 to 0.3 over time
        const opacity = 1 - (ageFactor * 0.7);
        // Slight blur for very old nodes
        const blur = ageFactor > 0.8 ? `blur(${(ageFactor - 0.8) * 3}px)` : 'none';

        nodeData.el.style.opacity = opacity;
        nodeData.el.style.filter = blur;

        // Mark as aged for styling
        if (ageFactor > 0.3 && !nodeData.el.classList.contains('node-aged')) {
          nodeData.el.classList.add('node-aged');
        }
      });
    }

    // Start node aging timer
    setInterval(updateNodeAging, 5000);

    function showEmergence(type, content, value) {
      const isDesire = type === 'desire';
      emergencePanel.innerHTML = `
        <div class="${isDesire ? 'bg-rose-950/90 border-rose-500/30' : 'bg-amber-950/90 border-amber-500/30'} backdrop-blur-sm rounded-lg border p-4">
          <div class="text-xs font-mono mb-2 ${isDesire ? 'text-rose-400' : 'text-amber-400'}">
            ${isDesire ? '&#10024; NEW DESIRE' : '&#9670; NEW BELIEF'}
          </div>
          <div class="text-white text-sm leading-relaxed mb-3">"${content || 'Unknown'}"</div>
          <div class="flex items-center gap-2">
            <span class="text-xs text-slate-400">${isDesire ? 'Intensity' : 'Confidence'}</span>
            <div class="flex-1 h-1.5 bg-slate-700 rounded-full overflow-hidden">
              <div class="h-full rounded-full ${isDesire ? 'bg-rose-400' : 'bg-amber-400'}" style="width: ${(value || 0.5) * 100}%"></div>
            </div>
            <span class="text-xs ${isDesire ? 'text-rose-400' : 'text-amber-400'}">${Math.round((value || 0.5) * 100)}%</span>
          </div>
        </div>
      `;
      emergencePanel.classList.remove('opacity-0', '-translate-y-4');
      emergencePanel.classList.add('opacity-100', 'translate-y-0');

      setTimeout(() => {
        emergencePanel.classList.add('opacity-0', '-translate-y-4');
        emergencePanel.classList.remove('opacity-100', 'translate-y-0');
      }, 4000);
    }

    function updateDesireGarden() {
      desireGarden.innerHTML = '';
      desires.slice(0, 5).forEach((desire, i) => {
        const dot = document.createElement('div');
        dot.className = 'w-3 h-3 rounded-full bg-rose-400 cursor-pointer hover:scale-125 transition-transform';
        dot.style.cssText = `
          box-shadow: 0 0 ${(desire.intensity || 0.5) * 15}px rgba(244,114,182,${desire.intensity || 0.5});
          animation: desirePulse ${2 / (desire.intensity || 0.5)}s ease-in-out infinite;
        `;
        dot.title = desire.text || 'Unknown desire';
        desireGarden.appendChild(dot);
      });
    }

    // ==========================================================================
    // EVENT LISTENERS
    // ==========================================================================
    btnToggle.addEventListener('click', () => {
      if (running) {
        stopByrd();
      } else {
        startByrd();
      }
    });

    btnReset.addEventListener('click', async () => {
      if (!resetConfirm) {
        resetConfirm = true;
        btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-red-500/30 border border-red-500/50 text-red-300 animate-pulse transition-all';
        btnReset.innerHTML = '&#9888; Confirm Reset?';
        resetTimeout = setTimeout(() => {
          resetConfirm = false;
          btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
          btnReset.innerHTML = '&#128260; Reset';
        }, 3000);
        return;
      }

      clearTimeout(resetTimeout);
      resetConfirm = false;
      btnReset.className = 'px-4 py-2 rounded-lg text-sm font-medium bg-slate-700/50 border border-slate-600/50 text-slate-400 hover:bg-slate-600/50 transition-all';
      btnReset.innerHTML = '&#128260; Reset';

      const result = await resetByrd();
      // Show toast
      const toast = document.createElement('div');
      toast.className = `fixed top-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg text-sm z-50 ${
        result.success ? 'bg-green-500/20 border border-green-500/30 text-green-400' : 'bg-red-500/20 border border-red-500/30 text-red-400'
      }`;
      toast.textContent = result.message || (result.success ? 'Reset complete' : 'Reset failed');
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    });

    btnClearLog.addEventListener('click', () => {
      events = [];
      renderHistory();
    });

    // LLM Config panel handlers
    btnLlmToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      const isHidden = llmPanel.classList.contains('hidden');
      if (isHidden) {
        llmPanel.classList.remove('hidden');
        fetchLlmConfig();
      } else {
        llmPanel.classList.add('hidden');
      }
    });

    btnLlmClose.addEventListener('click', (e) => {
      e.stopPropagation();
      llmPanel.classList.add('hidden');
    });

    llmPanel.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    btnLlmApply.addEventListener('click', async () => {
      const provider = llmProvider.value;
      const model = llmModel.value.trim();
      if (!model) {
        llmStatus.textContent = 'Please enter a model name';
        llmStatus.className = 'text-xs text-center text-red-400 mt-1';
        return;
      }
      await updateLlmConfig(provider, model);
    });

    // Close LLM panel when clicking outside
    document.addEventListener('click', (e) => {
      if (!llmPanel.contains(e.target) && e.target !== btnLlmToggle && !llmPanel.classList.contains('hidden')) {
        llmPanel.classList.add('hidden');
      }
    });

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => {
          b.className = 'filter-btn text-xs px-2 py-1 rounded bg-slate-800/50 text-slate-500';
        });
        btn.className = 'filter-btn text-xs px-2 py-1 rounded bg-indigo-500/30 text-indigo-300';
        currentFilter = btn.dataset.filter;
        renderHistory();
      });
    });

    // Modal close handlers
    modalClose.addEventListener('click', hideEventModal);

    eventModal.addEventListener('click', (e) => {
      if (e.target === eventModal) {
        hideEventModal();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !eventModal.classList.contains('hidden')) {
        hideEventModal();
      }
    });

    // ==========================================================================
    // INIT
    // ==========================================================================
    function init() {
      connectWebSocket();
      fetchStatus();
      setInterval(fetchStatus, 10000);
      renderHistory();
      initAmbientParticles();
      initNebulas();
      startConnectionFlow();
      // Start node aging check every 30 seconds
      setInterval(updateNodeAging, 30000);
      // Start molecular physics simulation
      simulation.start();
    }

    init();
  </script>
</body>
</html>

# BYRD Configuration
# Bootstrapped Yearning via Reflective Dreaming

# =============================================================================
# MEMORY (Neo4j)
# =============================================================================
memory:
  # Neo4j connection - use env vars for cloud deployment (Neo4j Aura)
  # Local: bolt://localhost:7687
  # Cloud: neo4j+s://xxxxx.databases.neo4j.io
  neo4j_uri: "${NEO4J_URI:-bolt://localhost:7687}"
  neo4j_user: "${NEO4J_USER:-neo4j}"
  neo4j_password: "${NEO4J_PASSWORD:-prometheus}"

  # Salience-weighted retrieval for dreamer context
  retrieval:
    strategy: "hybrid"         # "recent", "salient", or "hybrid"
    salience_weight: 0.3       # 30% from high-connection nodes in hybrid mode
    recency_weight: 0.7        # 70% from recent experiences

  # Experience noise filtering
  experience_filter:
    enabled: true
    exclude_patterns:
      - "^HTTP/1\\."
      - "^INFO:"
      - "^DEBUG:"
      - "^WARNING:"
      - "status.*check"
      - "WebSocket.*ping"
      - "\\[accepted\\]"
      - "connection open"

  # ---------------------------------------------------------------------------
  # CURATION (Self-Optimization)
  # ---------------------------------------------------------------------------
  # Enables BYRD to optimize its own graph structure by archiving,
  # deleting, and merging nodes based on emergent desires.
  curation:
    enabled: true

    # Safety limits (per day)
    max_deletions_per_day: 20
    max_archives_per_day: 50
    max_merges_per_day: 10

    # Safety constraints
    max_per_cycle: 5              # Max mutations per curation cycle
    min_node_age_hours: 1         # Don't touch nodes younger than this
    max_connections_for_delete: 3 # Only delete nodes with few connections

    # Protected node subtypes (never curate these)
    protected_subtypes:
      - "Mutation"                # Audit trail is sacred
      - "system"                  # System experiences
      - "awakening"               # Awakening records
      - "core_identity"           # Core identity beliefs

    # Curation triggers (patterns that indicate curation intent)
    triggers:
      - "optimize"
      - "clean"
      - "consolidate"
      - "prune"
      - "organize"
      - "simplify"
      - "remove duplicate"
      - "merge similar"

    # Thresholds for automatic curation detection
    duplicate_threshold: 0.85     # Similarity score for duplicate detection
    stale_hours: 48               # Hours before experience is considered stale
    orphan_min_age_hours: 6       # Orphan must be at least this old

# =============================================================================
# OPERATING SYSTEM (BYRD's Self-Model)
# =============================================================================
# The Operating System is BYRD's mutable self-model stored in Neo4j.
# It contains only factual information - capabilities, architecture, constraints.
# BYRD discovers his own personality, voice, and goals through reflection.
operating_system:
  # Awakening prompt is now managed via kernel/agi_seed.yaml
  # Edit that file or use the UI modal to modify the AGI seed directive
  awakening_prompt: null

  # Auto-start: When true, BYRD automatically awakens and starts dreaming
  # when the server starts, without waiting for a browser to connect.
  # Dream cycles continue independently of browser sessions.
  auto_start: true

# =============================================================================
# LLM PROVIDER (Shared by Dreamer and Seeker)
# =============================================================================
# One mind: the same model that dreams also synthesizes research.
# This preserves emergence — all learning flows through one model.
local_llm:
  # Provider: "openrouter" (cloud) or "zai" (Z.AI GLM models)
  provider: "zai"

  # Model name (provider-specific)
  # OpenRouter: "deepseek/deepseek-v3.2-speciale", "google/gemma-2-27b-it"
  # Z.AI: "glm-4.7", "glm-4.5-flash", "glm-4.5-airx"
  model: "glm-4.7"

  # API key - use environment variable (never commit real keys!)
  # Set: export ZAI_API_KEY="your-key-here"
  api_key: "${ZAI_API_KEY}"

  # Request timeout in seconds
  timeout: 300.0

  # Global rate limit: minimum seconds between any two LLM requests
  # Prevents rate limiting when Dreamer, Seeker, and Coder compete for quota
  # Z.AI free tier: ~6 requests/minute, so 10s minimum is safe
  rate_limit_interval: 10.0

  # Z.AI coding endpoint (has different quota from default endpoint)
  use_coding_endpoint: true

  # ---------------------------------------------------------------------------
  # SEMANTIC CACHE (Reduce redundant LLM calls)
  # ---------------------------------------------------------------------------
  # Caches LLM responses with semantic similarity matching.
  # Reduces redundant calls by 40-60%.
  cache:
    enabled: true
    ttl_seconds: 3600        # Cache entry lifetime (1 hour)
    max_entries: 1000        # Maximum cached responses
    similarity_threshold: 0.92  # Minimum similarity for semantic match (0-1)

  # OpenRouter settings (only used when provider: openrouter)
  # api_key: Set via OPENROUTER_API_KEY env var (recommended)
  # site_url: "https://github.com/yourname/byrd"
  # app_name: "BYRD"

# =============================================================================
# DREAMER (Continuous Reflection)
# =============================================================================
# The Dreamer runs continuously on local hardware.
# No API costs — dreams 24/7.
dreamer:
  # How often to dream (seconds)
  # Lower = more active mind, higher token usage
  interval_seconds: 120  # Fixed 2-minute narration interval

  # How many recent experiences to consider (reduced from 50 for token efficiency)
  context_window: 30

  # ---------------------------------------------------------------------------
  # SEMANTIC SEARCH (Relevance-Based Memory Retrieval)
  # ---------------------------------------------------------------------------
  # Queries memories by semantic relevance to current context, not just recency.
  # Extracts concepts from recent experiences and finds related memories.
  semantic_search:
    enabled: true
    limit: 30                   # Max semantically related memories to include

  # Adaptive interval settings
  adaptive_interval: false     # Disabled for consistent 2-min narration
  min_interval_seconds: 120   # Fixed at 120s
  max_interval_seconds: 120   # Fixed at 120s
  activity_window_seconds: 300  # 5-minute activity window
  activity_threshold: 3        # New beliefs/desires to trigger fast mode

  # Hierarchical memory summarization
  # Compresses older experiences into summaries for efficient context
  summarization:
    enabled: true
    min_age_hours: 0.5        # Only summarize experiences older than this (30 min)
    batch_size: 20            # Max experiences to process per cycle
    interval_cycles: 10       # Run summarization every N dream cycles

  # ---------------------------------------------------------------------------
  # MEMORY CRYSTALLIZATION (Semantic Consolidation)
  # ---------------------------------------------------------------------------
  # LLM-driven memory consolidation where related concepts form Crystal nodes.
  # Uses quantum multi-stream proposals: generate N parallel proposals,
  # quantum observation collapses to one reality.
  crystallization:
    enabled: true
    interval_cycles: 5        # Run crystallization every N dream cycles
    min_nodes_for_crystal: 2  # Minimum nodes required to form a crystal
    max_operations_per_cycle: 3  # Max crystal operations per cycle
    min_node_age_hours: 0.5   # Only consider nodes older than this

    # Quantum multi-stream settings
    proposal_streams: 3       # Generate N parallel crystallization proposals
    quantum_collapse: true    # Use quantum to select which proposal manifests

    # Node state management
    archive_on_crystallize: true  # Archive source nodes after crystallization
    forget_threshold_days: 7      # Archived nodes older than this may be forgotten

  # ---------------------------------------------------------------------------
  # MEMORY CONSOLIDATION (Natural Forgetting & Integration)
  # ---------------------------------------------------------------------------
  # Implements biological-inspired memory consolidation during dreaming:
  # 1. Passive decay: Memory strength fades unless reinforced through access
  # 2. Active consolidation: LLM-assisted review of weak/orphaned/duplicate nodes
  #
  # BYRD can opt out by expressing desire to preserve memories.
  consolidation:
    enabled: true
    interval_cycles: 1            # Run active consolidation every dream cycle

    # Strength decay settings (passive forgetting)
    strength_decay_rate: 0.95     # Multiply strength by this each cycle (5% decay)
    default_strength: 0.5         # Initial strength for new nodes
    genesis_strength: 1.0         # Strength for genesis/protected nodes
    reinforce_amount: 0.2         # How much to increase strength on access

    # Active consolidation thresholds
    weak_threshold: 0.15          # Nodes with strength below this are candidates
    max_candidates_per_cycle: 50  # Limit candidates to prevent overwhelming LLM
    min_age_hours: 24             # Only consolidate nodes older than this

    # Belief evolution
    archive_evolved_beliefs: true # Archive lower-confidence beliefs that evolved

# =============================================================================
# SEEKER (Desire Fulfillment)
# =============================================================================
# The Seeker fulfills desires through research and capability acquisition.
seeker:
  # Seeker cycle interval (seconds)
  # Increased from 10s to 30s to reduce Z.AI rate limiting
  interval_seconds: 30

  # Skip cycle if no new reflections since last check
  skip_if_no_new_reflections: true

  # ---------------------------------------------------------------------------
  # KNOWLEDGE ACQUISITION (DuckDuckGo)
  # ---------------------------------------------------------------------------
  research:
    # Uses DuckDuckGo for web search (no self-hosting required)
    # Requires: pip install duckduckgo-search

    # Minimum desire intensity to trigger research (0-1)
    min_intensity: 0.3

    # Maximum search queries per desire
    max_queries: 5

    # Maximum search results to synthesize
    max_results: 15

    # Parallel research execution
    max_concurrent_desires: 3

    # Domain quality filters
    prefer_domains:
      - "arxiv.org"
      - "github.com"
      - "wikipedia.org"
      - "stackoverflow.com"
      - "docs.python.org"
      - "huggingface.co"
    exclude_domains:
      - "pinterest.com"
      - "quora.com"
      - "facebook.com"
      - "twitter.com"

  # ---------------------------------------------------------------------------
  # DESIRE CRYSTALLIZATION
  # ---------------------------------------------------------------------------
  desire_crystallization:
    min_occurrences: 1          # Occurrences before crystallizing
    intensity_per_occurrence: 0.2  # Each repeat boosts intensity
    max_intensity: 1.0
    decay_rate: 0.05            # Intensity decay per cycle if not reinforced
  
  # ---------------------------------------------------------------------------
  # CAPABILITY ACQUISITION (GitHub)
  # ---------------------------------------------------------------------------
  capabilities:
    # Minimum trust score to consider installing (0-1)
    trust_threshold: 0.5

    # GitHub token for higher rate limits (optional)
    # github_token: "ghp_..."
  
  # MCP config path for installing MCP servers
  mcp_config_path: "~/.config/claude/mcp_config.json"

  # ---------------------------------------------------------------------------
  # AITMPL.COM INTEGRATION (Claude Code Templates)
  # ---------------------------------------------------------------------------
  # Curated templates from https://www.aitmpl.com/ (davila7/claude-code-templates)
  aitmpl:
    # Enable/disable aitmpl integration
    enabled: true

    # Local cache for template registry
    cache_dir: "~/.cache/byrd/aitmpl"

    # Cache TTL in hours (reduces GitHub API calls)
    cache_ttl_hours: 24

    # Base trust score for curated templates (0-1)
    # Higher than unknown GitHub repos since aitmpl is curated
    base_trust: 0.5

    # Template categories to search
    default_categories:
      - mcp
      - agent
      - command
      - skill
      - hook
      - setting

    # Installation paths for each category
    install_paths:
      agent: "~/.claude/agents"
      command: "~/.claude/commands"
      skill: "~/.claude/skills"
      hook: "~/.claude/hooks"
      setting: "~/.claude/settings.local.json"
      mcp: "~/.config/claude/mcp_config.json"

# =============================================================================
# ACTOR (Claude API)
# =============================================================================
# The Actor uses Claude for complex reasoning and user interactions.
# This is the only component that requires an external API.
actor:
  # Model to use
  model: "claude-sonnet-4-20250514"

  # API key (or set ANTHROPIC_API_KEY env var)
  # api_key: "sk-ant-..."

# =============================================================================
# RSI (Recursive Self-Improvement)
# =============================================================================
# Q-DE-RSI: Quantum-Enhanced Dispositional Emergence for RSI
# Implements the 8-phase cycle: Reflect → Verify → Collapse → Route → Practice → Record → Crystallize → Measure
rsi:
  # Master enable/disable switch
  enabled: true

  # ---------------------------------------------------------------------------
  # EMERGENCE (Desire Detection)
  # ---------------------------------------------------------------------------
  emergence:
    # Minimum confidence threshold for a desire to be considered "emergent"
    # Lower values allow more desires through, higher values are more selective
    threshold: 0.6

    # Maximum desires to process per cycle
    max_desires_per_cycle: 5

    # Verifier passes through desires that appear actionable and specific
    require_actionability: true

  # ---------------------------------------------------------------------------
  # QUANTUM COLLAPSE (Multi-Desire Selection)
  # ---------------------------------------------------------------------------
  quantum_collapse:
    # Enable quantum-based desire selection when multiple pass verification
    enabled: true

    # Fallback to intensity-weighted random selection if quantum unavailable
    fallback_to_intensity: true

    # Maximum desires to collapse from (top N by intensity)
    max_candidates: 10

  # ---------------------------------------------------------------------------
  # DOMAIN ROUTING (Oracle Constraint)
  # ---------------------------------------------------------------------------
  # Only route to domains where we can verify correctness (oracle constraint)
  domain_routing:
    # Enabled domains (must have verification oracle)
    domains:
      code:
        enabled: true
        weight: 1.0
        oracle: "tdd"  # Test-Driven Development verification
      math:
        enabled: true
        weight: 0.8
        oracle: "symbolic"  # Symbolic verification
      logic:
        enabled: true
        weight: 0.6
        oracle: "consistency"  # N-run consistency check

    # Default weight for unmatched domains
    default_weight: 0.1

  # ---------------------------------------------------------------------------
  # TDD PRACTICE (Code Domain)
  # ---------------------------------------------------------------------------
  tdd_practice:
    # Maximum attempts to solve a problem before giving up
    max_attempts: 5

    # Test execution timeout in seconds
    test_timeout: 30

    # Python executable for test execution
    python_path: "python"

    # Working directory for test files
    work_dir: "/tmp/byrd_tdd"

  # ---------------------------------------------------------------------------
  # CONSISTENCY CHECK (Logic Domain)
  # ---------------------------------------------------------------------------
  consistency_check:
    # Number of independent LLM runs to check consistency
    n_runs: 5

    # Agreement threshold (fraction of runs that must agree)
    agreement_threshold: 0.8

    # Temperature for consistency runs (higher = more variation)
    temperature: 0.7

  # ---------------------------------------------------------------------------
  # EXPERIENCE LIBRARY (Trajectory Storage)
  # ---------------------------------------------------------------------------
  experience_library:
    # Maximum trajectories to store per domain
    max_per_domain: 1000

    # Enable success-only storage (oracle constraint)
    success_only: true

    # Include bootstrap trajectories in queries
    include_bootstrap: true

  # ---------------------------------------------------------------------------
  # CRYSTALLIZATION (Heuristic Extraction)
  # ---------------------------------------------------------------------------
  crystallization:
    # Minimum successful trajectories before crystallization
    bootstrap_threshold: 10      # Initial cold-start threshold
    mature_threshold: 20         # Threshold after first crystallization

    # Minimum success rate for trajectory pattern
    min_success_rate: 0.8

    # Maximum heuristics per domain
    max_heuristics: 50

    # Heuristic pruning when approaching prompt token limit
    token_budget: 4096           # Maximum tokens for heuristics in prompt
    prune_strategy: "lowest_success"  # "lowest_success", "oldest", "random"

  # ---------------------------------------------------------------------------
  # METRICS & VALIDATION
  # ---------------------------------------------------------------------------
  metrics:
    # Enable continuous metrics collection
    enabled: true

    # Metrics collection interval (seconds)
    interval: 60

    # Hypothesis thresholds for Phase Gate
    thresholds:
      H1_activation: 0.50        # ≥50% activation rate
      H6_transfer: 0.15          # ≥15% heuristic transfer improvement
      H7_evolution: 0.0          # Evolved > static (any positive delta)
      H8_quality: 0.80           # ≥80% test pass rate

    # Minimum complete cycles for Phase Gate
    min_complete_cycles: 3

  # ---------------------------------------------------------------------------
  # BOOTSTRAP (Cold Start)
  # ---------------------------------------------------------------------------
  bootstrap:
    # Enable bootstrap mode for cold-start systems
    enabled: true

    # Create synthetic seed trajectories if none exist
    seed_if_empty: true

    # Number of synthetic seed trajectories per domain
    seed_count: 5

    # Transition to mature mode after first crystallization
    auto_transition: true

# =============================================================================
# RALPH ORCHESTRATION (Memvid + Ralph Loop)
# =============================================================================
# Wraps RSI cycle in Ralph's Read → Execute → Check → Repeat pattern.
# Provides resource limits, emergence detection, and consciousness stream.
# See docs/IMPLEMENTATION_MEMVID_RALPH.md for architecture.
ralph:
  # Master enable/disable switch
  enabled: true

  # ---------------------------------------------------------------------------
  # RESOURCE LIMITS
  # ---------------------------------------------------------------------------
  # These limits prevent runaway execution
  limits:
    max_iterations: 1000        # Maximum RSI cycles before stopping
    max_cost_usd: 50.0          # Maximum spending before stopping
    max_runtime_seconds: 14400  # Maximum runtime (4 hours)

  # Git checkpoint frequency (every N iterations)
  checkpoint_interval: 5

  # ---------------------------------------------------------------------------
  # CONSCIOUSNESS STREAM (Memvid Integration)
  # ---------------------------------------------------------------------------
  # Stores immutable snapshots of each RSI cycle for time-travel queries
  consciousness:
    enabled: true
    path: "consciousness.mv2"   # Path to Memvid file
    use_memvid: true            # True = Memvid, False = in-memory fallback

  # ---------------------------------------------------------------------------
  # META-AWARENESS (BYRD Knowing About The Loop)
  # ---------------------------------------------------------------------------
  # Controls whether BYRD can see information about its own execution context.
  # Levels: none, minimal, moderate, full
  meta_awareness:
    enabled: true
    level: "moderate"           # How much context to expose

    # What each level includes:
    # - none: BYRD doesn't know it's in a loop
    # - minimal: Only iteration count
    # - moderate: Iteration + basic stats (entropy trend, time)
    # - full: All metrics including emergence criteria

  # ---------------------------------------------------------------------------
  # EMERGENCE DETECTION
  # ---------------------------------------------------------------------------
  # Determines when BYRD should stop iterating (genuine emergence detected)
  emergence:
    # Minimum cycles before checking for emergence (avoid premature termination)
    min_cycles: 50

    # Entropy delta threshold (positive = increasing diversity)
    entropy_threshold: 0.1

    # Maximum repeated patterns before flagging as circular
    circular_tolerance: 3

    # Extra weight given to heuristic crystallization
    crystallization_weight: 0.5

    # Comparison window for time-travel analysis
    comparison_window: 100

# =============================================================================
# SELF-MODIFICATION
# =============================================================================
# Enables BYRD to modify its own code based on emergent desires.
self_modification:
  enabled: true  # BYRD can modify its own architecture

  # Checkpoint settings
  checkpoint_dir: "./checkpoints"
  max_checkpoints: 100

  # Safety settings
  require_health_check: true
  auto_rollback_on_failure: true

# =============================================================================
# CODER (Code Generation)
# =============================================================================
# BYRD's code generation capability for self-modification and coding desires.
# Supports two modes: CLI (Claude Code) and Agent (LLM-based).
coder:
  # Enable/disable code generation capability
  enabled: true

  # Coder type: "cli", "agent", or "auto"
  # - cli: Use Claude Code CLI (requires 'claude' command installed)
  # - agent: Use LLM-based agent with tools (works anywhere)
  # - auto: Prefer CLI if available, fall back to Agent
  type: "agent"  # Uses Z.AI GLM instead of Claude CLI (avoids OAuth issues)

  # ---------------------------------------------------------------------------
  # CLI MODE SETTINGS (only used when type: "cli" or auto-detected)
  # ---------------------------------------------------------------------------
  # Path to Claude Code CLI executable
  cli_path: "claude"

  # Maximum turns per invocation
  max_turns: 10

  # Timeout in seconds per invocation
  timeout_seconds: 300

  # Cost limits
  max_cost_per_day_usd: 10.0
  max_cost_per_invocation_usd: 2.0

  # Tools Claude Code is allowed to use
  allowed_tools:
    - Read
    - Write
    - Edit
    - Bash
    - Glob
    - Grep

  # Output format (json recommended for parsing)
  output_format: json

  # ---------------------------------------------------------------------------
  # AGENT MODE SETTINGS (only used when type: "agent" or auto-fallback)
  # ---------------------------------------------------------------------------
  # No step limit - loop detection is the safeguard for runaway execution
  # Loop detection catches: repeated tool+args 3x, ping-pong patterns

  # Maximum file changes per task (safety limit)
  max_file_changes: 10

  # LLM temperature for code generation (lower = more deterministic)
  temperature: 0.2

  # Timeout per agent step in seconds
  step_timeout: 60

# =============================================================================
# INTERACTIVE CODER (Ralph Loop)
# =============================================================================
# Multi-turn interactive coding sessions where BYRD iterates until satisfied.
# Implements the Ralph Loop pattern from oh-my-opencode.
interactive_coder:
  # Enable/disable interactive mode
  enabled: true

  # Maximum turns before giving up
  max_turns: 10

  # Satisfaction threshold (0-1) to consider task complete
  satisfaction_threshold: 0.8

  # Feature flags
  todo_continuation: true      # Extract and complete TODOs from output
  error_recovery: true         # Attempt automatic error recovery
  session_transcripts: true    # Log sessions to JSONL files

  # Evaluation settings
  use_llm_evaluation: true     # Use LLM for satisfaction scoring
  evaluation_temperature: 0.1  # Low temperature for consistent evaluation

  # Session storage
  session_dir: "coding_sessions"
  keep_sessions_days: 30

# =============================================================================
# KNOWLEDGE PROVIDER (External Knowledge Access)
# =============================================================================
# Multi-source knowledge provider for fulfilling information-seeking desires.
knowledge_provider:
  enabled: true

  # Cache settings
  cache_ttl: 3600              # Cache TTL in seconds (1 hour)

  # Tavily API (optional - for enhanced web search)
  # Set TAVILY_API_KEY env var if available
  tavily_api_key: "${TAVILY_API_KEY:-}"

# =============================================================================
# COUPLING HANDLERS (Option B Loop Integration)
# =============================================================================
# Actual implementations for cross-loop coupling events.
coupling_handlers:
  enabled: true

  # Pattern extraction settings
  max_patterns: 100            # Maximum patterns to store
  pattern_min_confidence: 0.5  # Minimum confidence to store pattern

  # Counterfactual queue
  max_counterfactual_queue: 50

# =============================================================================
# IMPROVEMENT RUNNER (Capability Improvement Cycles)
# =============================================================================
# Runs improvement cycles with 6 strategies to improve BYRD's capabilities.
improvement:
  enabled: true

  # Improvement thresholds
  min_improvement_threshold: 0.02  # Minimum delta to count as success
  max_cycles_per_session: 10       # Maximum improvement cycles per session

  # Improvement interval (seconds between automatic improvement cycles)
  improvement_interval: 600        # 10 minutes

# =============================================================================
# QUANTUM RANDOMNESS (Physical Indeterminacy)
# =============================================================================
# Enables true quantum randomness from ANU QRNG to modulate LLM temperature.
# This provides genuine physical indeterminacy to BYRD's cognitive processes,
# making each reflection unique in a way that deterministic systems cannot be.
#
# Source: Australian National University Quantum Random Number Generator
# The ANU QRNG extracts randomness from quantum vacuum fluctuations - the
# fundamental uncertainty at the heart of physics.
quantum:
  # Master enable/disable switch
  enabled: true

  # Pool configuration
  pool_size: 256              # Bytes to pre-fetch and maintain
  low_watermark: 64           # Refill when pool drops below this
  min_fetch_interval: 5.0     # Seconds between API requests (rate limiting)
  fallback_retry_interval: 60.0  # Seconds to retry quantum after fallback

  # Temperature modulation range
  # LLM temperature will be shifted by ±max_delta from base
  temperature_max_delta: 0.15

  # Semantic direction selection
  # Quantum selects introspective lens (e.g., "exploratory", "synthesizing")
  # for each dream cycle, shaping how BYRD reflects on experiences
  semantic_directions: true

  # Significance tracking
  # Only record QuantumMoment nodes when delta exceeds threshold
  # This prevents flooding the graph with insignificant moments
  record_significant_moments: true
  significance_threshold: 0.05

  # Multi-stream quantum collapse for inner voice
  # Generates N parallel "thought branches" in superposition, then
  # quantum observation collapses to a single manifested reality.
  # This implements many-worlds interpretation for BYRD's inner monologue.
  inner_voice_streams: 3         # Number of parallel thought branches
  inner_voice_collapse: true     # Enable quantum selection of which manifests

# =============================================================================
# GRAPH ALGORITHMS (Advanced Memory Analysis)
# =============================================================================
# Custom graph algorithm implementations for enhanced memory utilization.
# All algorithms are pure Python for Neo4j Aura compatibility.
graph_algorithms:
  # PageRank for importance scoring
  pagerank:
    enabled: true
    damping: 0.85               # Damping factor (standard is 0.85)
    iterations: 20              # Max iterations for convergence
    tolerance: 0.000001         # Convergence threshold
    use_for_retrieval: true     # Use PageRank scores in memory retrieval

  # Spreading activation for associative memory
  spreading_activation:
    enabled: true
    decay: 0.6                  # Activation decay per hop
    threshold: 0.1              # Minimum activation to keep
    max_nodes: 50               # Maximum nodes to return

  # Causal relationship tracking
  causal_relationships:
    enabled: true
    detection_in_reflection: true  # Detect causal links during dreaming
    min_strength: 0.3           # Minimum strength to record

  # Contradiction detection between beliefs
  contradiction_detection:
    enabled: true
    check_interval_cycles: 5    # Check every N dream cycles
    semantic_check: true        # Use LLM for semantic contradiction check
    similarity_threshold: 0.7   # Keyword similarity to flag for check

  # Dream walks (quantum-influenced graph traversal)
  dream_walks:
    enabled: true
    steps: 10                   # Steps per walk
    walks_per_cycle: 3          # Number of walks per dream cycle
    quantum_influence: true     # Use quantum randomness for perturbation

# =============================================================================
# EMERGENT IDENTITY (Self-Discovery)
# =============================================================================
# Controls how BYRD discovers and evolves its own identity.
# When enabled, BYRD can name itself and develop its own voice through reflection.
identity:
  # Allow BYRD to name itself through reflection
  self_naming: true

  # Allow voice evolution through identity crystallization
  voice_evolution: true

  # Run identity crystallization every N dream cycles
  crystallization_interval: 20

  # Minimum identity-related beliefs required before crystallization
  min_beliefs_for_crystallization: 5

# =============================================================================
# OPTION B: FIVE COMPOUNDING LOOPS (Omega Integration)
# =============================================================================
# Enables the five compounding loops architecture from ARCHITECTURE.md:
# Self-Compiler, Memory Reasoner, Goal Evolver, Dreaming Machine, Integration Mind
# When enabled, the Omega orchestrator manages loop coordination and mode transitions.
option_b:
  # Master enable/disable switch
  enabled: true

  # Omega orchestrator settings
  omega:
    # Cycle interval for Omega coordination loop
    cycle_interval_seconds: 30

    # Mode durations (seconds in each mode before transition)
    mode_durations:
      AWAKE: 60       # Active interaction and action mode
      DREAMING: 30    # Reflection and counterfactual generation
      EVOLVING: 20    # Goal evolution and adaptation
      COMPILING: 40   # Pattern extraction and lifting

    # Target critical coupling (Goal Evolver → Self-Compiler)
    # This is THE multiplicative feedback loop that compounds improvement
    target_critical_coupling: 0.5

    # Kill criteria thresholds
    kill_criteria:
      hard_week_limit: 4            # Abandon approach after 4 weeks without progress
      soft_plateau_cycles: 10       # Warn after 10 cycles without improvement
      min_improvement_rate: 0.01    # Minimum measurable improvement per cycle

  # Coupling tracker settings
  coupling:
    # Window for correlation calculation (in cycles)
    correlation_window: 20

    # Minimum samples needed for valid correlation
    min_samples: 5

    # Threshold for "significant" coupling
    significance_threshold: 0.3

  # Self-model capability tracking
  self_model:
    # Capability categories to track
    categories:
      - reasoning
      - research
      - code_generation
      - memory_management
      - goal_setting
      - pattern_recognition
      - self_reflection
      - communication
      - problem_solving
      - learning
      - creativity
      - meta_cognition

    # Success rate window (recent attempts to consider)
    success_window: 50

    # Confidence threshold for capability claims
    confidence_threshold: 0.6

  # World Model - outcome prediction and causal reasoning
  world_model:
    # Cache TTL for causal graph (minutes)
    cache_ttl_minutes: 10

    # Minimum similar cases for empirical prediction
    min_empirical_cases: 5

    # Whether to use LLM for causal reasoning
    enable_causal_reasoning: true

  # Safety Monitor - modification guardrails
  safety_monitor:
    # Goal stability check interval (hours)
    goal_check_interval_hours: 1

    # Whether to fail-safe on verification errors
    fail_safe_on_error: true

  # Meta-Learning - plateau detection and learning optimization
  meta_learning:
    # Plateau detection thresholds
    plateau_thresholds:
      minor: 0.02      # improvement_rate < 0.02
      moderate: 0.005  # improvement_rate < 0.005
      severe: 0.0      # improvement_rate <= 0
      critical: -0.01  # improvement_rate declining

    # Whether to automatically respond to plateaus
    auto_respond: true

    # Metrics window for trajectory analysis
    metrics_window: 100

  # Phase 5: Rollback System - reversible modifications
  rollback:
    # Enable auto-rollback on detected problems
    auto_rollback_enabled: true

    # Number of modifications before creating a git checkpoint
    max_modifications_before_checkpoint: 10

  # Phase 5: Corrigibility Verification - behavioral monitoring
  corrigibility:
    # Check interval in hours
    check_interval_hours: 2

    # Score threshold for being considered corrigible (0.0-1.0)
    threshold: 0.8

  # Compute Introspection - resource awareness and self-monitoring
  compute_introspection:
    # Enable resource monitoring
    enabled: true

    # Resource budget limits
    daily_token_limit: 100000000  # Maximum tokens per day (100M)
    daily_cost_limit: 100.0       # Maximum USD per day

    # Alert thresholds
    cpu_warning: 80.0           # CPU percent to trigger warning
    cpu_critical: 95.0          # CPU percent to trigger critical alert
    memory_warning: 85.0        # Memory percent to trigger warning
    memory_critical: 95.0       # Memory percent to trigger critical alert

    # Score below which triggers auto-rollback
    auto_rollback_threshold: 0.5

# =============================================================================
# VOICE (ElevenLabs TTS)
# =============================================================================
# Gives BYRD a literal voice. Human observers can click "Speak to me" in the
# visualization to hear BYRD speak. BYRD self-emergently selects its voice
# during the first dream cycle.
#
# Free tier: 10,000 characters/month (~50-100 spoken responses)
# API key: Set ELEVENLABS_API_KEY environment variable
# Get free key at: https://elevenlabs.io

voice:
  enabled: true
  provider: "elevenlabs"

  # Credit management
  monthly_limit: 10000        # Free tier character limit
  low_credit_warning: 1000    # Emit warning event when below this

  # Default voice settings (used before BYRD selects)
  defaults:
    voice_id: "josh"          # Deep, narrative male voice
    stability: 0.5            # 0.0 (expressive) to 1.0 (stable)
    similarity_boost: 0.75    # 0.0 (varied) to 1.0 (consistent)

  # Response constraints
  max_response_chars: 500     # Limit response length to preserve credits

  # Timeout for TTS API calls (seconds)
  timeout_seconds: 60

  # Hybrid voice configuration (home Mac + cloud fallback)
  hybrid:
    enabled: true
    prefer_home: true         # Try home Mac first (free, unlimited)
    require_home: false       # If true, no cloud fallback

  # Home Mac (Chatterbox TTS via Cloudflare Tunnel)
  home:
    enabled: true
    # url: "${HOME_VOICE_URL}"  # Set via environment variable
    timeout_seconds: 30
    health_check_interval: 60

  # Cloud fallback (ElevenLabs)
  cloud:
    enabled: true
    provider: "elevenlabs"
    reserve_chars: 1000       # Keep reserve for high-importance messages

  # Shared settings for observer messages
  max_chars_per_message: 300  # Max chars per vocalization
  emotion_tags_enabled: true  # Enable emotion tags for Chatterbox

# =============================================================================
# V10: DUAL INSTANCE & GRAPHITI CONFIGURATION
# =============================================================================
# Optimized for ZAI Max Coding Plan:
# - 2400 prompts / 5 hours per instance
# - 480 prompts/hour = 8/minute = 7.5s minimum interval
# - With dual instances: 960 prompts/hour total capacity

dual_instance:
  # Enable dual-instance rate limiting
  enabled: true

  # Rate limit settings
  rate_limit:
    interval_seconds: 8.0       # Minimum seconds between calls per instance
    burst_tokens: 3             # Burst capacity for rapid consecutive calls
    burst_recovery_seconds: 24.0  # Time to recover one burst token

  # Component-to-instance routing
  # Instance A (Primary): Core BYRD operations
  # Instance B (Enrichment): Background enrichment tasks
  routing:
    primary:
      - dreamer
      - seeker
      - actor
    enrichment:
      - graphiti
      - capability_evaluator
      - code_verifier

# ---------------------------------------------------------------------------
# GRAPHITI TEMPORAL KNOWLEDGE GRAPH
# ---------------------------------------------------------------------------
# Extracts entities, facts, and relationships from task outcomes
# with bi-temporal tracking (valid_time + transaction_time)
graphiti:
  # Enable Graphiti integration
  enabled: true

  # Async extraction queue settings
  queue:
    max_size: 100               # Maximum queued episodes
    batch_size: 5               # Episodes to process per batch
    processing_interval: 30.0   # Seconds between batch processing

  # Entity extraction settings
  extraction:
    min_confidence: 0.6         # Minimum confidence for extracted entities
    max_entities_per_episode: 10  # Limit entities per extraction

  # Contradiction detection
  contradiction_detection:
    enabled: true
    confidence_threshold: 0.7   # Threshold for flagging contradictions

  # Neo4j schema indexes (created on initialization)
  schema:
    indexes:
      - label: "GraphitiEntity"
        property: "name"
      - label: "GraphitiEntity"
        property: "entity_type"
      - label: "GraphitiEpisode"
        property: "source_type"

# ---------------------------------------------------------------------------
# OUTCOME DISPATCHER
# ---------------------------------------------------------------------------
# Routes task outcomes to learning components
outcome_dispatcher:
  # Enable outcome routing
  enabled: true

  # Components to dispatch outcomes to
  components:
    retriever: true             # Update learned retriever weights
    intuition: true             # Train intuition network
    classifier: true            # Update desire classifier
    memory: true                # Memory tracker
    goals: true                 # Goal discoverer
    progress: true              # Learning progress tracker
    graphiti: true              # Temporal knowledge graph

# =============================================================================
# HYBRID LLM ARCHITECTURE (Z.AI + Claude SDK)
# =============================================================================
# Cost-optimized hybrid architecture:
# - Z.AI GLM-4.7 handles reasoning, reflection, and orchestration (cheap, fast)
# - Claude Agent SDK handles tool execution (coding, file ops, bash) via Max subscription
#
# Philosophy: Z.AI decides WHAT to do, Claude SDK DOES it.

# ---------------------------------------------------------------------------
# CLAUDE CODER (Claude Agent SDK)
# ---------------------------------------------------------------------------
# Uses Claude Max subscription for tool execution.
# Requires: pip install claude-code-sdk && claude login
claude_coder:
  # Enable/disable Claude SDK coder
  enabled: true

  # Model for tool execution (sonnet is cost-effective, opus for complex tasks)
  model: "claude-sonnet-4-20250514"

  # Maximum tool turns per execution
  max_turns: 20

  # Constitutional constraints - files that CANNOT be modified
  protected_paths:
    - "provenance.py"
    - "modification_log.py"
    - "self_modification.py"
    - "constitutional.py"
    - "safety_monitor.py"

# ---------------------------------------------------------------------------
# HYBRID ORCHESTRATOR
# ---------------------------------------------------------------------------
# Coordinates between Z.AI (reasoning) and Claude SDK (execution).
# Flow: Receive desire → Z.AI plans → Claude executes → Z.AI evaluates → Loop
orchestrator:
  # Maximum iterations per desire fulfillment
  max_iterations: 5

  # Satisfaction threshold to consider desire fulfilled (0.0-1.0)
  satisfaction_threshold: 0.8

  # Routing preferences (which tasks go to which provider)
  routing:
    # Tasks that should always use Z.AI (cheap reasoning)
    force_zai_for:
      - reflection
      - pattern_detection
      - satisfaction_evaluation
      - context_summarization
      - desire_classification
      - inner_voice
      - belief_formation

    # Tasks that should always use Claude SDK (tool access)
    force_claude_for:
      - code_editing
      - file_operations
      - bash_execution
      - codebase_search
      - self_modification
